/******************************************************************************
* Copyright (c) 2004-2011 O. Dolomanov, OlexSys                               *
*                                                                             *
* This file is part of the OlexSys Development Framework.                     *
*                                                                             *
* This source file is distributed under the terms of the licence located in   *
* the root folder.                                                            *
******************************************************************************/

#ifndef __OLX_FAST_SYMM
#define __OLX_FAST_SYMM
#include "xbase.h"
BeginXlibNamespace()

#define FSymmFactory_a(base, clazz) base* a_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "A112" ) return new clazz<FastSG_A112>;\
  else if( sgName == "A112/a" ) return new clazz<FastSG_A112_a>;\
  else if( sgName == "A112/m" ) return new clazz<FastSG_A112_m>;\
  else if( sgName == "A112/n" ) return new clazz<FastSG_A112_n>;\
  else if( sgName == "A11a" ) return new clazz<FastSG_A11a>;\
  else if( sgName == "A11m" ) return new clazz<FastSG_A11m>;\
  else if( sgName == "A11n" ) return new clazz<FastSG_A11n>;\
  else if( sgName == "A2" ) return new clazz<FastSG_A2>;\
  else if( sgName == "A2/a" ) return new clazz<FastSG_A2_a>;\
  else if( sgName == "A2/m" ) return new clazz<FastSG_A2_m>;\
  else if( sgName == "A2/n" ) return new clazz<FastSG_A2_n>;\
  else if( sgName == "A2122" ) return new clazz<FastSG_A2122>;\
  else if( sgName == "A21am" ) return new clazz<FastSG_A21am>;\
  else if( sgName == "A21ma" ) return new clazz<FastSG_A21ma>;\
  else if( sgName == "A222" ) return new clazz<FastSG_A222>;\
  else if( sgName == "A2aa" ) return new clazz<FastSG_A2aa>;\
  else if( sgName == "A2mm" ) return new clazz<FastSG_A2mm>;\
  else if( sgName == "Aa" ) return new clazz<FastSG_Aa>;\
  else if( sgName == "Aba2" ) return new clazz<FastSG_Aba2>;\
  else if( sgName == "Abaa" ) return new clazz<FastSG_Abaa>;\
  else if( sgName == "Abm2" ) return new clazz<FastSG_Abm2>;\
  else if( sgName == "Abma" ) return new clazz<FastSG_Abma>;\
  else if( sgName == "Abmm" ) return new clazz<FastSG_Abmm>;\
  else if( sgName == "Ac2a" ) return new clazz<FastSG_Ac2a>;\
  else if( sgName == "Ac2m" ) return new clazz<FastSG_Ac2m>;\
  else if( sgName == "Acaa" ) return new clazz<FastSG_Acaa>;\
  else if( sgName == "Acam" ) return new clazz<FastSG_Acam>;\
  else if( sgName == "Acmm" ) return new clazz<FastSG_Acmm>;\
  else if( sgName == "Am" ) return new clazz<FastSG_Am>;\
  else if( sgName == "Am2a" ) return new clazz<FastSG_Am2a>;\
  else if( sgName == "Am2m" ) return new clazz<FastSG_Am2m>;\
  else if( sgName == "Ama2" ) return new clazz<FastSG_Ama2>;\
  else if( sgName == "Amaa" ) return new clazz<FastSG_Amaa>;\
  else if( sgName == "Amam" ) return new clazz<FastSG_Amam>;\
  else if( sgName == "Amm2" ) return new clazz<FastSG_Amm2>;\
  else if( sgName == "Amma" ) return new clazz<FastSG_Amma>;\
  else if( sgName == "Ammm" ) return new clazz<FastSG_Ammm>;\
  else if( sgName == "An" ) return new clazz<FastSG_An>;\
  else return NULL;  }
#define FSymmFactory_b(base, clazz) base* b_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "B112" ) return new clazz<FastSG_B112>;\
  else if( sgName == "B112/b" ) return new clazz<FastSG_B112_b>;\
  else if( sgName == "B112/m" ) return new clazz<FastSG_B112_m>;\
  else if( sgName == "B112/n" ) return new clazz<FastSG_B112_n>;\
  else if( sgName == "B11b" ) return new clazz<FastSG_B11b>;\
  else if( sgName == "B11m" ) return new clazz<FastSG_B11m>;\
  else if( sgName == "B11n" ) return new clazz<FastSG_B11n>;\
  else if( sgName == "B2/b11" ) return new clazz<FastSG_B2_b11>;\
  else if( sgName == "B2/m11" ) return new clazz<FastSG_B2_m11>;\
  else if( sgName == "B2/n11" ) return new clazz<FastSG_B2_n11>;\
  else if( sgName == "B211" ) return new clazz<FastSG_B211>;\
  else if( sgName == "B2212" ) return new clazz<FastSG_B2212>;\
  else if( sgName == "B222" ) return new clazz<FastSG_B222>;\
  else if( sgName == "B2cb" ) return new clazz<FastSG_B2cb>;\
  else if( sgName == "B2cm" ) return new clazz<FastSG_B2cm>;\
  else if( sgName == "B2mb" ) return new clazz<FastSG_B2mb>;\
  else if( sgName == "B2mm" ) return new clazz<FastSG_B2mm>;\
  else if( sgName == "Bb11" ) return new clazz<FastSG_Bb11>;\
  else if( sgName == "Bb21m" ) return new clazz<FastSG_Bb21m>;\
  else if( sgName == "Bb2b" ) return new clazz<FastSG_Bb2b>;\
  else if( sgName == "Bba2" ) return new clazz<FastSG_Bba2>;\
  else if( sgName == "Bbab" ) return new clazz<FastSG_Bbab>;\
  else if( sgName == "Bbcb" ) return new clazz<FastSG_Bbcb>;\
  else if( sgName == "Bbcm" ) return new clazz<FastSG_Bbcm>;\
  else if( sgName == "Bbm2" ) return new clazz<FastSG_Bbm2>;\
  else if( sgName == "Bbmb" ) return new clazz<FastSG_Bbmb>;\
  else if( sgName == "Bbmm" ) return new clazz<FastSG_Bbmm>;\
  else if( sgName == "Bm11" ) return new clazz<FastSG_Bm11>;\
  else if( sgName == "Bm21b" ) return new clazz<FastSG_Bm21b>;\
  else if( sgName == "Bm2m" ) return new clazz<FastSG_Bm2m>;\
  else if( sgName == "Bma2" ) return new clazz<FastSG_Bma2>;\
  else if( sgName == "Bmab" ) return new clazz<FastSG_Bmab>;\
  else if( sgName == "Bmam" ) return new clazz<FastSG_Bmam>;\
  else if( sgName == "Bmcm" ) return new clazz<FastSG_Bmcm>;\
  else if( sgName == "Bmm2" ) return new clazz<FastSG_Bmm2>;\
  else if( sgName == "Bmmb" ) return new clazz<FastSG_Bmmb>;\
  else if( sgName == "Bmmm" ) return new clazz<FastSG_Bmmm>;\
  else if( sgName == "Bn11" ) return new clazz<FastSG_Bn11>;\
  else return NULL;  }

#define FSymmFactory_c(base, clazz) base* c_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "C1" ) return new clazz<FastSG_C1>;\
  else if( sgName == "C2" ) return new clazz<FastSG_C2>;\
  else if( sgName == "C2/c" ) return new clazz<FastSG_C2_c>;\
  else if( sgName == "C2/c11" ) return new clazz<FastSG_C2_c11>;\
  else if( sgName == "C2/m" ) return new clazz<FastSG_C2_m>;\
  else if( sgName == "C2/m11" ) return new clazz<FastSG_C2_m11>;\
  else if( sgName == "C2/n" ) return new clazz<FastSG_C2_n>;\
  else if( sgName == "C2/n11" ) return new clazz<FastSG_C2_n11>;\
  else if( sgName == "C211" ) return new clazz<FastSG_C211>;\
  else if( sgName == "C222" ) return new clazz<FastSG_C222>;\
  else if( sgName == "C2221" ) return new clazz<FastSG_C2221>;\
  else if( sgName == "C2cb" ) return new clazz<FastSG_C2cb>;\
  else if( sgName == "C2cm" ) return new clazz<FastSG_C2cm>;\
  else if( sgName == "C2mb" ) return new clazz<FastSG_C2mb>;\
  else if( sgName == "C2mm" ) return new clazz<FastSG_C2mm>;\
  else if( sgName == "Cc" ) return new clazz<FastSG_Cc>;\
  else if( sgName == "Cc11" ) return new clazz<FastSG_Cc11>;\
  else if( sgName == "Cc2a" ) return new clazz<FastSG_Cc2a>;\
  else if( sgName == "Cc2m" ) return new clazz<FastSG_Cc2m>;\
  else if( sgName == "Ccc2" ) return new clazz<FastSG_Ccc2>;\
  else if( sgName == "Ccca" ) return new clazz<FastSG_Ccca>;\
  else if( sgName == "Cccb" ) return new clazz<FastSG_Cccb>;\
  else if( sgName == "Cccm" ) return new clazz<FastSG_Cccm>;\
  else if( sgName == "Ccm21" ) return new clazz<FastSG_Ccm21>;\
  else if( sgName == "Ccmb" ) return new clazz<FastSG_Ccmb>;\
  else if( sgName == "Ccmm" ) return new clazz<FastSG_Ccmm>;\
  else if( sgName == "Cm" ) return new clazz<FastSG_Cm>;\
  else if( sgName == "Cm11" ) return new clazz<FastSG_Cm11>;\
  else if( sgName == "Cm2a" ) return new clazz<FastSG_Cm2a>;\
  else if( sgName == "Cm2m" ) return new clazz<FastSG_Cm2m>;\
  else if( sgName == "Cmc21" ) return new clazz<FastSG_Cmc21>;\
  else if( sgName == "Cmca" ) return new clazz<FastSG_Cmca>;\
  else if( sgName == "Cmcm" ) return new clazz<FastSG_Cmcm>;\
  else if( sgName == "Cmm2" ) return new clazz<FastSG_Cmm2>;\
  else if( sgName == "Cmma" ) return new clazz<FastSG_Cmma>;\
  else if( sgName == "Cmmb" ) return new clazz<FastSG_Cmmb>;\
  else if( sgName == "Cmmm" ) return new clazz<FastSG_Cmmm>;\
  else if( sgName == "Cn" ) return new clazz<FastSG_Cn>;\
  else if( sgName == "Cn11" ) return new clazz<FastSG_Cn11>;\
  else return NULL;  }

#define FSymmFactory_f(base, clazz) base* f_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "F-43c" ) return new clazz<FastSG_F_43c>;\
  else if( sgName == "F-43m" ) return new clazz<FastSG_F_43m>;\
  else if( sgName == "F222" ) return new clazz<FastSG_F222>;\
  else if( sgName == "F23" ) return new clazz<FastSG_F23>;\
  else if( sgName == "F2dd" ) return new clazz<FastSG_F2dd>;\
  else if( sgName == "F2mm" ) return new clazz<FastSG_F2mm>;\
  else if( sgName == "F4132" ) return new clazz<FastSG_F4132>;\
  else if( sgName == "F432" ) return new clazz<FastSG_F432>;\
  else if( sgName == "Fd-3" ) return new clazz<FastSG_Fd_3>;\
  else if( sgName == "Fd-3c" ) return new clazz<FastSG_Fd_3c>;\
  else if( sgName == "Fd-3m" ) return new clazz<FastSG_Fd_3m>;\
  else if( sgName == "Fd2d" ) return new clazz<FastSG_Fd2d>;\
  else if( sgName == "Fdd2" ) return new clazz<FastSG_Fdd2>;\
  else if( sgName == "Fddd" ) return new clazz<FastSG_Fddd>;\
  else if( sgName == "Fm-3" ) return new clazz<FastSG_Fm_3>;\
  else if( sgName == "Fm-3c" ) return new clazz<FastSG_Fm_3c>;\
  else if( sgName == "Fm-3m" ) return new clazz<FastSG_Fm_3m>;\
  else if( sgName == "Fm2m" ) return new clazz<FastSG_Fm2m>;\
  else if( sgName == "Fmm2" ) return new clazz<FastSG_Fmm2>;\
  else if( sgName == "Fmmm" ) return new clazz<FastSG_Fmmm>;\
  else return NULL;  }
#define FSymmFactory_i(base, clazz) base* i_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "I-4" ) return new clazz<FastSG_I_4>;\
  else if( sgName == "I-42d" ) return new clazz<FastSG_I_42d>;\
  else if( sgName == "I-42m" ) return new clazz<FastSG_I_42m>;\
  else if( sgName == "I-43d" ) return new clazz<FastSG_I_43d>;\
  else if( sgName == "I-43m" ) return new clazz<FastSG_I_43m>;\
  else if( sgName == "I-4c2" ) return new clazz<FastSG_I_4c2>;\
  else if( sgName == "I-4m2" ) return new clazz<FastSG_I_4m2>;\
  else if( sgName == "I112" ) return new clazz<FastSG_I112>;\
  else if( sgName == "I112/a" ) return new clazz<FastSG_I112_a>;\
  else if( sgName == "I112/b" ) return new clazz<FastSG_I112_b>;\
  else if( sgName == "I112/m" ) return new clazz<FastSG_I112_m>;\
  else if( sgName == "I11a" ) return new clazz<FastSG_I11a>;\
  else if( sgName == "I11b" ) return new clazz<FastSG_I11b>;\
  else if( sgName == "I11m" ) return new clazz<FastSG_I11m>;\
  else if( sgName == "I2" ) return new clazz<FastSG_I2>;\
  else if( sgName == "I2/a" ) return new clazz<FastSG_I2_a>;\
  else if( sgName == "I2/b11" ) return new clazz<FastSG_I2_b11>;\
  else if( sgName == "I2/c" ) return new clazz<FastSG_I2_c>;\
  else if( sgName == "I2/c11" ) return new clazz<FastSG_I2_c11>;\
  else if( sgName == "I2/m" ) return new clazz<FastSG_I2_m>;\
  else if( sgName == "I2/m11" ) return new clazz<FastSG_I2_m11>;\
  else if( sgName == "I211" ) return new clazz<FastSG_I211>;\
  else if( sgName == "I212121" ) return new clazz<FastSG_I212121>;\
  else if( sgName == "I213" ) return new clazz<FastSG_I213>;\
  else if( sgName == "I222" ) return new clazz<FastSG_I222>;\
  else if( sgName == "I23" ) return new clazz<FastSG_I23>;\
  else if( sgName == "I2cb" ) return new clazz<FastSG_I2cb>;\
  else if( sgName == "I2cm" ) return new clazz<FastSG_I2cm>;\
  else if( sgName == "I2mb" ) return new clazz<FastSG_I2mb>;\
  else if( sgName == "I2mm" ) return new clazz<FastSG_I2mm>;\
  else if( sgName == "I4" ) return new clazz<FastSG_I4>;\
  else if( sgName == "I4/m" ) return new clazz<FastSG_I4_m>;\
  else if( sgName == "I4/mcm" ) return new clazz<FastSG_I4_mcm>;\
  else if( sgName == "I4/mmm" ) return new clazz<FastSG_I4_mmm>;\
  else if( sgName == "I41" ) return new clazz<FastSG_I41>;\
  else if( sgName == "I41/a" ) return new clazz<FastSG_I41_a>;\
  else if( sgName == "I41/acd" ) return new clazz<FastSG_I41_acd>;\
  else if( sgName == "I41/amd" ) return new clazz<FastSG_I41_amd>;\
  else if( sgName == "I4122" ) return new clazz<FastSG_I4122>;\
  else if( sgName == "I4132" ) return new clazz<FastSG_I4132>;\
  else if( sgName == "I41cd" ) return new clazz<FastSG_I41cd>;\
  else if( sgName == "I41md" ) return new clazz<FastSG_I41md>;\
  else if( sgName == "I422" ) return new clazz<FastSG_I422>;\
  else if( sgName == "I432" ) return new clazz<FastSG_I432>;\
  else if( sgName == "I4cm" ) return new clazz<FastSG_I4cm>;\
  else if( sgName == "I4mm" ) return new clazz<FastSG_I4mm>;\
  else if( sgName == "Ia" ) return new clazz<FastSG_Ia>;\
  else if( sgName == "Ia-3" ) return new clazz<FastSG_Ia_3>;\
  else if( sgName == "Ia-3d" ) return new clazz<FastSG_Ia_3d>;\
  else if( sgName == "Ib11" ) return new clazz<FastSG_Ib11>;\
  else if( sgName == "Iba2" ) return new clazz<FastSG_Iba2>;\
  else if( sgName == "Ibam" ) return new clazz<FastSG_Ibam>;\
  else if( sgName == "Ibca" ) return new clazz<FastSG_Ibca>;\
  else if( sgName == "Ibm2" ) return new clazz<FastSG_Ibm2>;\
  else if( sgName == "Ibmm" ) return new clazz<FastSG_Ibmm>;\
  else if( sgName == "Ic" ) return new clazz<FastSG_Ic>;\
  else if( sgName == "Ic11" ) return new clazz<FastSG_Ic11>;\
  else if( sgName == "Ic2a" ) return new clazz<FastSG_Ic2a>;\
  else if( sgName == "Ic2m" ) return new clazz<FastSG_Ic2m>;\
  else if( sgName == "Icab" ) return new clazz<FastSG_Icab>;\
  else if( sgName == "Icma" ) return new clazz<FastSG_Icma>;\
  else if( sgName == "Icmm" ) return new clazz<FastSG_Icmm>;\
  else if( sgName == "Im" ) return new clazz<FastSG_Im>;\
  else if( sgName == "Im-3" ) return new clazz<FastSG_Im_3>;\
  else if( sgName == "Im-3m" ) return new clazz<FastSG_Im_3m>;\
  else if( sgName == "Im11" ) return new clazz<FastSG_Im11>;\
  else if( sgName == "Im2a" ) return new clazz<FastSG_Im2a>;\
  else if( sgName == "Im2m" ) return new clazz<FastSG_Im2m>;\
  else if( sgName == "Ima2" ) return new clazz<FastSG_Ima2>;\
  else if( sgName == "Imam" ) return new clazz<FastSG_Imam>;\
  else if( sgName == "Imcb" ) return new clazz<FastSG_Imcb>;\
  else if( sgName == "Imcm" ) return new clazz<FastSG_Imcm>;\
  else if( sgName == "Imm2" ) return new clazz<FastSG_Imm2>;\
  else if( sgName == "Imma" ) return new clazz<FastSG_Imma>;\
  else if( sgName == "Immb" ) return new clazz<FastSG_Immb>;\
  else if( sgName == "Immm" ) return new clazz<FastSG_Immm>;\
  else return NULL;  }

#define FSymmFactory_p1(base, clazz) base* p1_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "P-1" ) return new clazz<FastSG_P_1>;\
  else if( sgName == "P-3" ) return new clazz<FastSG_P_3>;\
  else if( sgName == "P-31c" ) return new clazz<FastSG_P_31c>;\
  else if( sgName == "P-31m" ) return new clazz<FastSG_P_31m>;\
  else if( sgName == "P-3c1" ) return new clazz<FastSG_P_3c1>;\
  else if( sgName == "P-3m1" ) return new clazz<FastSG_P_3m1>;\
  else if( sgName == "P-4" ) return new clazz<FastSG_P_4>;\
  else if( sgName == "P-421c" ) return new clazz<FastSG_P_421c>;\
  else if( sgName == "P-421m" ) return new clazz<FastSG_P_421m>;\
  else if( sgName == "P-42c" ) return new clazz<FastSG_P_42c>;\
  else if( sgName == "P-42m" ) return new clazz<FastSG_P_42m>;\
  else if( sgName == "P-43m" ) return new clazz<FastSG_P_43m>;\
  else if( sgName == "P-43n" ) return new clazz<FastSG_P_43n>;\
  else if( sgName == "P-4b2" ) return new clazz<FastSG_P_4b2>;\
  else if( sgName == "P-4c2" ) return new clazz<FastSG_P_4c2>;\
  else if( sgName == "P-4m2" ) return new clazz<FastSG_P_4m2>;\
  else if( sgName == "P-4n2" ) return new clazz<FastSG_P_4n2>;\
  else if( sgName == "P-6" ) return new clazz<FastSG_P_6>;\
  else if( sgName == "P-62c" ) return new clazz<FastSG_P_62c>;\
  else if( sgName == "P-62m" ) return new clazz<FastSG_P_62m>;\
  else if( sgName == "P-6c2" ) return new clazz<FastSG_P_6c2>;\
  else if( sgName == "P-6m2" ) return new clazz<FastSG_P_6m2>;\
  else if( sgName == "P1" ) return new clazz<FastSG_P1>;\
  else if( sgName == "P112" ) return new clazz<FastSG_P112>;\
  else if( sgName == "P112/a" ) return new clazz<FastSG_P112_a>;\
  else if( sgName == "P112/b" ) return new clazz<FastSG_P112_b>;\
  else if( sgName == "P112/m" ) return new clazz<FastSG_P112_m>;\
  else if( sgName == "P112/n" ) return new clazz<FastSG_P112_n>;\
  else if( sgName == "P1121" ) return new clazz<FastSG_P1121>;\
  else if( sgName == "P1121/a" ) return new clazz<FastSG_P1121_a>;\
  else if( sgName == "P1121/b" ) return new clazz<FastSG_P1121_b>;\
  else if( sgName == "P1121/m" ) return new clazz<FastSG_P1121_m>;\
  else if( sgName == "P1121/n" ) return new clazz<FastSG_P1121_n>;\
  else if( sgName == "P11a" ) return new clazz<FastSG_P11a>;\
  else if( sgName == "P11b" ) return new clazz<FastSG_P11b>;\
  else if( sgName == "P11m" ) return new clazz<FastSG_P11m>;\
  else if( sgName == "P11n" ) return new clazz<FastSG_P11n>;\
  else if( sgName == "P2" ) return new clazz<FastSG_P2>;\
  else if( sgName == "P2/a" ) return new clazz<FastSG_P2_a>;\
  else if( sgName == "P2/b11" ) return new clazz<FastSG_P2_b11>;\
  else if( sgName == "P2/c" ) return new clazz<FastSG_P2_c>;\
  else if( sgName == "P2/c11" ) return new clazz<FastSG_P2_c11>;\
  else if( sgName == "P2/m" ) return new clazz<FastSG_P2_m>;\
  else if( sgName == "P2/m11" ) return new clazz<FastSG_P2_m11>;\
  else if( sgName == "P2/n" ) return new clazz<FastSG_P2_n>;\
  else if( sgName == "P2/n11" ) return new clazz<FastSG_P2_n11>;\
  else if( sgName == "P21" ) return new clazz<FastSG_P21>;\
  else if( sgName == "P21/a" ) return new clazz<FastSG_P21_a>;\
  else if( sgName == "P21/b11" ) return new clazz<FastSG_P21_b11>;\
  else if( sgName == "P21/c" ) return new clazz<FastSG_P21_c>;\
  else if( sgName == "P21/c11" ) return new clazz<FastSG_P21_c11>;\
  else if( sgName == "P21/m" ) return new clazz<FastSG_P21_m>;\
  else if( sgName == "P21/m11" ) return new clazz<FastSG_P21_m11>;\
  else return NULL;  }

#define FSymmFactory_p2(base, clazz) base* p2_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "P21/n" ) return new clazz<FastSG_P21_n>;\
  else if( sgName == "P21/n11" ) return new clazz<FastSG_P21_n11>;\
  else if( sgName == "P211" ) return new clazz<FastSG_P211>;\
  else if( sgName == "P2111" ) return new clazz<FastSG_P2111>;\
  else if( sgName == "P21212" ) return new clazz<FastSG_P21212>;\
  else if( sgName == "P212121" ) return new clazz<FastSG_P212121>;\
  else if( sgName == "P2122" ) return new clazz<FastSG_P2122>;\
  else if( sgName == "P21221" ) return new clazz<FastSG_P21221>;\
  else if( sgName == "P213" ) return new clazz<FastSG_P213>;\
  else if( sgName == "P21ab" ) return new clazz<FastSG_P21ab>;\
  else if( sgName == "P21am" ) return new clazz<FastSG_P21am>;\
  else if( sgName == "P21ca" ) return new clazz<FastSG_P21ca>;\
  else if( sgName == "P21cn" ) return new clazz<FastSG_P21cn>;\
  else if( sgName == "P21ma" ) return new clazz<FastSG_P21ma>;\
  else if( sgName == "P21mn" ) return new clazz<FastSG_P21mn>;\
  else if( sgName == "P21nb" ) return new clazz<FastSG_P21nb>;\
  else if( sgName == "P21nm" ) return new clazz<FastSG_P21nm>;\
  else if( sgName == "P2212" ) return new clazz<FastSG_P2212>;\
  else if( sgName == "P22121" ) return new clazz<FastSG_P22121>;\
  else if( sgName == "P222" ) return new clazz<FastSG_P222>;\
  else if( sgName == "P2221" ) return new clazz<FastSG_P2221>;\
  else if( sgName == "P23" ) return new clazz<FastSG_P23>;\
  else if( sgName == "P2aa" ) return new clazz<FastSG_P2aa>;\
  else if( sgName == "P2an" ) return new clazz<FastSG_P2an>;\
  else if( sgName == "P2cb" ) return new clazz<FastSG_P2cb>;\
  else if( sgName == "P2cm" ) return new clazz<FastSG_P2cm>;\
  else if( sgName == "P2mb" ) return new clazz<FastSG_P2mb>;\
  else if( sgName == "P2mm" ) return new clazz<FastSG_P2mm>;\
  else if( sgName == "P2na" ) return new clazz<FastSG_P2na>;\
  else if( sgName == "P2nn" ) return new clazz<FastSG_P2nn>;\
  else if( sgName == "P3" ) return new clazz<FastSG_P3>;\
  else if( sgName == "P31" ) return new clazz<FastSG_P31>;\
  else if( sgName == "P3112" ) return new clazz<FastSG_P3112>;\
  else if( sgName == "P312" ) return new clazz<FastSG_P312>;\
  else if( sgName == "P3121" ) return new clazz<FastSG_P3121>;\
  else if( sgName == "P31c" ) return new clazz<FastSG_P31c>;\
  else if( sgName == "P31m" ) return new clazz<FastSG_P31m>;\
  else if( sgName == "P32" ) return new clazz<FastSG_P32>;\
  else if( sgName == "P321" ) return new clazz<FastSG_P321>;\
  else if( sgName == "P3212" ) return new clazz<FastSG_P3212>;\
  else if( sgName == "P3221" ) return new clazz<FastSG_P3221>;\
  else if( sgName == "P3c1" ) return new clazz<FastSG_P3c1>;\
  else if( sgName == "P3m1" ) return new clazz<FastSG_P3m1>;\
  else if( sgName == "P4" ) return new clazz<FastSG_P4>;\
  else if( sgName == "P4/m" ) return new clazz<FastSG_P4_m>;\
  else if( sgName == "P4/mbm" ) return new clazz<FastSG_P4_mbm>;\
  else if( sgName == "P4/mcc" ) return new clazz<FastSG_P4_mcc>;\
  else if( sgName == "P4/mmm" ) return new clazz<FastSG_P4_mmm>;\
  else if( sgName == "P4/mnc" ) return new clazz<FastSG_P4_mnc>;\
  else if( sgName == "P4/n" ) return new clazz<FastSG_P4_n>;\
  else if( sgName == "P4/nbm" ) return new clazz<FastSG_P4_nbm>;\
  else if( sgName == "P4/ncc" ) return new clazz<FastSG_P4_ncc>;\
  else if( sgName == "P4/nmm" ) return new clazz<FastSG_P4_nmm>;\
  else if( sgName == "P4/nnc" ) return new clazz<FastSG_P4_nnc>;\
  else if( sgName == "P41" ) return new clazz<FastSG_P41>;\
  else if( sgName == "P41212" ) return new clazz<FastSG_P41212>;\
  else if( sgName == "P4122" ) return new clazz<FastSG_P4122>;\
  else if( sgName == "P4132" ) return new clazz<FastSG_P4132>;\
  else if( sgName == "P42" ) return new clazz<FastSG_P42>;\
  else if( sgName == "P42/m" ) return new clazz<FastSG_P42_m>;\
  else if( sgName == "P42/mbc" ) return new clazz<FastSG_P42_mbc>;\
  else if( sgName == "P42/mcm" ) return new clazz<FastSG_P42_mcm>;\
  else if( sgName == "P42/mmc" ) return new clazz<FastSG_P42_mmc>;\
  else if( sgName == "P42/mnm" ) return new clazz<FastSG_P42_mnm>;\
  else if( sgName == "P42/n" ) return new clazz<FastSG_P42_n>;\
  else if( sgName == "P42/nbc" ) return new clazz<FastSG_P42_nbc>;\
  else if( sgName == "P42/ncm" ) return new clazz<FastSG_P42_ncm>;\
  else if( sgName == "P42/nmc" ) return new clazz<FastSG_P42_nmc>;\
  else if( sgName == "P42/nnm" ) return new clazz<FastSG_P42_nnm>;\
  else if( sgName == "P4212" ) return new clazz<FastSG_P4212>;\
  else if( sgName == "P422" ) return new clazz<FastSG_P422>;\
  else if( sgName == "P42212" ) return new clazz<FastSG_P42212>;\
  else if( sgName == "P4222" ) return new clazz<FastSG_P4222>;\
  else if( sgName == "P4232" ) return new clazz<FastSG_P4232>;\
  else if( sgName == "P42bc" ) return new clazz<FastSG_P42bc>;\
  else if( sgName == "P42cm" ) return new clazz<FastSG_P42cm>;\
  else if( sgName == "P42mc" ) return new clazz<FastSG_P42mc>;\
  else if( sgName == "P42nm" ) return new clazz<FastSG_P42nm>;\
  else if( sgName == "P43" ) return new clazz<FastSG_P43>;\
  else if( sgName == "P432" ) return new clazz<FastSG_P432>;\
  else if( sgName == "P43212" ) return new clazz<FastSG_P43212>;\
  else if( sgName == "P4322" ) return new clazz<FastSG_P4322>;\
  else if( sgName == "P4332" ) return new clazz<FastSG_P4332>;\
  else if( sgName == "P4bm" ) return new clazz<FastSG_P4bm>;\
  else if( sgName == "P4cc" ) return new clazz<FastSG_P4cc>;\
  else if( sgName == "P4mm" ) return new clazz<FastSG_P4mm>;\
  else if( sgName == "P4nc" ) return new clazz<FastSG_P4nc>;\
  else if( sgName == "P6" ) return new clazz<FastSG_P6>;\
  else if( sgName == "P6/m" ) return new clazz<FastSG_P6_m>;\
  else if( sgName == "P6/mcc" ) return new clazz<FastSG_P6_mcc>;\
  else if( sgName == "P6/mmm" ) return new clazz<FastSG_P6_mmm>;\
  else if( sgName == "P61" ) return new clazz<FastSG_P61>;\
  else if( sgName == "P6122" ) return new clazz<FastSG_P6122>;\
  else if( sgName == "P62" ) return new clazz<FastSG_P62>;\
  else if( sgName == "P622" ) return new clazz<FastSG_P622>;\
  else if( sgName == "P6222" ) return new clazz<FastSG_P6222>;\
  else return NULL;  }

#define FSymmFactory_p3(base, clazz) base* p3_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "P63" ) return new clazz<FastSG_P63>;\
  else if( sgName == "P63/m" ) return new clazz<FastSG_P63_m>;\
  else if( sgName == "P63/mcm" ) return new clazz<FastSG_P63_mcm>;\
  else if( sgName == "P63/mmc" ) return new clazz<FastSG_P63_mmc>;\
  else if( sgName == "P6322" ) return new clazz<FastSG_P6322>;\
  else if( sgName == "P63cm" ) return new clazz<FastSG_P63cm>;\
  else if( sgName == "P63mc" ) return new clazz<FastSG_P63mc>;\
  else if( sgName == "P64" ) return new clazz<FastSG_P64>;\
  else if( sgName == "P6422" ) return new clazz<FastSG_P6422>;\
  else if( sgName == "P65" ) return new clazz<FastSG_P65>;\
  else if( sgName == "P6522" ) return new clazz<FastSG_P6522>;\
  else if( sgName == "P6cc" ) return new clazz<FastSG_P6cc>;\
  else if( sgName == "P6mm" ) return new clazz<FastSG_P6mm>;\
  else if( sgName == "Pa" ) return new clazz<FastSG_Pa>;\
  else if( sgName == "Pa-3" ) return new clazz<FastSG_Pa_3>;\
  else if( sgName == "Pb11" ) return new clazz<FastSG_Pb11>;\
  else if( sgName == "Pb21a" ) return new clazz<FastSG_Pb21a>;\
  else if( sgName == "Pb21m" ) return new clazz<FastSG_Pb21m>;\
  else if( sgName == "Pb2b" ) return new clazz<FastSG_Pb2b>;\
  else if( sgName == "Pb2n" ) return new clazz<FastSG_Pb2n>;\
  else if( sgName == "Pba2" ) return new clazz<FastSG_Pba2>;\
  else if( sgName == "Pbaa" ) return new clazz<FastSG_Pbaa>;\
  else if( sgName == "Pbab" ) return new clazz<FastSG_Pbab>;\
  else if( sgName == "Pbam" ) return new clazz<FastSG_Pbam>;\
  else if( sgName == "Pban" ) return new clazz<FastSG_Pban>;\
  else if( sgName == "Pbc21" ) return new clazz<FastSG_Pbc21>;\
  else if( sgName == "Pbca" ) return new clazz<FastSG_Pbca>;\
  else if( sgName == "Pbcb" ) return new clazz<FastSG_Pbcb>;\
  else if( sgName == "Pbcm" ) return new clazz<FastSG_Pbcm>;\
  else if( sgName == "Pbcn" ) return new clazz<FastSG_Pbcn>;\
  else if( sgName == "Pbm2" ) return new clazz<FastSG_Pbm2>;\
  else if( sgName == "Pbma" ) return new clazz<FastSG_Pbma>;\
  else if( sgName == "Pbmb" ) return new clazz<FastSG_Pbmb>;\
  else if( sgName == "Pbmm" ) return new clazz<FastSG_Pbmm>;\
  else if( sgName == "Pbmn" ) return new clazz<FastSG_Pbmn>;\
  else if( sgName == "Pbn21" ) return new clazz<FastSG_Pbn21>;\
  else if( sgName == "Pbna" ) return new clazz<FastSG_Pbna>;\
  else if( sgName == "Pbnb" ) return new clazz<FastSG_Pbnb>;\
  else if( sgName == "Pbnm" ) return new clazz<FastSG_Pbnm>;\
  else if( sgName == "Pbnn" ) return new clazz<FastSG_Pbnn>;\
  else if( sgName == "Pc" ) return new clazz<FastSG_Pc>;\
  else if( sgName == "Pc11" ) return new clazz<FastSG_Pc11>;\
  else if( sgName == "Pc21b" ) return new clazz<FastSG_Pc21b>;\
  else if( sgName == "Pc21n" ) return new clazz<FastSG_Pc21n>;\
  else if( sgName == "Pc2a" ) return new clazz<FastSG_Pc2a>;\
  else if( sgName == "Pc2m" ) return new clazz<FastSG_Pc2m>;\
  else if( sgName == "Pca21" ) return new clazz<FastSG_Pca21>;\
  else if( sgName == "Pcaa" ) return new clazz<FastSG_Pcaa>;\
  else if( sgName == "Pcab" ) return new clazz<FastSG_Pcab>;\
  else if( sgName == "Pcam" ) return new clazz<FastSG_Pcam>;\
  else if( sgName == "Pcan" ) return new clazz<FastSG_Pcan>;\
  else return NULL;  }

#define FSymmFactory_p4(base, clazz) base* p4_fs_factory_##base(const olxstr& sgName) {\
  if( sgName == "Pcc2" ) return new clazz<FastSG_Pcc2>;\
  else if( sgName == "Pcca" ) return new clazz<FastSG_Pcca>;\
  else if( sgName == "Pccb" ) return new clazz<FastSG_Pccb>;\
  else if( sgName == "Pccm" ) return new clazz<FastSG_Pccm>;\
  else if( sgName == "Pccn" ) return new clazz<FastSG_Pccn>;\
  else if( sgName == "Pcm21" ) return new clazz<FastSG_Pcm21>;\
  else if( sgName == "Pcma" ) return new clazz<FastSG_Pcma>;\
  else if( sgName == "Pcmb" ) return new clazz<FastSG_Pcmb>;\
  else if( sgName == "Pcmm" ) return new clazz<FastSG_Pcmm>;\
  else if( sgName == "Pcmn" ) return new clazz<FastSG_Pcmn>;\
  else if( sgName == "Pcn2" ) return new clazz<FastSG_Pcn2>;\
  else if( sgName == "Pcna" ) return new clazz<FastSG_Pcna>;\
  else if( sgName == "Pcnb" ) return new clazz<FastSG_Pcnb>;\
  else if( sgName == "Pcnm" ) return new clazz<FastSG_Pcnm>;\
  else if( sgName == "Pcnn" ) return new clazz<FastSG_Pcnn>;\
  else if( sgName == "Pm" ) return new clazz<FastSG_Pm>;\
  else if( sgName == "Pm-3" ) return new clazz<FastSG_Pm_3>;\
  else if( sgName == "Pm-3m" ) return new clazz<FastSG_Pm_3m>;\
  else if( sgName == "Pm-3n" ) return new clazz<FastSG_Pm_3n>;\
  else if( sgName == "Pm11" ) return new clazz<FastSG_Pm11>;\
  else if( sgName == "Pm21b" ) return new clazz<FastSG_Pm21b>;\
  else if( sgName == "Pm21n" ) return new clazz<FastSG_Pm21n>;\
  else if( sgName == "Pm2a" ) return new clazz<FastSG_Pm2a>;\
  else if( sgName == "Pm2m" ) return new clazz<FastSG_Pm2m>;\
  else if( sgName == "Pma2" ) return new clazz<FastSG_Pma2>;\
  else if( sgName == "Pmaa" ) return new clazz<FastSG_Pmaa>;\
  else if( sgName == "Pmab" ) return new clazz<FastSG_Pmab>;\
  else if( sgName == "Pmam" ) return new clazz<FastSG_Pmam>;\
  else if( sgName == "Pman" ) return new clazz<FastSG_Pman>;\
  else if( sgName == "Pmc21" ) return new clazz<FastSG_Pmc21>;\
  else if( sgName == "Pmca" ) return new clazz<FastSG_Pmca>;\
  else if( sgName == "Pmcb" ) return new clazz<FastSG_Pmcb>;\
  else if( sgName == "Pmcm" ) return new clazz<FastSG_Pmcm>;\
  else if( sgName == "Pmcn" ) return new clazz<FastSG_Pmcn>;\
  else if( sgName == "Pmm2" ) return new clazz<FastSG_Pmm2>;\
  else if( sgName == "Pmma" ) return new clazz<FastSG_Pmma>;\
  else if( sgName == "Pmmb" ) return new clazz<FastSG_Pmmb>;\
  else if( sgName == "Pmmm" ) return new clazz<FastSG_Pmmm>;\
  else if( sgName == "Pmmn" ) return new clazz<FastSG_Pmmn>;\
  else if( sgName == "Pmn21" ) return new clazz<FastSG_Pmn21>;\
  else if( sgName == "Pmna" ) return new clazz<FastSG_Pmna>;\
  else if( sgName == "Pmnb" ) return new clazz<FastSG_Pmnb>;\
  else if( sgName == "Pmnm" ) return new clazz<FastSG_Pmnm>;\
  else if( sgName == "Pmnn" ) return new clazz<FastSG_Pmnn>;\
  else if( sgName == "Pn" ) return new clazz<FastSG_Pn>;\
  else if( sgName == "Pn-3" ) return new clazz<FastSG_Pn_3>;\
  else if( sgName == "Pn-3m" ) return new clazz<FastSG_Pn_3m>;\
  else if( sgName == "Pn-3n" ) return new clazz<FastSG_Pn_3n>;\
  else if( sgName == "Pn11" ) return new clazz<FastSG_Pn11>;\
  else if( sgName == "Pn21a" ) return new clazz<FastSG_Pn21a>;\
  else if( sgName == "Pn21m" ) return new clazz<FastSG_Pn21m>;\
  else if( sgName == "Pn2b" ) return new clazz<FastSG_Pn2b>;\
  else if( sgName == "Pn2n" ) return new clazz<FastSG_Pn2n>;\
  else if( sgName == "Pna21" ) return new clazz<FastSG_Pna21>;\
  else if( sgName == "Pnaa" ) return new clazz<FastSG_Pnaa>;\
  else if( sgName == "Pnab" ) return new clazz<FastSG_Pnab>;\
  else if( sgName == "Pnam" ) return new clazz<FastSG_Pnam>;\
  else if( sgName == "Pnan" ) return new clazz<FastSG_Pnan>;\
  else if( sgName == "Pnc2" ) return new clazz<FastSG_Pnc2>;\
  else if( sgName == "Pnca" ) return new clazz<FastSG_Pnca>;\
  else if( sgName == "Pncb" ) return new clazz<FastSG_Pncb>;\
  else if( sgName == "Pncm" ) return new clazz<FastSG_Pncm>;\
  else if( sgName == "Pncn" ) return new clazz<FastSG_Pncn>;\
  else if( sgName == "Pnm21" ) return new clazz<FastSG_Pnm21>;\
  else if( sgName == "Pnma" ) return new clazz<FastSG_Pnma>;\
  else if( sgName == "Pnmb" ) return new clazz<FastSG_Pnmb>;\
  else if( sgName == "Pnmm" ) return new clazz<FastSG_Pnmm>;\
  else if( sgName == "Pnmn" ) return new clazz<FastSG_Pnmn>;\
  else if( sgName == "Pnn2" ) return new clazz<FastSG_Pnn2>;\
  else if( sgName == "Pnna" ) return new clazz<FastSG_Pnna>;\
  else if( sgName == "Pnnb" ) return new clazz<FastSG_Pnnb>;\
  else if( sgName == "Pnnm" ) return new clazz<FastSG_Pnnm>;\
  else if( sgName == "Pnnn" ) return new clazz<FastSG_Pnnn>;\
  else if( sgName == "R-3" ) return new clazz<FastSG_R_3>;\
  else if( sgName == "R-3:r" ) return new clazz<FastSG_R_3_r>;\
  else if( sgName == "R-3c" ) return new clazz<FastSG_R_3c>;\
  else if( sgName == "R-3c:r" ) return new clazz<FastSG_R_3c_r>;\
  else if( sgName == "R-3m" ) return new clazz<FastSG_R_3m>;\
  else if( sgName == "R-3m:r" ) return new clazz<FastSG_R_3m_r>;\
  else if( sgName == "R3" ) return new clazz<FastSG_R3>;\
  else if( sgName == "R32" ) return new clazz<FastSG_R32>;\
  else if( sgName == "R32:r" ) return new clazz<FastSG_R32_r>;\
  else if( sgName == "R3:r" ) return new clazz<FastSG_R3_r>;\
  else if( sgName == "R3c" ) return new clazz<FastSG_R3c>;\
  else if( sgName == "R3c:r" ) return new clazz<FastSG_R3c_r>;\
  else if( sgName == "R3m" ) return new clazz<FastSG_R3m>;\
  else if( sgName == "R3m:r" ) return new clazz<FastSG_R3m_r>;\
  else return NULL;  }

#define FSymmFactory(base, clazz) base* fs_factory_##base(const olxstr& sgName) {\
  if( sgName.IsEmpty() )  return NULL;\
  if( sgName.CharAt(0) == 'A' )  return a_fs_factory_##base(sgName);\
  if( sgName.CharAt(0) == 'B' )  return b_fs_factory_##base(sgName);\
  if( sgName.CharAt(0) == 'C' )  return c_fs_factory_##base(sgName);\
  if( sgName.CharAt(0) == 'F' )  return f_fs_factory_##base(sgName);\
  if( sgName.CharAt(0) == 'I' )  return i_fs_factory_##base(sgName);\
  base* rv = p1_fs_factory_##base(sgName);\
  if( rv != NULL )  return rv;\
  rv = p2_fs_factory_##base(sgName);\
  if( rv != NULL )  return rv;\
  rv = p3_fs_factory_##base(sgName);\
  if( rv != NULL )  return rv;\
  rv = p4_fs_factory_##base(sgName);\
  return rv; }

#define DefineFSFactory(base, clazz) \
  FSymmFactory_a(base,clazz)\
  FSymmFactory_b(base,clazz)\
  FSymmFactory_c(base,clazz)\
  FSymmFactory_f(base,clazz)\
  FSymmFactory_i(base,clazz)\
  FSymmFactory_p1(base,clazz)\
  FSymmFactory_p2(base,clazz)\
  FSymmFactory_p3(base,clazz)\
  FSymmFactory_p4(base,clazz)\
  FSymmFactory(base,clazz)\

struct FastSG_A112 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A112_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A112_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A112_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A11a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A11m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A11n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2122 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A21am {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A21ma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2aa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_A2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Aa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Aba2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Abaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Abm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Abma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Abmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ac2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ac2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Acaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Acam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Acmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[1]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[1]*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Am {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Am2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Am2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ama2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Amaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Amam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Amm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Amma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ammm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_An {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='A';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B112 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B112_b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B112_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B112_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B11b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B11m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B11n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2_b11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2_m11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2_n11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B211 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2cb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2mb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_B2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bb11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bb21m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bb2b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bba2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbcb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[1]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bbmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[1]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bm11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bm21b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bm2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bma2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[1]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[0]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[1]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bmmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Bn11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='B';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
  }
  static const short size=2;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_c11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_m11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2_n11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C211 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2221 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2cb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2mb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_C2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cc11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cc2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cc2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ccc2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ccca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cccb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[1]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cccm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ccm21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ccmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ccmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cm11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cm2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cm2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmc21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = (v[1]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[1]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[0]*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cmmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Cn11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='C';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F_43c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[1];
    res[5][1] = -v[0]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1];
    res[13][1] = v[0]+1./2;
    res[13][2] = -v[2];
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0];
    res[14][2] = -v[2];
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2]+1./2;
    res[16][0] = -v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1]+1./2;
    res[17][0] = -v[0];
    res[17][1] = v[2]+1./2;
    res[17][2] = -v[1];
    res[18][0] = -v[0]+1./2;
    res[18][1] = v[2];
    res[18][2] = -v[1];
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[2]+1./2;
    res[19][2] = -v[1]+1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = -v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1]+1./2;
    res[25][0] = -v[0];
    res[25][1] = -v[2]+1./2;
    res[25][2] = v[1];
    res[26][0] = -v[0]+1./2;
    res[26][1] = -v[2];
    res[26][2] = v[1];
    res[27][0] = -v[0]+1./2;
    res[27][1] = -v[2]+1./2;
    res[27][2] = v[1]+1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[1];
    res[28][2] = v[0]+1./2;
    res[29][0] = -v[2];
    res[29][1] = -v[1]+1./2;
    res[29][2] = v[0];
    res[30][0] = -v[2]+1./2;
    res[30][1] = -v[1];
    res[30][2] = v[0];
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[1]+1./2;
    res[31][2] = v[0]+1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1]+1./2;
    res[33][2] = -v[2]+1./2;
    res[34][0] = -v[0]+1./2;
    res[34][1] = v[1];
    res[34][2] = -v[2]+1./2;
    res[35][0] = -v[0]+1./2;
    res[35][1] = v[1]+1./2;
    res[35][2] = -v[2];
    res[36][0] = v[2];
    res[36][1] = -v[1];
    res[36][2] = -v[0]+1./2;
    res[37][0] = v[2];
    res[37][1] = -v[1]+1./2;
    res[37][2] = -v[0];
    res[38][0] = v[2]+1./2;
    res[38][1] = -v[1];
    res[38][2] = -v[0];
    res[39][0] = v[2]+1./2;
    res[39][1] = -v[1]+1./2;
    res[39][2] = -v[0]+1./2;
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0]+1./2;
    res[41][2] = v[1]+1./2;
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0];
    res[42][2] = v[1]+1./2;
    res[43][0] = v[2]+1./2;
    res[43][1] = v[0]+1./2;
    res[43][2] = v[1];
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = v[1];
    res[45][1] = v[2]+1./2;
    res[45][2] = v[0]+1./2;
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2];
    res[46][2] = v[0]+1./2;
    res[47][0] = v[1]+1./2;
    res[47][1] = v[2]+1./2;
    res[47][2] = v[0];
    res[48][0] = -v[1];
    res[48][1] = -v[2];
    res[48][2] = v[0];
    res[49][0] = -v[1];
    res[49][1] = -v[2]+1./2;
    res[49][2] = v[0]+1./2;
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2];
    res[50][2] = v[0]+1./2;
    res[51][0] = -v[1]+1./2;
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[0];
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1];
    res[53][0] = v[2];
    res[53][1] = -v[0]+1./2;
    res[53][2] = -v[1]+1./2;
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0];
    res[54][2] = -v[1]+1./2;
    res[55][0] = v[2]+1./2;
    res[55][1] = -v[0]+1./2;
    res[55][2] = -v[1];
    res[56][0] = -v[1];
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2]+1./2;
    res[57][2] = -v[0]+1./2;
    res[58][0] = -v[1]+1./2;
    res[58][1] = v[2];
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[1]+1./2;
    res[59][1] = v[2]+1./2;
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = -v[0];
    res[60][2] = v[1];
    res[61][0] = -v[2];
    res[61][1] = -v[0]+1./2;
    res[61][2] = v[1]+1./2;
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0];
    res[62][2] = v[1]+1./2;
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = -v[2];
    res[65][1] = v[0]+1./2;
    res[65][2] = -v[1]+1./2;
    res[66][0] = -v[2]+1./2;
    res[66][1] = v[0];
    res[66][2] = -v[1]+1./2;
    res[67][0] = -v[2]+1./2;
    res[67][1] = v[0]+1./2;
    res[67][2] = -v[1];
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0];
    res[69][0] = v[1];
    res[69][1] = -v[2]+1./2;
    res[69][2] = -v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2];
    res[70][2] = -v[0]+1./2;
    res[71][0] = v[1]+1./2;
    res[71][1] = -v[2]+1./2;
    res[71][2] = -v[0];
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2]+1./2;
    res[73][0] = -v[1];
    res[73][1] = -v[0]+1./2;
    res[73][2] = v[2];
    res[74][0] = -v[1]+1./2;
    res[74][1] = -v[0];
    res[74][2] = v[2];
    res[75][0] = -v[1]+1./2;
    res[75][1] = -v[0]+1./2;
    res[75][2] = v[2]+1./2;
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2]+1./2;
    res[77][0] = v[1];
    res[77][1] = v[0]+1./2;
    res[77][2] = v[2];
    res[78][0] = v[1]+1./2;
    res[78][1] = v[0];
    res[78][2] = v[2];
    res[79][0] = v[1]+1./2;
    res[79][1] = v[0]+1./2;
    res[79][2] = v[2]+1./2;
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1]+1./2;
    res[81][0] = v[0];
    res[81][1] = -v[2]+1./2;
    res[81][2] = -v[1];
    res[82][0] = v[0]+1./2;
    res[82][1] = -v[2];
    res[82][2] = -v[1];
    res[83][0] = v[0]+1./2;
    res[83][1] = -v[2]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1]+1./2;
    res[85][0] = v[0];
    res[85][1] = v[2]+1./2;
    res[85][2] = v[1];
    res[86][0] = v[0]+1./2;
    res[86][1] = v[2];
    res[86][2] = v[1];
    res[87][0] = v[0]+1./2;
    res[87][1] = v[2]+1./2;
    res[87][2] = v[1]+1./2;
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0]+1./2;
    res[89][0] = -v[2];
    res[89][1] = v[1]+1./2;
    res[89][2] = -v[0];
    res[90][0] = -v[2]+1./2;
    res[90][1] = v[1];
    res[90][2] = -v[0];
    res[91][0] = -v[2]+1./2;
    res[91][1] = v[1]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0]+1./2;
    res[93][0] = v[2];
    res[93][1] = v[1]+1./2;
    res[93][2] = v[0];
    res[94][0] = v[2]+1./2;
    res[94][1] = v[1];
    res[94][2] = v[0];
    res[95][0] = v[2]+1./2;
    res[95][1] = v[1]+1./2;
    res[95][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[2];
    res[18][2] = v[1];
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    res[26][0] = -v[0];
    res[26][1] = v[2];
    res[26][2] = -v[1];
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    res[28][0] = v[2];
    res[28][1] = -v[1];
    res[28][2] = -v[0];
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    res[30][0] = v[2];
    res[30][1] = -v[1];
    res[30][2] = -v[0];
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    res[36][0] = -v[2];
    res[36][1] = -v[1];
    res[36][2] = v[0];
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    res[38][0] = -v[2];
    res[38][1] = -v[1];
    res[38][2] = v[0];
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    res[74][0] = -v[1];
    res[74][1] = -v[0];
    res[74][2] = v[2];
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2];
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    res[78][0] = v[1];
    res[78][1] = v[0];
    res[78][2] = v[2];
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    res[82][0] = v[0];
    res[82][1] = -v[2];
    res[82][2] = -v[1];
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1];
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    res[86][0] = v[0];
    res[86][1] = v[2];
    res[86][2] = v[1];
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    res[90][0] = -v[2];
    res[90][1] = v[1];
    res[90][2] = -v[0];
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0];
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    res[94][0] = v[2];
    res[94][1] = v[1];
    res[94][2] = v[0];
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    phase[17] = v[1]*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[2];
    res[18][2] = v[1];
    phase[18] = v[0]*1./2;
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    phase[24] = v[2]*1./2;
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    phase[25] = v[1]*1./2;
    res[26][0] = -v[0];
    res[26][1] = v[2];
    res[26][2] = -v[1];
    phase[26] = v[0]*1./2;
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = v[2];
    res[28][1] = -v[1];
    res[28][2] = -v[0];
    phase[28] = v[2]*1./2;
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    phase[29] = v[1]*1./2;
    res[30][0] = v[2];
    res[30][1] = -v[1];
    res[30][2] = -v[0];
    phase[30] = v[0]*1./2;
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] =  0;
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[0]+v[2])*1./2;
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = -v[2];
    res[36][1] = -v[1];
    res[36][2] = v[0];
    phase[36] = v[2]*1./2;
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    phase[37] = v[1]*1./2;
    res[38][0] = -v[2];
    res[38][1] = -v[1];
    res[38][2] = v[0];
    phase[38] = v[0]*1./2;
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[2])*1./2;
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    phase[45] = (v[1]+v[2])*1./2;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] =  0;
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    phase[49] = (v[1]+v[2])*1./2;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[2])*1./2;
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    phase[51] = (v[0]+v[1])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] =  0;
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = (v[1]+v[2])*1./2;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[2])*1./2;
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] =  0;
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    phase[57] = (v[1]+v[2])*1./2;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[0]+v[2])*1./2;
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    phase[59] = (v[0]+v[1])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] =  0;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    phase[61] = (v[1]+v[2])*1./2;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[2])*1./2;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] =  0;
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    phase[65] = (v[1]+v[2])*1./2;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[0]+v[2])*1./2;
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    phase[67] = (v[0]+v[1])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] =  0;
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    phase[69] = (v[1]+v[2])*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[2])*1./2;
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2];
    phase[72] = v[2]*1./2;
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    phase[73] = v[1]*1./2;
    res[74][0] = -v[1];
    res[74][1] = -v[0];
    res[74][2] = v[2];
    phase[74] = v[0]*1./2;
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    phase[75] = (v[0]+v[1]+v[2])*1./2;
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2];
    phase[76] = v[2]*1./2;
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    phase[77] = v[1]*1./2;
    res[78][0] = v[1];
    res[78][1] = v[0];
    res[78][2] = v[2];
    phase[78] = v[0]*1./2;
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    phase[79] = (v[0]+v[1]+v[2])*1./2;
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1];
    phase[80] = v[2]*1./2;
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    phase[81] = v[1]*1./2;
    res[82][0] = v[0];
    res[82][1] = -v[2];
    res[82][2] = -v[1];
    phase[82] = v[0]*1./2;
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    phase[83] = (v[0]+v[1]+v[2])*1./2;
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1];
    phase[84] = v[2]*1./2;
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    phase[85] = v[1]*1./2;
    res[86][0] = v[0];
    res[86][1] = v[2];
    res[86][2] = v[1];
    phase[86] = v[0]*1./2;
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    phase[87] = (v[0]+v[1]+v[2])*1./2;
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0];
    phase[88] = v[2]*1./2;
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    phase[89] = v[1]*1./2;
    res[90][0] = -v[2];
    res[90][1] = v[1];
    res[90][2] = -v[0];
    phase[90] = v[0]*1./2;
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    phase[91] = (v[0]+v[1]+v[2])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0];
    phase[92] = v[2]*1./2;
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    phase[93] = v[1]*1./2;
    res[94][0] = v[2];
    res[94][1] = v[1];
    res[94][2] = v[0];
    phase[94] = v[0]*1./2;
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
    phase[95] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F_43m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = -v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0]+1./2;
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0];
    res[14][2] = -v[2]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    res[17][0] = -v[0];
    res[17][1] = v[2]+1./2;
    res[17][2] = -v[1]+1./2;
    res[18][0] = -v[0]+1./2;
    res[18][1] = v[2];
    res[18][2] = -v[1]+1./2;
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[2]+1./2;
    res[19][2] = -v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = -v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    res[25][0] = -v[0];
    res[25][1] = -v[2]+1./2;
    res[25][2] = v[1]+1./2;
    res[26][0] = -v[0]+1./2;
    res[26][1] = -v[2];
    res[26][2] = v[1]+1./2;
    res[27][0] = -v[0]+1./2;
    res[27][1] = -v[2]+1./2;
    res[27][2] = v[1];
    res[28][0] = -v[2];
    res[28][1] = -v[1];
    res[28][2] = v[0];
    res[29][0] = -v[2];
    res[29][1] = -v[1]+1./2;
    res[29][2] = v[0]+1./2;
    res[30][0] = -v[2]+1./2;
    res[30][1] = -v[1];
    res[30][2] = v[0]+1./2;
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[1]+1./2;
    res[31][2] = v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1]+1./2;
    res[33][2] = -v[2]+1./2;
    res[34][0] = -v[0]+1./2;
    res[34][1] = v[1];
    res[34][2] = -v[2]+1./2;
    res[35][0] = -v[0]+1./2;
    res[35][1] = v[1]+1./2;
    res[35][2] = -v[2];
    res[36][0] = v[2];
    res[36][1] = -v[1];
    res[36][2] = -v[0];
    res[37][0] = v[2];
    res[37][1] = -v[1]+1./2;
    res[37][2] = -v[0]+1./2;
    res[38][0] = v[2]+1./2;
    res[38][1] = -v[1];
    res[38][2] = -v[0]+1./2;
    res[39][0] = v[2]+1./2;
    res[39][1] = -v[1]+1./2;
    res[39][2] = -v[0];
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0]+1./2;
    res[41][2] = v[1]+1./2;
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0];
    res[42][2] = v[1]+1./2;
    res[43][0] = v[2]+1./2;
    res[43][1] = v[0]+1./2;
    res[43][2] = v[1];
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = v[1];
    res[45][1] = v[2]+1./2;
    res[45][2] = v[0]+1./2;
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2];
    res[46][2] = v[0]+1./2;
    res[47][0] = v[1]+1./2;
    res[47][1] = v[2]+1./2;
    res[47][2] = v[0];
    res[48][0] = -v[1];
    res[48][1] = -v[2];
    res[48][2] = v[0];
    res[49][0] = -v[1];
    res[49][1] = -v[2]+1./2;
    res[49][2] = v[0]+1./2;
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2];
    res[50][2] = v[0]+1./2;
    res[51][0] = -v[1]+1./2;
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[0];
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1];
    res[53][0] = v[2];
    res[53][1] = -v[0]+1./2;
    res[53][2] = -v[1]+1./2;
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0];
    res[54][2] = -v[1]+1./2;
    res[55][0] = v[2]+1./2;
    res[55][1] = -v[0]+1./2;
    res[55][2] = -v[1];
    res[56][0] = -v[1];
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2]+1./2;
    res[57][2] = -v[0]+1./2;
    res[58][0] = -v[1]+1./2;
    res[58][1] = v[2];
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[1]+1./2;
    res[59][1] = v[2]+1./2;
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = -v[0];
    res[60][2] = v[1];
    res[61][0] = -v[2];
    res[61][1] = -v[0]+1./2;
    res[61][2] = v[1]+1./2;
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0];
    res[62][2] = v[1]+1./2;
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = -v[2];
    res[65][1] = v[0]+1./2;
    res[65][2] = -v[1]+1./2;
    res[66][0] = -v[2]+1./2;
    res[66][1] = v[0];
    res[66][2] = -v[1]+1./2;
    res[67][0] = -v[2]+1./2;
    res[67][1] = v[0]+1./2;
    res[67][2] = -v[1];
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0];
    res[69][0] = v[1];
    res[69][1] = -v[2]+1./2;
    res[69][2] = -v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2];
    res[70][2] = -v[0]+1./2;
    res[71][0] = v[1]+1./2;
    res[71][1] = -v[2]+1./2;
    res[71][2] = -v[0];
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0]+1./2;
    res[73][2] = v[2]+1./2;
    res[74][0] = -v[1]+1./2;
    res[74][1] = -v[0];
    res[74][2] = v[2]+1./2;
    res[75][0] = -v[1]+1./2;
    res[75][1] = -v[0]+1./2;
    res[75][2] = v[2];
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2];
    res[77][0] = v[1];
    res[77][1] = v[0]+1./2;
    res[77][2] = v[2]+1./2;
    res[78][0] = v[1]+1./2;
    res[78][1] = v[0];
    res[78][2] = v[2]+1./2;
    res[79][0] = v[1]+1./2;
    res[79][1] = v[0]+1./2;
    res[79][2] = v[2];
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2]+1./2;
    res[81][2] = -v[1]+1./2;
    res[82][0] = v[0]+1./2;
    res[82][1] = -v[2];
    res[82][2] = -v[1]+1./2;
    res[83][0] = v[0]+1./2;
    res[83][1] = -v[2]+1./2;
    res[83][2] = -v[1];
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1];
    res[85][0] = v[0];
    res[85][1] = v[2]+1./2;
    res[85][2] = v[1]+1./2;
    res[86][0] = v[0]+1./2;
    res[86][1] = v[2];
    res[86][2] = v[1]+1./2;
    res[87][0] = v[0]+1./2;
    res[87][1] = v[2]+1./2;
    res[87][2] = v[1];
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1]+1./2;
    res[89][2] = -v[0]+1./2;
    res[90][0] = -v[2]+1./2;
    res[90][1] = v[1];
    res[90][2] = -v[0]+1./2;
    res[91][0] = -v[2]+1./2;
    res[91][1] = v[1]+1./2;
    res[91][2] = -v[0];
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0];
    res[93][0] = v[2];
    res[93][1] = v[1]+1./2;
    res[93][2] = v[0]+1./2;
    res[94][0] = v[2]+1./2;
    res[94][1] = v[1];
    res[94][2] = v[0]+1./2;
    res[95][0] = v[2]+1./2;
    res[95][1] = v[1]+1./2;
    res[95][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[2];
    res[18][2] = v[1];
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    res[26][0] = -v[0];
    res[26][1] = v[2];
    res[26][2] = -v[1];
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    res[28][0] = v[2];
    res[28][1] = -v[1];
    res[28][2] = -v[0];
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    res[30][0] = v[2];
    res[30][1] = -v[1];
    res[30][2] = -v[0];
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    res[36][0] = -v[2];
    res[36][1] = -v[1];
    res[36][2] = v[0];
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    res[38][0] = -v[2];
    res[38][1] = -v[1];
    res[38][2] = v[0];
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    res[74][0] = -v[1];
    res[74][1] = -v[0];
    res[74][2] = v[2];
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2];
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    res[78][0] = v[1];
    res[78][1] = v[0];
    res[78][2] = v[2];
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    res[82][0] = v[0];
    res[82][1] = -v[2];
    res[82][2] = -v[1];
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1];
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    res[86][0] = v[0];
    res[86][1] = v[2];
    res[86][2] = v[1];
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    res[90][0] = -v[2];
    res[90][1] = v[1];
    res[90][2] = -v[0];
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0];
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    res[94][0] = v[2];
    res[94][1] = v[1];
    res[94][2] = v[0];
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = -v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[2];
    res[18][2] = v[1];
    phase[18] = (v[0]+v[2])*1./2;
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    phase[25] = (v[1]+v[2])*1./2;
    res[26][0] = -v[0];
    res[26][1] = v[2];
    res[26][2] = -v[1];
    phase[26] = (v[0]+v[2])*1./2;
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = v[2];
    res[28][1] = -v[1];
    res[28][2] = -v[0];
    phase[28] =  0;
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    phase[29] = (v[1]+v[2])*1./2;
    res[30][0] = v[2];
    res[30][1] = -v[1];
    res[30][2] = -v[0];
    phase[30] = (v[0]+v[2])*1./2;
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] =  0;
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[0]+v[2])*1./2;
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = -v[2];
    res[36][1] = -v[1];
    res[36][2] = v[0];
    phase[36] =  0;
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    phase[37] = (v[1]+v[2])*1./2;
    res[38][0] = -v[2];
    res[38][1] = -v[1];
    res[38][2] = v[0];
    phase[38] = (v[0]+v[2])*1./2;
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    phase[39] = (v[0]+v[1])*1./2;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[2])*1./2;
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    phase[45] = (v[1]+v[2])*1./2;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] =  0;
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    phase[49] = (v[1]+v[2])*1./2;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[2])*1./2;
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    phase[51] = (v[0]+v[1])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] =  0;
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = (v[1]+v[2])*1./2;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[2])*1./2;
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] =  0;
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    phase[57] = (v[1]+v[2])*1./2;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[0]+v[2])*1./2;
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    phase[59] = (v[0]+v[1])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] =  0;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    phase[61] = (v[1]+v[2])*1./2;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[2])*1./2;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] =  0;
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    phase[65] = (v[1]+v[2])*1./2;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[0]+v[2])*1./2;
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    phase[67] = (v[0]+v[1])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] =  0;
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    phase[69] = (v[1]+v[2])*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[2])*1./2;
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = -v[1];
    res[72][1] = -v[0];
    res[72][2] = v[2];
    phase[72] =  0;
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    phase[73] = (v[1]+v[2])*1./2;
    res[74][0] = -v[1];
    res[74][1] = -v[0];
    res[74][2] = v[2];
    phase[74] = (v[0]+v[2])*1./2;
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    phase[75] = (v[0]+v[1])*1./2;
    res[76][0] = v[1];
    res[76][1] = v[0];
    res[76][2] = v[2];
    phase[76] =  0;
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    phase[77] = (v[1]+v[2])*1./2;
    res[78][0] = v[1];
    res[78][1] = v[0];
    res[78][2] = v[2];
    phase[78] = (v[0]+v[2])*1./2;
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    phase[79] = (v[0]+v[1])*1./2;
    res[80][0] = v[0];
    res[80][1] = -v[2];
    res[80][2] = -v[1];
    phase[80] =  0;
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    phase[81] = (v[1]+v[2])*1./2;
    res[82][0] = v[0];
    res[82][1] = -v[2];
    res[82][2] = -v[1];
    phase[82] = (v[0]+v[2])*1./2;
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    phase[83] = (v[0]+v[1])*1./2;
    res[84][0] = v[0];
    res[84][1] = v[2];
    res[84][2] = v[1];
    phase[84] =  0;
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    phase[85] = (v[1]+v[2])*1./2;
    res[86][0] = v[0];
    res[86][1] = v[2];
    res[86][2] = v[1];
    phase[86] = (v[0]+v[2])*1./2;
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = -v[2];
    res[88][1] = v[1];
    res[88][2] = -v[0];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    phase[89] = (v[1]+v[2])*1./2;
    res[90][0] = -v[2];
    res[90][1] = v[1];
    res[90][2] = -v[0];
    phase[90] = (v[0]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    phase[91] = (v[0]+v[1])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[1];
    res[92][2] = v[0];
    phase[92] =  0;
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    phase[93] = (v[1]+v[2])*1./2;
    res[94][0] = v[2];
    res[94][1] = v[1];
    res[94][2] = v[0];
    phase[94] = (v[0]+v[2])*1./2;
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
    phase[95] = (v[0]+v[1])*1./2;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1]+1./2;
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = -v[0]+1./2;
    res[15][1] = v[1]+1./2;
    res[15][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F23 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[0]+1./2;
    res[5][2] = v[1]+1./2;
    res[6][0] = v[2]+1./2;
    res[6][1] = v[0];
    res[6][2] = v[1]+1./2;
    res[7][0] = v[2]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[1];
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    res[9][0] = v[1];
    res[9][1] = v[2]+1./2;
    res[9][2] = v[0]+1./2;
    res[10][0] = v[1]+1./2;
    res[10][1] = v[2];
    res[10][2] = v[0]+1./2;
    res[11][0] = v[1]+1./2;
    res[11][1] = v[2]+1./2;
    res[11][2] = v[0];
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = -v[1];
    res[13][1] = -v[2]+1./2;
    res[13][2] = v[0]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[2];
    res[14][2] = v[0]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = -v[2]+1./2;
    res[15][2] = v[0];
    res[16][0] = v[2];
    res[16][1] = -v[0];
    res[16][2] = -v[1];
    res[17][0] = v[2];
    res[17][1] = -v[0]+1./2;
    res[17][2] = -v[1]+1./2;
    res[18][0] = v[2]+1./2;
    res[18][1] = -v[0];
    res[18][2] = -v[1]+1./2;
    res[19][0] = v[2]+1./2;
    res[19][1] = -v[0]+1./2;
    res[19][2] = -v[1];
    res[20][0] = -v[1];
    res[20][1] = v[2];
    res[20][2] = -v[0];
    res[21][0] = -v[1];
    res[21][1] = v[2]+1./2;
    res[21][2] = -v[0]+1./2;
    res[22][0] = -v[1]+1./2;
    res[22][1] = v[2];
    res[22][2] = -v[0]+1./2;
    res[23][0] = -v[1]+1./2;
    res[23][1] = v[2]+1./2;
    res[23][2] = -v[0];
    res[24][0] = -v[2];
    res[24][1] = -v[0];
    res[24][2] = v[1];
    res[25][0] = -v[2];
    res[25][1] = -v[0]+1./2;
    res[25][2] = v[1]+1./2;
    res[26][0] = -v[2]+1./2;
    res[26][1] = -v[0];
    res[26][2] = v[1]+1./2;
    res[27][0] = -v[2]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = v[1];
    res[28][0] = -v[2];
    res[28][1] = v[0];
    res[28][2] = -v[1];
    res[29][0] = -v[2];
    res[29][1] = v[0]+1./2;
    res[29][2] = -v[1]+1./2;
    res[30][0] = -v[2]+1./2;
    res[30][1] = v[0];
    res[30][2] = -v[1]+1./2;
    res[31][0] = -v[2]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[1];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = v[1];
    res[33][1] = -v[2]+1./2;
    res[33][2] = -v[0]+1./2;
    res[34][0] = v[1]+1./2;
    res[34][1] = -v[2];
    res[34][2] = -v[0]+1./2;
    res[35][0] = v[1]+1./2;
    res[35][1] = -v[2]+1./2;
    res[35][2] = -v[0];
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    res[37][0] = -v[0];
    res[37][1] = -v[1]+1./2;
    res[37][2] = v[2]+1./2;
    res[38][0] = -v[0]+1./2;
    res[38][1] = -v[1];
    res[38][2] = v[2]+1./2;
    res[39][0] = -v[0]+1./2;
    res[39][1] = -v[1]+1./2;
    res[39][2] = v[2];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = v[0];
    res[41][1] = -v[1]+1./2;
    res[41][2] = -v[2]+1./2;
    res[42][0] = v[0]+1./2;
    res[42][1] = -v[1];
    res[42][2] = -v[2]+1./2;
    res[43][0] = v[0]+1./2;
    res[43][1] = -v[1]+1./2;
    res[43][2] = -v[2];
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1]+1./2;
    res[45][2] = -v[2]+1./2;
    res[46][0] = -v[0]+1./2;
    res[46][1] = v[1];
    res[46][2] = -v[2]+1./2;
    res[47][0] = -v[0]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = v[1];
    res[5][1] = v[2];
    res[5][2] = v[0];
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    res[7][0] = v[1];
    res[7][1] = v[2];
    res[7][2] = v[0];
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    res[9][0] = v[2];
    res[9][1] = v[0];
    res[9][2] = v[1];
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    res[15][0] = v[2];
    res[15][1] = -v[0];
    res[15][2] = -v[1];
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    res[17][0] = -v[1];
    res[17][1] = -v[2];
    res[17][2] = v[0];
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    res[19][0] = -v[1];
    res[19][1] = -v[2];
    res[19][2] = v[0];
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = v[1];
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = v[1];
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    res[25][0] = -v[1];
    res[25][1] = v[2];
    res[25][2] = -v[0];
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    res[27][0] = -v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    res[29][0] = v[1];
    res[29][1] = -v[2];
    res[29][2] = -v[0];
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = -v[0];
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2];
    res[33][1] = v[0];
    res[33][2] = -v[1];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    res[37][0] = -v[0];
    res[37][1] = -v[1];
    res[37][2] = v[2];
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    res[39][0] = -v[0];
    res[39][1] = -v[1];
    res[39][2] = v[2];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = v[0];
    res[41][1] = -v[1];
    res[41][2] = -v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = v[0];
    res[43][1] = -v[1];
    res[43][2] = -v[2];
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = -v[2];
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = v[2];
    res[5][2] = v[0];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[2];
    res[7][2] = v[0];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    phase[8] =  0;
    res[9][0] = v[2];
    res[9][1] = v[0];
    res[9][2] = v[1];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[2];
    res[15][1] = -v[0];
    res[15][2] = -v[1];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    phase[16] =  0;
    res[17][0] = -v[1];
    res[17][1] = -v[2];
    res[17][2] = v[0];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    phase[18] = (v[0]+v[2])*1./2;
    res[19][0] = -v[1];
    res[19][1] = -v[2];
    res[19][2] = v[0];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    phase[20] =  0;
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = v[1];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = v[1];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    phase[24] =  0;
    res[25][0] = -v[1];
    res[25][1] = v[2];
    res[25][2] = -v[0];
    phase[25] = (v[1]+v[2])*1./2;
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    phase[26] = (v[0]+v[2])*1./2;
    res[27][0] = -v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    phase[28] =  0;
    res[29][0] = v[1];
    res[29][1] = -v[2];
    res[29][2] = -v[0];
    phase[29] = (v[1]+v[2])*1./2;
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    phase[30] = (v[0]+v[2])*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    phase[32] =  0;
    res[33][0] = -v[2];
    res[33][1] = v[0];
    res[33][2] = -v[1];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = (v[0]+v[2])*1./2;
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    phase[36] =  0;
    res[37][0] = -v[0];
    res[37][1] = -v[1];
    res[37][2] = v[2];
    phase[37] = (v[1]+v[2])*1./2;
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    phase[38] = (v[0]+v[2])*1./2;
    res[39][0] = -v[0];
    res[39][1] = -v[1];
    res[39][2] = v[2];
    phase[39] = (v[0]+v[1])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] =  0;
    res[41][0] = v[0];
    res[41][1] = -v[1];
    res[41][2] = -v[2];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[0]+v[2])*1./2;
    res[43][0] = v[0];
    res[43][1] = -v[1];
    res[43][2] = -v[2];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    phase[44] =  0;
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = -v[2];
    phase[45] = (v[1]+v[2])*1./2;
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    phase[46] = (v[0]+v[2])*1./2;
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = -v[2];
    phase[47] = (v[0]+v[1])*1./2;
  }
  static const short size=48;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F2dd {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./4;
    res[8][1] = v[1]+1./4;
    res[8][2] = -v[2]+1./4;
    res[9][0] = v[0]+1./4;
    res[9][1] = v[1]+3./4;
    res[9][2] = -v[2]+3./4;
    res[10][0] = v[0]+3./4;
    res[10][1] = v[1]+1./4;
    res[10][2] = -v[2]+3./4;
    res[11][0] = v[0]+3./4;
    res[11][1] = v[1]+3./4;
    res[11][2] = -v[2]+1./4;
    res[12][0] = v[0]+1./4;
    res[12][1] = -v[1]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = v[0]+1./4;
    res[13][1] = -v[1]+3./4;
    res[13][2] = v[2]+3./4;
    res[14][0] = v[0]+3./4;
    res[14][1] = -v[1]+1./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = v[0]+3./4;
    res[15][1] = -v[1]+3./4;
    res[15][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1]+v[2])*1./4;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./4;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[0]+1./2;
    res[14][1] = -v[1];
    res[14][2] = v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F4132 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[1]+1./4;
    res[4][1] = v[0]+1./4;
    res[4][2] = v[2]+1./4;
    res[5][0] = -v[1]+1./4;
    res[5][1] = v[0]+3./4;
    res[5][2] = v[2]+3./4;
    res[6][0] = -v[1]+3./4;
    res[6][1] = v[0]+1./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = -v[1]+3./4;
    res[7][1] = v[0]+3./4;
    res[7][2] = v[2]+1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1]+1./4;
    res[12][1] = -v[0]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = v[1]+1./4;
    res[13][1] = -v[0]+3./4;
    res[13][2] = v[2]+3./4;
    res[14][0] = v[1]+3./4;
    res[14][1] = -v[0]+1./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = v[1]+3./4;
    res[15][1] = -v[0]+3./4;
    res[15][2] = v[2]+1./4;
    res[16][0] = v[0]+1./4;
    res[16][1] = -v[2]+1./4;
    res[16][2] = v[1]+1./4;
    res[17][0] = v[0]+1./4;
    res[17][1] = -v[2]+3./4;
    res[17][2] = v[1]+3./4;
    res[18][0] = v[0]+3./4;
    res[18][1] = -v[2]+1./4;
    res[18][2] = v[1]+3./4;
    res[19][0] = v[0]+3./4;
    res[19][1] = -v[2]+3./4;
    res[19][2] = v[1]+1./4;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = v[0]+1./4;
    res[24][1] = v[2]+1./4;
    res[24][2] = -v[1]+1./4;
    res[25][0] = v[0]+1./4;
    res[25][1] = v[2]+3./4;
    res[25][2] = -v[1]+3./4;
    res[26][0] = v[0]+3./4;
    res[26][1] = v[2]+1./4;
    res[26][2] = -v[1]+3./4;
    res[27][0] = v[0]+3./4;
    res[27][1] = v[2]+3./4;
    res[27][2] = -v[1]+1./4;
    res[28][0] = v[2]+1./4;
    res[28][1] = v[1]+1./4;
    res[28][2] = -v[0]+1./4;
    res[29][0] = v[2]+1./4;
    res[29][1] = v[1]+3./4;
    res[29][2] = -v[0]+3./4;
    res[30][0] = v[2]+3./4;
    res[30][1] = v[1]+1./4;
    res[30][2] = -v[0]+3./4;
    res[31][0] = v[2]+3./4;
    res[31][1] = v[1]+3./4;
    res[31][2] = -v[0]+1./4;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1]+1./2;
    res[33][2] = -v[2]+1./2;
    res[34][0] = -v[0]+1./2;
    res[34][1] = v[1];
    res[34][2] = -v[2]+1./2;
    res[35][0] = -v[0]+1./2;
    res[35][1] = v[1]+1./2;
    res[35][2] = -v[2];
    res[36][0] = -v[2]+1./4;
    res[36][1] = v[1]+1./4;
    res[36][2] = v[0]+1./4;
    res[37][0] = -v[2]+1./4;
    res[37][1] = v[1]+3./4;
    res[37][2] = v[0]+3./4;
    res[38][0] = -v[2]+3./4;
    res[38][1] = v[1]+1./4;
    res[38][2] = v[0]+3./4;
    res[39][0] = -v[2]+3./4;
    res[39][1] = v[1]+3./4;
    res[39][2] = v[0]+1./4;
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0]+1./2;
    res[41][2] = v[1]+1./2;
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0];
    res[42][2] = v[1]+1./2;
    res[43][0] = v[2]+1./2;
    res[43][1] = v[0]+1./2;
    res[43][2] = v[1];
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = v[1];
    res[45][1] = v[2]+1./2;
    res[45][2] = v[0]+1./2;
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2];
    res[46][2] = v[0]+1./2;
    res[47][0] = v[1]+1./2;
    res[47][1] = v[2]+1./2;
    res[47][2] = v[0];
    res[48][0] = -v[1];
    res[48][1] = -v[2];
    res[48][2] = v[0];
    res[49][0] = -v[1];
    res[49][1] = -v[2]+1./2;
    res[49][2] = v[0]+1./2;
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2];
    res[50][2] = v[0]+1./2;
    res[51][0] = -v[1]+1./2;
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[0];
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1];
    res[53][0] = v[2];
    res[53][1] = -v[0]+1./2;
    res[53][2] = -v[1]+1./2;
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0];
    res[54][2] = -v[1]+1./2;
    res[55][0] = v[2]+1./2;
    res[55][1] = -v[0]+1./2;
    res[55][2] = -v[1];
    res[56][0] = -v[1];
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2]+1./2;
    res[57][2] = -v[0]+1./2;
    res[58][0] = -v[1]+1./2;
    res[58][1] = v[2];
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[1]+1./2;
    res[59][1] = v[2]+1./2;
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = -v[0];
    res[60][2] = v[1];
    res[61][0] = -v[2];
    res[61][1] = -v[0]+1./2;
    res[61][2] = v[1]+1./2;
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0];
    res[62][2] = v[1]+1./2;
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = -v[2];
    res[65][1] = v[0]+1./2;
    res[65][2] = -v[1]+1./2;
    res[66][0] = -v[2]+1./2;
    res[66][1] = v[0];
    res[66][2] = -v[1]+1./2;
    res[67][0] = -v[2]+1./2;
    res[67][1] = v[0]+1./2;
    res[67][2] = -v[1];
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0];
    res[69][0] = v[1];
    res[69][1] = -v[2]+1./2;
    res[69][2] = -v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2];
    res[70][2] = -v[0]+1./2;
    res[71][0] = v[1]+1./2;
    res[71][1] = -v[2]+1./2;
    res[71][2] = -v[0];
    res[72][0] = v[1]+1./4;
    res[72][1] = v[0]+1./4;
    res[72][2] = -v[2]+1./4;
    res[73][0] = v[1]+1./4;
    res[73][1] = v[0]+3./4;
    res[73][2] = -v[2]+3./4;
    res[74][0] = v[1]+3./4;
    res[74][1] = v[0]+1./4;
    res[74][2] = -v[2]+3./4;
    res[75][0] = v[1]+3./4;
    res[75][1] = v[0]+3./4;
    res[75][2] = -v[2]+1./4;
    res[76][0] = -v[1]+1./4;
    res[76][1] = -v[0]+1./4;
    res[76][2] = -v[2]+1./4;
    res[77][0] = -v[1]+1./4;
    res[77][1] = -v[0]+3./4;
    res[77][2] = -v[2]+3./4;
    res[78][0] = -v[1]+3./4;
    res[78][1] = -v[0]+1./4;
    res[78][2] = -v[2]+3./4;
    res[79][0] = -v[1]+3./4;
    res[79][1] = -v[0]+3./4;
    res[79][2] = -v[2]+1./4;
    res[80][0] = -v[0]+1./4;
    res[80][1] = v[2]+1./4;
    res[80][2] = v[1]+1./4;
    res[81][0] = -v[0]+1./4;
    res[81][1] = v[2]+3./4;
    res[81][2] = v[1]+3./4;
    res[82][0] = -v[0]+3./4;
    res[82][1] = v[2]+1./4;
    res[82][2] = v[1]+3./4;
    res[83][0] = -v[0]+3./4;
    res[83][1] = v[2]+3./4;
    res[83][2] = v[1]+1./4;
    res[84][0] = -v[0]+1./4;
    res[84][1] = -v[2]+1./4;
    res[84][2] = -v[1]+1./4;
    res[85][0] = -v[0]+1./4;
    res[85][1] = -v[2]+3./4;
    res[85][2] = -v[1]+3./4;
    res[86][0] = -v[0]+3./4;
    res[86][1] = -v[2]+1./4;
    res[86][2] = -v[1]+3./4;
    res[87][0] = -v[0]+3./4;
    res[87][1] = -v[2]+3./4;
    res[87][2] = -v[1]+1./4;
    res[88][0] = v[2]+1./4;
    res[88][1] = -v[1]+1./4;
    res[88][2] = v[0]+1./4;
    res[89][0] = v[2]+1./4;
    res[89][1] = -v[1]+3./4;
    res[89][2] = v[0]+3./4;
    res[90][0] = v[2]+3./4;
    res[90][1] = -v[1]+1./4;
    res[90][2] = v[0]+3./4;
    res[91][0] = v[2]+3./4;
    res[91][1] = -v[1]+3./4;
    res[91][2] = v[0]+1./4;
    res[92][0] = -v[2]+1./4;
    res[92][1] = -v[1]+1./4;
    res[92][2] = -v[0]+1./4;
    res[93][0] = -v[2]+1./4;
    res[93][1] = -v[1]+3./4;
    res[93][2] = -v[0]+3./4;
    res[94][0] = -v[2]+3./4;
    res[94][1] = -v[1]+1./4;
    res[94][2] = -v[0]+3./4;
    res[95][0] = -v[2]+3./4;
    res[95][1] = -v[1]+3./4;
    res[95][2] = -v[0]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    res[17][0] = v[0];
    res[17][1] = v[2];
    res[17][2] = -v[1];
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    res[19][0] = v[0];
    res[19][1] = v[2];
    res[19][2] = -v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    res[25][0] = v[0];
    res[25][1] = -v[2];
    res[25][2] = v[1];
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    res[27][0] = v[0];
    res[27][1] = -v[2];
    res[27][2] = v[1];
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    res[29][0] = -v[2];
    res[29][1] = v[1];
    res[29][2] = v[0];
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    res[31][0] = -v[2];
    res[31][1] = v[1];
    res[31][2] = v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    res[37][0] = v[2];
    res[37][1] = v[1];
    res[37][2] = -v[0];
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    res[39][0] = v[2];
    res[39][1] = v[1];
    res[39][2] = -v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = v[1];
    res[73][1] = v[0];
    res[73][2] = -v[2];
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    res[75][0] = v[1];
    res[75][1] = v[0];
    res[75][2] = -v[2];
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = -v[1];
    res[77][1] = -v[0];
    res[77][2] = -v[2];
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    res[79][0] = -v[1];
    res[79][1] = -v[0];
    res[79][2] = -v[2];
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = -v[0];
    res[81][1] = v[2];
    res[81][2] = v[1];
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    res[83][0] = -v[0];
    res[83][1] = v[2];
    res[83][2] = v[1];
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = -v[0];
    res[85][1] = -v[2];
    res[85][2] = -v[1];
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    res[87][0] = -v[0];
    res[87][1] = -v[2];
    res[87][2] = -v[1];
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = v[2];
    res[89][1] = -v[1];
    res[89][2] = v[0];
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    res[91][0] = v[2];
    res[91][1] = -v[1];
    res[91][2] = v[0];
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = -v[2];
    res[93][1] = -v[1];
    res[93][2] = -v[0];
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    res[95][0] = -v[2];
    res[95][1] = -v[1];
    res[95][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./4;
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    phase[5] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./4;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = v[2];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    phase[16] = (v[0]+v[1]+v[2])*1./4;
    res[17][0] = v[0];
    res[17][1] = v[2];
    res[17][2] = -v[1];
    phase[17] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    phase[18] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[19][0] = v[0];
    res[19][1] = v[2];
    res[19][2] = -v[1];
    phase[19] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    phase[24] = (v[0]+v[1]+v[2])*1./4;
    res[25][0] = v[0];
    res[25][1] = -v[2];
    res[25][2] = v[1];
    phase[25] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    phase[26] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[27][0] = v[0];
    res[27][1] = -v[2];
    res[27][2] = v[1];
    phase[27] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    phase[28] = (v[0]+v[1]+v[2])*1./4;
    res[29][0] = -v[2];
    res[29][1] = v[1];
    res[29][2] = v[0];
    phase[29] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    phase[30] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[31][0] = -v[2];
    res[31][1] = v[1];
    res[31][2] = v[0];
    phase[31] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] =  0;
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[0]+v[2])*1./2;
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    phase[36] = (v[0]+v[1]+v[2])*1./4;
    res[37][0] = v[2];
    res[37][1] = v[1];
    res[37][2] = -v[0];
    phase[37] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    phase[38] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[39][0] = v[2];
    res[39][1] = v[1];
    res[39][2] = -v[0];
    phase[39] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[2])*1./2;
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    phase[45] = (v[1]+v[2])*1./2;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] =  0;
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    phase[49] = (v[1]+v[2])*1./2;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[2])*1./2;
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    phase[51] = (v[0]+v[1])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] =  0;
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = (v[1]+v[2])*1./2;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[2])*1./2;
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] =  0;
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    phase[57] = (v[1]+v[2])*1./2;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[0]+v[2])*1./2;
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    phase[59] = (v[0]+v[1])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] =  0;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    phase[61] = (v[1]+v[2])*1./2;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[2])*1./2;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] =  0;
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    phase[65] = (v[1]+v[2])*1./2;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[0]+v[2])*1./2;
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    phase[67] = (v[0]+v[1])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] =  0;
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    phase[69] = (v[1]+v[2])*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[2])*1./2;
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    phase[72] = (v[0]+v[1]+v[2])*1./4;
    res[73][0] = v[1];
    res[73][1] = v[0];
    res[73][2] = -v[2];
    phase[73] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    phase[74] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[75][0] = v[1];
    res[75][1] = v[0];
    res[75][2] = -v[2];
    phase[75] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    phase[76] = (v[0]+v[1]+v[2])*1./4;
    res[77][0] = -v[1];
    res[77][1] = -v[0];
    res[77][2] = -v[2];
    phase[77] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    phase[78] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[79][0] = -v[1];
    res[79][1] = -v[0];
    res[79][2] = -v[2];
    phase[79] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    phase[80] = (v[0]+v[1]+v[2])*1./4;
    res[81][0] = -v[0];
    res[81][1] = v[2];
    res[81][2] = v[1];
    phase[81] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    phase[82] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[83][0] = -v[0];
    res[83][1] = v[2];
    res[83][2] = v[1];
    phase[83] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    phase[84] = (v[0]+v[1]+v[2])*1./4;
    res[85][0] = -v[0];
    res[85][1] = -v[2];
    res[85][2] = -v[1];
    phase[85] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    phase[86] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[87][0] = -v[0];
    res[87][1] = -v[2];
    res[87][2] = -v[1];
    phase[87] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    phase[88] = (v[0]+v[1]+v[2])*1./4;
    res[89][0] = v[2];
    res[89][1] = -v[1];
    res[89][2] = v[0];
    phase[89] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    phase[90] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[91][0] = v[2];
    res[91][1] = -v[1];
    res[91][2] = v[0];
    phase[91] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    phase[92] = (v[0]+v[1]+v[2])*1./4;
    res[93][0] = -v[2];
    res[93][1] = -v[1];
    res[93][2] = -v[0];
    phase[93] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    phase[94] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[95][0] = -v[2];
    res[95][1] = -v[1];
    res[95][2] = -v[0];
    phase[95] = (v[0]+v[1])*3./4+v[2]*1./4;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_F432 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1]+1./2;
    res[6][1] = v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[1]+1./2;
    res[14][1] = -v[0];
    res[14][2] = v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = v[2];
    res[16][0] = v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    res[17][0] = v[0];
    res[17][1] = -v[2]+1./2;
    res[17][2] = v[1]+1./2;
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[2];
    res[18][2] = v[1]+1./2;
    res[19][0] = v[0]+1./2;
    res[19][1] = -v[2]+1./2;
    res[19][2] = v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    res[25][0] = v[0];
    res[25][1] = v[2]+1./2;
    res[25][2] = -v[1]+1./2;
    res[26][0] = v[0]+1./2;
    res[26][1] = v[2];
    res[26][2] = -v[1]+1./2;
    res[27][0] = v[0]+1./2;
    res[27][1] = v[2]+1./2;
    res[27][2] = -v[1];
    res[28][0] = v[2];
    res[28][1] = v[1];
    res[28][2] = -v[0];
    res[29][0] = v[2];
    res[29][1] = v[1]+1./2;
    res[29][2] = -v[0]+1./2;
    res[30][0] = v[2]+1./2;
    res[30][1] = v[1];
    res[30][2] = -v[0]+1./2;
    res[31][0] = v[2]+1./2;
    res[31][1] = v[1]+1./2;
    res[31][2] = -v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1]+1./2;
    res[33][2] = -v[2]+1./2;
    res[34][0] = -v[0]+1./2;
    res[34][1] = v[1];
    res[34][2] = -v[2]+1./2;
    res[35][0] = -v[0]+1./2;
    res[35][1] = v[1]+1./2;
    res[35][2] = -v[2];
    res[36][0] = -v[2];
    res[36][1] = v[1];
    res[36][2] = v[0];
    res[37][0] = -v[2];
    res[37][1] = v[1]+1./2;
    res[37][2] = v[0]+1./2;
    res[38][0] = -v[2]+1./2;
    res[38][1] = v[1];
    res[38][2] = v[0]+1./2;
    res[39][0] = -v[2]+1./2;
    res[39][1] = v[1]+1./2;
    res[39][2] = v[0];
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0]+1./2;
    res[41][2] = v[1]+1./2;
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0];
    res[42][2] = v[1]+1./2;
    res[43][0] = v[2]+1./2;
    res[43][1] = v[0]+1./2;
    res[43][2] = v[1];
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = v[1];
    res[45][1] = v[2]+1./2;
    res[45][2] = v[0]+1./2;
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2];
    res[46][2] = v[0]+1./2;
    res[47][0] = v[1]+1./2;
    res[47][1] = v[2]+1./2;
    res[47][2] = v[0];
    res[48][0] = -v[1];
    res[48][1] = -v[2];
    res[48][2] = v[0];
    res[49][0] = -v[1];
    res[49][1] = -v[2]+1./2;
    res[49][2] = v[0]+1./2;
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2];
    res[50][2] = v[0]+1./2;
    res[51][0] = -v[1]+1./2;
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[0];
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1];
    res[53][0] = v[2];
    res[53][1] = -v[0]+1./2;
    res[53][2] = -v[1]+1./2;
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0];
    res[54][2] = -v[1]+1./2;
    res[55][0] = v[2]+1./2;
    res[55][1] = -v[0]+1./2;
    res[55][2] = -v[1];
    res[56][0] = -v[1];
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2]+1./2;
    res[57][2] = -v[0]+1./2;
    res[58][0] = -v[1]+1./2;
    res[58][1] = v[2];
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[1]+1./2;
    res[59][1] = v[2]+1./2;
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = -v[0];
    res[60][2] = v[1];
    res[61][0] = -v[2];
    res[61][1] = -v[0]+1./2;
    res[61][2] = v[1]+1./2;
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0];
    res[62][2] = v[1]+1./2;
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = -v[2];
    res[65][1] = v[0]+1./2;
    res[65][2] = -v[1]+1./2;
    res[66][0] = -v[2]+1./2;
    res[66][1] = v[0];
    res[66][2] = -v[1]+1./2;
    res[67][0] = -v[2]+1./2;
    res[67][1] = v[0]+1./2;
    res[67][2] = -v[1];
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0];
    res[69][0] = v[1];
    res[69][1] = -v[2]+1./2;
    res[69][2] = -v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2];
    res[70][2] = -v[0]+1./2;
    res[71][0] = v[1]+1./2;
    res[71][1] = -v[2]+1./2;
    res[71][2] = -v[0];
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = v[1];
    res[73][1] = v[0]+1./2;
    res[73][2] = -v[2]+1./2;
    res[74][0] = v[1]+1./2;
    res[74][1] = v[0];
    res[74][2] = -v[2]+1./2;
    res[75][0] = v[1]+1./2;
    res[75][1] = v[0]+1./2;
    res[75][2] = -v[2];
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = -v[1];
    res[77][1] = -v[0]+1./2;
    res[77][2] = -v[2]+1./2;
    res[78][0] = -v[1]+1./2;
    res[78][1] = -v[0];
    res[78][2] = -v[2]+1./2;
    res[79][0] = -v[1]+1./2;
    res[79][1] = -v[0]+1./2;
    res[79][2] = -v[2];
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = -v[0];
    res[81][1] = v[2]+1./2;
    res[81][2] = v[1]+1./2;
    res[82][0] = -v[0]+1./2;
    res[82][1] = v[2];
    res[82][2] = v[1]+1./2;
    res[83][0] = -v[0]+1./2;
    res[83][1] = v[2]+1./2;
    res[83][2] = v[1];
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = -v[0];
    res[85][1] = -v[2]+1./2;
    res[85][2] = -v[1]+1./2;
    res[86][0] = -v[0]+1./2;
    res[86][1] = -v[2];
    res[86][2] = -v[1]+1./2;
    res[87][0] = -v[0]+1./2;
    res[87][1] = -v[2]+1./2;
    res[87][2] = -v[1];
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = v[2];
    res[89][1] = -v[1]+1./2;
    res[89][2] = v[0]+1./2;
    res[90][0] = v[2]+1./2;
    res[90][1] = -v[1];
    res[90][2] = v[0]+1./2;
    res[91][0] = v[2]+1./2;
    res[91][1] = -v[1]+1./2;
    res[91][2] = v[0];
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = -v[2];
    res[93][1] = -v[1]+1./2;
    res[93][2] = -v[0]+1./2;
    res[94][0] = -v[2]+1./2;
    res[94][1] = -v[1];
    res[94][2] = -v[0]+1./2;
    res[95][0] = -v[2]+1./2;
    res[95][1] = -v[1]+1./2;
    res[95][2] = -v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    res[17][0] = v[0];
    res[17][1] = v[2];
    res[17][2] = -v[1];
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    res[19][0] = v[0];
    res[19][1] = v[2];
    res[19][2] = -v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    res[25][0] = v[0];
    res[25][1] = -v[2];
    res[25][2] = v[1];
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    res[27][0] = v[0];
    res[27][1] = -v[2];
    res[27][2] = v[1];
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    res[29][0] = -v[2];
    res[29][1] = v[1];
    res[29][2] = v[0];
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    res[31][0] = -v[2];
    res[31][1] = v[1];
    res[31][2] = v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    res[37][0] = v[2];
    res[37][1] = v[1];
    res[37][2] = -v[0];
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    res[39][0] = v[2];
    res[39][1] = v[1];
    res[39][2] = -v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = v[1];
    res[73][1] = v[0];
    res[73][2] = -v[2];
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    res[75][0] = v[1];
    res[75][1] = v[0];
    res[75][2] = -v[2];
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = -v[1];
    res[77][1] = -v[0];
    res[77][2] = -v[2];
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    res[79][0] = -v[1];
    res[79][1] = -v[0];
    res[79][2] = -v[2];
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = -v[0];
    res[81][1] = v[2];
    res[81][2] = v[1];
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    res[83][0] = -v[0];
    res[83][1] = v[2];
    res[83][2] = v[1];
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = -v[0];
    res[85][1] = -v[2];
    res[85][2] = -v[1];
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    res[87][0] = -v[0];
    res[87][1] = -v[2];
    res[87][2] = -v[1];
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = v[2];
    res[89][1] = -v[1];
    res[89][2] = v[0];
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    res[91][0] = v[2];
    res[91][1] = -v[1];
    res[91][2] = v[0];
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = -v[2];
    res[93][1] = -v[1];
    res[93][2] = -v[0];
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    res[95][0] = -v[2];
    res[95][1] = -v[1];
    res[95][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    phase[16] =  0;
    res[17][0] = v[0];
    res[17][1] = v[2];
    res[17][2] = -v[1];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    phase[18] = (v[0]+v[2])*1./2;
    res[19][0] = v[0];
    res[19][1] = v[2];
    res[19][2] = -v[1];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    phase[24] =  0;
    res[25][0] = v[0];
    res[25][1] = -v[2];
    res[25][2] = v[1];
    phase[25] = (v[1]+v[2])*1./2;
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    phase[26] = (v[0]+v[2])*1./2;
    res[27][0] = v[0];
    res[27][1] = -v[2];
    res[27][2] = v[1];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    phase[28] =  0;
    res[29][0] = -v[2];
    res[29][1] = v[1];
    res[29][2] = v[0];
    phase[29] = (v[1]+v[2])*1./2;
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    phase[30] = (v[0]+v[2])*1./2;
    res[31][0] = -v[2];
    res[31][1] = v[1];
    res[31][2] = v[0];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] =  0;
    res[33][0] = -v[0];
    res[33][1] = v[1];
    res[33][2] = -v[2];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[0]+v[2])*1./2;
    res[35][0] = -v[0];
    res[35][1] = v[1];
    res[35][2] = -v[2];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    phase[36] =  0;
    res[37][0] = v[2];
    res[37][1] = v[1];
    res[37][2] = -v[0];
    phase[37] = (v[1]+v[2])*1./2;
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    phase[38] = (v[0]+v[2])*1./2;
    res[39][0] = v[2];
    res[39][1] = v[1];
    res[39][2] = -v[0];
    phase[39] = (v[0]+v[1])*1./2;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = v[1];
    res[41][1] = v[2];
    res[41][2] = v[0];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[2])*1./2;
    res[43][0] = v[1];
    res[43][1] = v[2];
    res[43][2] = v[0];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = v[1];
    phase[45] = (v[1]+v[2])*1./2;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = v[1];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] =  0;
    res[49][0] = v[2];
    res[49][1] = -v[0];
    res[49][2] = -v[1];
    phase[49] = (v[1]+v[2])*1./2;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[2])*1./2;
    res[51][0] = v[2];
    res[51][1] = -v[0];
    res[51][2] = -v[1];
    phase[51] = (v[0]+v[1])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] =  0;
    res[53][0] = -v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = (v[1]+v[2])*1./2;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[2])*1./2;
    res[55][0] = -v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] =  0;
    res[57][0] = -v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    phase[57] = (v[1]+v[2])*1./2;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[0]+v[2])*1./2;
    res[59][0] = -v[2];
    res[59][1] = -v[0];
    res[59][2] = v[1];
    phase[59] = (v[0]+v[1])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] =  0;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = -v[0];
    phase[61] = (v[1]+v[2])*1./2;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[2])*1./2;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] =  0;
    res[65][0] = v[1];
    res[65][1] = -v[2];
    res[65][2] = -v[0];
    phase[65] = (v[1]+v[2])*1./2;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[0]+v[2])*1./2;
    res[67][0] = v[1];
    res[67][1] = -v[2];
    res[67][2] = -v[0];
    phase[67] = (v[0]+v[1])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] =  0;
    res[69][0] = -v[2];
    res[69][1] = v[0];
    res[69][2] = -v[1];
    phase[69] = (v[1]+v[2])*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[2])*1./2;
    res[71][0] = -v[2];
    res[71][1] = v[0];
    res[71][2] = -v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    phase[72] =  0;
    res[73][0] = v[1];
    res[73][1] = v[0];
    res[73][2] = -v[2];
    phase[73] = (v[1]+v[2])*1./2;
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    phase[74] = (v[0]+v[2])*1./2;
    res[75][0] = v[1];
    res[75][1] = v[0];
    res[75][2] = -v[2];
    phase[75] = (v[0]+v[1])*1./2;
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    phase[76] =  0;
    res[77][0] = -v[1];
    res[77][1] = -v[0];
    res[77][2] = -v[2];
    phase[77] = (v[1]+v[2])*1./2;
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    phase[78] = (v[0]+v[2])*1./2;
    res[79][0] = -v[1];
    res[79][1] = -v[0];
    res[79][2] = -v[2];
    phase[79] = (v[0]+v[1])*1./2;
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    phase[80] =  0;
    res[81][0] = -v[0];
    res[81][1] = v[2];
    res[81][2] = v[1];
    phase[81] = (v[1]+v[2])*1./2;
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    phase[82] = (v[0]+v[2])*1./2;
    res[83][0] = -v[0];
    res[83][1] = v[2];
    res[83][2] = v[1];
    phase[83] = (v[0]+v[1])*1./2;
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    phase[84] =  0;
    res[85][0] = -v[0];
    res[85][1] = -v[2];
    res[85][2] = -v[1];
    phase[85] = (v[1]+v[2])*1./2;
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    phase[86] = (v[0]+v[2])*1./2;
    res[87][0] = -v[0];
    res[87][1] = -v[2];
    res[87][2] = -v[1];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    phase[88] =  0;
    res[89][0] = v[2];
    res[89][1] = -v[1];
    res[89][2] = v[0];
    phase[89] = (v[1]+v[2])*1./2;
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    phase[90] = (v[0]+v[2])*1./2;
    res[91][0] = v[2];
    res[91][1] = -v[1];
    res[91][2] = v[0];
    phase[91] = (v[0]+v[1])*1./2;
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    phase[92] =  0;
    res[93][0] = -v[2];
    res[93][1] = -v[1];
    res[93][2] = -v[0];
    phase[93] = (v[1]+v[2])*1./2;
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    phase[94] = (v[0]+v[2])*1./2;
    res[95][0] = -v[2];
    res[95][1] = -v[1];
    res[95][2] = -v[0];
    phase[95] = (v[0]+v[1])*1./2;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fd_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    res[10][0] = v[2];
    res[10][1] = v[0]+1./2;
    res[10][2] = v[1]+1./2;
    res[11][0] = -v[2];
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[1]+1./2;
    res[12][0] = v[2]+1./2;
    res[12][1] = v[0];
    res[12][2] = v[1]+1./2;
    res[13][0] = -v[2]+1./2;
    res[13][1] = -v[0];
    res[13][2] = -v[1]+1./2;
    res[14][0] = v[2]+1./2;
    res[14][1] = v[0]+1./2;
    res[14][2] = v[1];
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[1];
    res[16][0] = v[1];
    res[16][1] = v[2];
    res[16][2] = v[0];
    res[17][0] = -v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = v[1];
    res[18][1] = v[2]+1./2;
    res[18][2] = v[0]+1./2;
    res[19][0] = -v[1];
    res[19][1] = -v[2]+1./2;
    res[19][2] = -v[0]+1./2;
    res[20][0] = v[1]+1./2;
    res[20][1] = v[2];
    res[20][2] = v[0]+1./2;
    res[21][0] = -v[1]+1./2;
    res[21][1] = -v[2];
    res[21][2] = -v[0]+1./2;
    res[22][0] = v[1]+1./2;
    res[22][1] = v[2]+1./2;
    res[22][2] = v[0];
    res[23][0] = -v[1]+1./2;
    res[23][1] = -v[2]+1./2;
    res[23][2] = -v[0];
    res[24][0] = -v[1]+1./4;
    res[24][1] = -v[2]+1./4;
    res[24][2] = v[0];
    res[25][0] = v[1]+1./4;
    res[25][1] = v[2]+1./4;
    res[25][2] = -v[0];
    res[26][0] = -v[1]+1./4;
    res[26][1] = -v[2]+3./4;
    res[26][2] = v[0]+1./2;
    res[27][0] = v[1]+1./4;
    res[27][1] = v[2]+3./4;
    res[27][2] = -v[0]+1./2;
    res[28][0] = -v[1]+3./4;
    res[28][1] = -v[2]+1./4;
    res[28][2] = v[0]+1./2;
    res[29][0] = v[1]+3./4;
    res[29][1] = v[2]+1./4;
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[1]+3./4;
    res[30][1] = -v[2]+3./4;
    res[30][2] = v[0];
    res[31][0] = v[1]+3./4;
    res[31][1] = v[2]+3./4;
    res[31][2] = -v[0];
    res[32][0] = v[2];
    res[32][1] = -v[0]+1./4;
    res[32][2] = -v[1]+1./4;
    res[33][0] = -v[2];
    res[33][1] = v[0]+1./4;
    res[33][2] = v[1]+1./4;
    res[34][0] = v[2];
    res[34][1] = -v[0]+3./4;
    res[34][2] = -v[1]+3./4;
    res[35][0] = -v[2];
    res[35][1] = v[0]+3./4;
    res[35][2] = v[1]+3./4;
    res[36][0] = v[2]+1./2;
    res[36][1] = -v[0]+1./4;
    res[36][2] = -v[1]+3./4;
    res[37][0] = -v[2]+1./2;
    res[37][1] = v[0]+1./4;
    res[37][2] = v[1]+3./4;
    res[38][0] = v[2]+1./2;
    res[38][1] = -v[0]+3./4;
    res[38][2] = -v[1]+1./4;
    res[39][0] = -v[2]+1./2;
    res[39][1] = v[0]+3./4;
    res[39][2] = v[1]+1./4;
    res[40][0] = -v[1]+1./4;
    res[40][1] = v[2];
    res[40][2] = -v[0]+1./4;
    res[41][0] = v[1]+1./4;
    res[41][1] = -v[2];
    res[41][2] = v[0]+1./4;
    res[42][0] = -v[1]+1./4;
    res[42][1] = v[2]+1./2;
    res[42][2] = -v[0]+3./4;
    res[43][0] = v[1]+1./4;
    res[43][1] = -v[2]+1./2;
    res[43][2] = v[0]+3./4;
    res[44][0] = -v[1]+3./4;
    res[44][1] = v[2];
    res[44][2] = -v[0]+3./4;
    res[45][0] = v[1]+3./4;
    res[45][1] = -v[2];
    res[45][2] = v[0]+3./4;
    res[46][0] = -v[1]+3./4;
    res[46][1] = v[2]+1./2;
    res[46][2] = -v[0]+1./4;
    res[47][0] = v[1]+3./4;
    res[47][1] = -v[2]+1./2;
    res[47][2] = v[0]+1./4;
    res[48][0] = -v[2]+1./4;
    res[48][1] = -v[0]+1./4;
    res[48][2] = v[1];
    res[49][0] = v[2]+1./4;
    res[49][1] = v[0]+1./4;
    res[49][2] = -v[1];
    res[50][0] = -v[2]+1./4;
    res[50][1] = -v[0]+3./4;
    res[50][2] = v[1]+1./2;
    res[51][0] = v[2]+1./4;
    res[51][1] = v[0]+3./4;
    res[51][2] = -v[1]+1./2;
    res[52][0] = -v[2]+3./4;
    res[52][1] = -v[0]+1./4;
    res[52][2] = v[1]+1./2;
    res[53][0] = v[2]+3./4;
    res[53][1] = v[0]+1./4;
    res[53][2] = -v[1]+1./2;
    res[54][0] = -v[2]+3./4;
    res[54][1] = -v[0]+3./4;
    res[54][2] = v[1];
    res[55][0] = v[2]+3./4;
    res[55][1] = v[0]+3./4;
    res[55][2] = -v[1];
    res[56][0] = -v[2]+1./4;
    res[56][1] = v[0];
    res[56][2] = -v[1]+1./4;
    res[57][0] = v[2]+1./4;
    res[57][1] = -v[0];
    res[57][2] = v[1]+1./4;
    res[58][0] = -v[2]+1./4;
    res[58][1] = v[0]+1./2;
    res[58][2] = -v[1]+3./4;
    res[59][0] = v[2]+1./4;
    res[59][1] = -v[0]+1./2;
    res[59][2] = v[1]+3./4;
    res[60][0] = -v[2]+3./4;
    res[60][1] = v[0];
    res[60][2] = -v[1]+3./4;
    res[61][0] = v[2]+3./4;
    res[61][1] = -v[0];
    res[61][2] = v[1]+3./4;
    res[62][0] = -v[2]+3./4;
    res[62][1] = v[0]+1./2;
    res[62][2] = -v[1]+1./4;
    res[63][0] = v[2]+3./4;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1]+1./4;
    res[64][0] = v[1];
    res[64][1] = -v[2]+1./4;
    res[64][2] = -v[0]+1./4;
    res[65][0] = -v[1];
    res[65][1] = v[2]+1./4;
    res[65][2] = v[0]+1./4;
    res[66][0] = v[1];
    res[66][1] = -v[2]+3./4;
    res[66][2] = -v[0]+3./4;
    res[67][0] = -v[1];
    res[67][1] = v[2]+3./4;
    res[67][2] = v[0]+3./4;
    res[68][0] = v[1]+1./2;
    res[68][1] = -v[2]+1./4;
    res[68][2] = -v[0]+3./4;
    res[69][0] = -v[1]+1./2;
    res[69][1] = v[2]+1./4;
    res[69][2] = v[0]+3./4;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2]+3./4;
    res[70][2] = -v[0]+1./4;
    res[71][0] = -v[1]+1./2;
    res[71][1] = v[2]+3./4;
    res[71][2] = v[0]+1./4;
    res[72][0] = -v[0]+1./4;
    res[72][1] = -v[1]+1./4;
    res[72][2] = v[2];
    res[73][0] = v[0]+1./4;
    res[73][1] = v[1]+1./4;
    res[73][2] = -v[2];
    res[74][0] = -v[0]+1./4;
    res[74][1] = -v[1]+3./4;
    res[74][2] = v[2]+1./2;
    res[75][0] = v[0]+1./4;
    res[75][1] = v[1]+3./4;
    res[75][2] = -v[2]+1./2;
    res[76][0] = -v[0]+3./4;
    res[76][1] = -v[1]+1./4;
    res[76][2] = v[2]+1./2;
    res[77][0] = v[0]+3./4;
    res[77][1] = v[1]+1./4;
    res[77][2] = -v[2]+1./2;
    res[78][0] = -v[0]+3./4;
    res[78][1] = -v[1]+3./4;
    res[78][2] = v[2];
    res[79][0] = v[0]+3./4;
    res[79][1] = v[1]+3./4;
    res[79][2] = -v[2];
    res[80][0] = v[0];
    res[80][1] = -v[1]+1./4;
    res[80][2] = -v[2]+1./4;
    res[81][0] = -v[0];
    res[81][1] = v[1]+1./4;
    res[81][2] = v[2]+1./4;
    res[82][0] = v[0];
    res[82][1] = -v[1]+3./4;
    res[82][2] = -v[2]+3./4;
    res[83][0] = -v[0];
    res[83][1] = v[1]+3./4;
    res[83][2] = v[2]+3./4;
    res[84][0] = v[0]+1./2;
    res[84][1] = -v[1]+1./4;
    res[84][2] = -v[2]+3./4;
    res[85][0] = -v[0]+1./2;
    res[85][1] = v[1]+1./4;
    res[85][2] = v[2]+3./4;
    res[86][0] = v[0]+1./2;
    res[86][1] = -v[1]+3./4;
    res[86][2] = -v[2]+1./4;
    res[87][0] = -v[0]+1./2;
    res[87][1] = v[1]+3./4;
    res[87][2] = v[2]+1./4;
    res[88][0] = -v[0]+1./4;
    res[88][1] = v[1];
    res[88][2] = -v[2]+1./4;
    res[89][0] = v[0]+1./4;
    res[89][1] = -v[1];
    res[89][2] = v[2]+1./4;
    res[90][0] = -v[0]+1./4;
    res[90][1] = v[1]+1./2;
    res[90][2] = -v[2]+3./4;
    res[91][0] = v[0]+1./4;
    res[91][1] = -v[1]+1./2;
    res[91][2] = v[2]+3./4;
    res[92][0] = -v[0]+3./4;
    res[92][1] = v[1];
    res[92][2] = -v[2]+3./4;
    res[93][0] = v[0]+3./4;
    res[93][1] = -v[1];
    res[93][2] = v[2]+3./4;
    res[94][0] = -v[0]+3./4;
    res[94][1] = v[1]+1./2;
    res[94][2] = -v[2]+1./4;
    res[95][0] = v[0]+3./4;
    res[95][1] = -v[1]+1./2;
    res[95][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = -v[1];
    res[11][1] = -v[2];
    res[11][2] = -v[0];
    res[12][0] = v[1];
    res[12][1] = v[2];
    res[12][2] = v[0];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = -v[0];
    res[14][0] = v[1];
    res[14][1] = v[2];
    res[14][2] = v[0];
    res[15][0] = -v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    res[16][0] = v[2];
    res[16][1] = v[0];
    res[16][2] = v[1];
    res[17][0] = -v[2];
    res[17][1] = -v[0];
    res[17][2] = -v[1];
    res[18][0] = v[2];
    res[18][1] = v[0];
    res[18][2] = v[1];
    res[19][0] = -v[2];
    res[19][1] = -v[0];
    res[19][2] = -v[1];
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    res[28][0] = v[2];
    res[28][1] = -v[0];
    res[28][2] = -v[1];
    res[29][0] = -v[2];
    res[29][1] = v[0];
    res[29][2] = v[1];
    res[30][0] = v[2];
    res[30][1] = -v[0];
    res[30][2] = -v[1];
    res[31][0] = -v[2];
    res[31][1] = v[0];
    res[31][2] = v[1];
    res[32][0] = -v[1];
    res[32][1] = -v[2];
    res[32][2] = v[0];
    res[33][0] = v[1];
    res[33][1] = v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[1];
    res[34][1] = -v[2];
    res[34][2] = v[0];
    res[35][0] = v[1];
    res[35][1] = v[2];
    res[35][2] = -v[0];
    res[36][0] = -v[1];
    res[36][1] = -v[2];
    res[36][2] = v[0];
    res[37][0] = v[1];
    res[37][1] = v[2];
    res[37][2] = -v[0];
    res[38][0] = -v[1];
    res[38][1] = -v[2];
    res[38][2] = v[0];
    res[39][0] = v[1];
    res[39][1] = v[2];
    res[39][2] = -v[0];
    res[40][0] = -v[2];
    res[40][1] = -v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0];
    res[41][2] = -v[1];
    res[42][0] = -v[2];
    res[42][1] = -v[0];
    res[42][2] = v[1];
    res[43][0] = v[2];
    res[43][1] = v[0];
    res[43][2] = -v[1];
    res[44][0] = -v[2];
    res[44][1] = -v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = -v[1];
    res[46][0] = -v[2];
    res[46][1] = -v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = -v[1];
    res[48][0] = -v[1];
    res[48][1] = v[2];
    res[48][2] = -v[0];
    res[49][0] = v[1];
    res[49][1] = -v[2];
    res[49][2] = v[0];
    res[50][0] = -v[1];
    res[50][1] = v[2];
    res[50][2] = -v[0];
    res[51][0] = v[1];
    res[51][1] = -v[2];
    res[51][2] = v[0];
    res[52][0] = -v[1];
    res[52][1] = v[2];
    res[52][2] = -v[0];
    res[53][0] = v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = v[2];
    res[54][2] = -v[0];
    res[55][0] = v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = v[1];
    res[56][1] = -v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2];
    res[57][2] = v[0];
    res[58][0] = v[1];
    res[58][1] = -v[2];
    res[58][2] = -v[0];
    res[59][0] = -v[1];
    res[59][1] = v[2];
    res[59][2] = v[0];
    res[60][0] = v[1];
    res[60][1] = -v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = v[0];
    res[62][0] = v[1];
    res[62][1] = -v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = v[0];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = v[2];
    res[65][1] = -v[0];
    res[65][2] = v[1];
    res[66][0] = -v[2];
    res[66][1] = v[0];
    res[66][2] = -v[1];
    res[67][0] = v[2];
    res[67][1] = -v[0];
    res[67][2] = v[1];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    res[72][0] = -v[0];
    res[72][1] = -v[1];
    res[72][2] = v[2];
    res[73][0] = v[0];
    res[73][1] = v[1];
    res[73][2] = -v[2];
    res[74][0] = -v[0];
    res[74][1] = -v[1];
    res[74][2] = v[2];
    res[75][0] = v[0];
    res[75][1] = v[1];
    res[75][2] = -v[2];
    res[76][0] = -v[0];
    res[76][1] = -v[1];
    res[76][2] = v[2];
    res[77][0] = v[0];
    res[77][1] = v[1];
    res[77][2] = -v[2];
    res[78][0] = -v[0];
    res[78][1] = -v[1];
    res[78][2] = v[2];
    res[79][0] = v[0];
    res[79][1] = v[1];
    res[79][2] = -v[2];
    res[80][0] = v[0];
    res[80][1] = -v[1];
    res[80][2] = -v[2];
    res[81][0] = -v[0];
    res[81][1] = v[1];
    res[81][2] = v[2];
    res[82][0] = v[0];
    res[82][1] = -v[1];
    res[82][2] = -v[2];
    res[83][0] = -v[0];
    res[83][1] = v[1];
    res[83][2] = v[2];
    res[84][0] = v[0];
    res[84][1] = -v[1];
    res[84][2] = -v[2];
    res[85][0] = -v[0];
    res[85][1] = v[1];
    res[85][2] = v[2];
    res[86][0] = v[0];
    res[86][1] = -v[1];
    res[86][2] = -v[2];
    res[87][0] = -v[0];
    res[87][1] = v[1];
    res[87][2] = v[2];
    res[88][0] = -v[0];
    res[88][1] = v[1];
    res[88][2] = -v[2];
    res[89][0] = v[0];
    res[89][1] = -v[1];
    res[89][2] = v[2];
    res[90][0] = -v[0];
    res[90][1] = v[1];
    res[90][2] = -v[2];
    res[91][0] = v[0];
    res[91][1] = -v[1];
    res[91][2] = v[2];
    res[92][0] = -v[0];
    res[92][1] = v[1];
    res[92][2] = -v[2];
    res[93][0] = v[0];
    res[93][1] = -v[1];
    res[93][2] = v[2];
    res[94][0] = -v[0];
    res[94][1] = v[1];
    res[94][2] = -v[2];
    res[95][0] = v[0];
    res[95][1] = -v[1];
    res[95][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[2];
    res[11][2] = -v[0];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[2];
    res[12][2] = v[0];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = -v[0];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = v[2];
    res[14][2] = v[0];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = -v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = v[2];
    res[16][1] = v[0];
    res[16][2] = v[1];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = -v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = v[2];
    res[18][1] = v[0];
    res[18][2] = v[1];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = -v[2];
    res[19][1] = -v[0];
    res[19][2] = -v[1];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    phase[20] = (v[0]+v[2])*1./2;
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    phase[21] = (v[0]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] = (v[0]+v[1])*1./4;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] = (v[0]+v[1])*1./4;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    phase[26] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    phase[27] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[28][0] = v[2];
    res[28][1] = -v[0];
    res[28][2] = -v[1];
    phase[28] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[29][0] = -v[2];
    res[29][1] = v[0];
    res[29][2] = v[1];
    phase[29] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[30][0] = v[2];
    res[30][1] = -v[0];
    res[30][2] = -v[1];
    phase[30] = (v[0]+v[1])*3./4;
    res[31][0] = -v[2];
    res[31][1] = v[0];
    res[31][2] = v[1];
    phase[31] = (v[0]+v[1])*3./4;
    res[32][0] = -v[1];
    res[32][1] = -v[2];
    res[32][2] = v[0];
    phase[32] = (v[1]+v[2])*1./4;
    res[33][0] = v[1];
    res[33][1] = v[2];
    res[33][2] = -v[0];
    phase[33] = (v[1]+v[2])*1./4;
    res[34][0] = -v[1];
    res[34][1] = -v[2];
    res[34][2] = v[0];
    phase[34] = (v[1]+v[2])*3./4;
    res[35][0] = v[1];
    res[35][1] = v[2];
    res[35][2] = -v[0];
    phase[35] = (v[1]+v[2])*3./4;
    res[36][0] = -v[1];
    res[36][1] = -v[2];
    res[36][2] = v[0];
    phase[36] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[37][0] = v[1];
    res[37][1] = v[2];
    res[37][2] = -v[0];
    phase[37] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[38][0] = -v[1];
    res[38][1] = -v[2];
    res[38][2] = v[0];
    phase[38] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[39][0] = v[1];
    res[39][1] = v[2];
    res[39][2] = -v[0];
    phase[39] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[40][0] = -v[2];
    res[40][1] = -v[0];
    res[40][2] = v[1];
    phase[40] = (v[0]+v[2])*1./4;
    res[41][0] = v[2];
    res[41][1] = v[0];
    res[41][2] = -v[1];
    phase[41] = (v[0]+v[2])*1./4;
    res[42][0] = -v[2];
    res[42][1] = -v[0];
    res[42][2] = v[1];
    phase[42] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[43][0] = v[2];
    res[43][1] = v[0];
    res[43][2] = -v[1];
    phase[43] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[44][0] = -v[2];
    res[44][1] = -v[0];
    res[44][2] = v[1];
    phase[44] = (v[0]+v[2])*3./4;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = -v[1];
    phase[45] = (v[0]+v[2])*3./4;
    res[46][0] = -v[2];
    res[46][1] = -v[0];
    res[46][2] = v[1];
    phase[46] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = -v[1];
    phase[47] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[48][0] = -v[1];
    res[48][1] = v[2];
    res[48][2] = -v[0];
    phase[48] = (v[0]+v[1])*1./4;
    res[49][0] = v[1];
    res[49][1] = -v[2];
    res[49][2] = v[0];
    phase[49] = (v[0]+v[1])*1./4;
    res[50][0] = -v[1];
    res[50][1] = v[2];
    res[50][2] = -v[0];
    phase[50] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[51][0] = v[1];
    res[51][1] = -v[2];
    res[51][2] = v[0];
    phase[51] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[52][0] = -v[1];
    res[52][1] = v[2];
    res[52][2] = -v[0];
    phase[52] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[53][0] = v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[54][0] = -v[1];
    res[54][1] = v[2];
    res[54][2] = -v[0];
    phase[54] = (v[0]+v[1])*3./4;
    res[55][0] = v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*3./4;
    res[56][0] = v[1];
    res[56][1] = -v[2];
    res[56][2] = -v[0];
    phase[56] = (v[0]+v[2])*1./4;
    res[57][0] = -v[1];
    res[57][1] = v[2];
    res[57][2] = v[0];
    phase[57] = (v[0]+v[2])*1./4;
    res[58][0] = v[1];
    res[58][1] = -v[2];
    res[58][2] = -v[0];
    phase[58] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[59][0] = -v[1];
    res[59][1] = v[2];
    res[59][2] = v[0];
    phase[59] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[60][0] = v[1];
    res[60][1] = -v[2];
    res[60][2] = -v[0];
    phase[60] = (v[0]+v[2])*3./4;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = v[0];
    phase[61] = (v[0]+v[2])*3./4;
    res[62][0] = v[1];
    res[62][1] = -v[2];
    res[62][2] = -v[0];
    phase[62] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = v[0];
    phase[63] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    phase[64] = (v[1]+v[2])*1./4;
    res[65][0] = v[2];
    res[65][1] = -v[0];
    res[65][2] = v[1];
    phase[65] = (v[1]+v[2])*1./4;
    res[66][0] = -v[2];
    res[66][1] = v[0];
    res[66][2] = -v[1];
    phase[66] = (v[1]+v[2])*3./4;
    res[67][0] = v[2];
    res[67][1] = -v[0];
    res[67][2] = v[1];
    phase[67] = (v[1]+v[2])*3./4;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    phase[69] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    phase[71] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[72][0] = -v[0];
    res[72][1] = -v[1];
    res[72][2] = v[2];
    phase[72] = (v[0]+v[1])*1./4;
    res[73][0] = v[0];
    res[73][1] = v[1];
    res[73][2] = -v[2];
    phase[73] = (v[0]+v[1])*1./4;
    res[74][0] = -v[0];
    res[74][1] = -v[1];
    res[74][2] = v[2];
    phase[74] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[75][0] = v[0];
    res[75][1] = v[1];
    res[75][2] = -v[2];
    phase[75] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[76][0] = -v[0];
    res[76][1] = -v[1];
    res[76][2] = v[2];
    phase[76] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[77][0] = v[0];
    res[77][1] = v[1];
    res[77][2] = -v[2];
    phase[77] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[78][0] = -v[0];
    res[78][1] = -v[1];
    res[78][2] = v[2];
    phase[78] = (v[0]+v[1])*3./4;
    res[79][0] = v[0];
    res[79][1] = v[1];
    res[79][2] = -v[2];
    phase[79] = (v[0]+v[1])*3./4;
    res[80][0] = v[0];
    res[80][1] = -v[1];
    res[80][2] = -v[2];
    phase[80] = (v[1]+v[2])*1./4;
    res[81][0] = -v[0];
    res[81][1] = v[1];
    res[81][2] = v[2];
    phase[81] = (v[1]+v[2])*1./4;
    res[82][0] = v[0];
    res[82][1] = -v[1];
    res[82][2] = -v[2];
    phase[82] = (v[1]+v[2])*3./4;
    res[83][0] = -v[0];
    res[83][1] = v[1];
    res[83][2] = v[2];
    phase[83] = (v[1]+v[2])*3./4;
    res[84][0] = v[0];
    res[84][1] = -v[1];
    res[84][2] = -v[2];
    phase[84] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[85][0] = -v[0];
    res[85][1] = v[1];
    res[85][2] = v[2];
    phase[85] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[86][0] = v[0];
    res[86][1] = -v[1];
    res[86][2] = -v[2];
    phase[86] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[87][0] = -v[0];
    res[87][1] = v[1];
    res[87][2] = v[2];
    phase[87] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[88][0] = -v[0];
    res[88][1] = v[1];
    res[88][2] = -v[2];
    phase[88] = (v[0]+v[2])*1./4;
    res[89][0] = v[0];
    res[89][1] = -v[1];
    res[89][2] = v[2];
    phase[89] = (v[0]+v[2])*1./4;
    res[90][0] = -v[0];
    res[90][1] = v[1];
    res[90][2] = -v[2];
    phase[90] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[91][0] = v[0];
    res[91][1] = -v[1];
    res[91][2] = v[2];
    phase[91] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[92][0] = -v[0];
    res[92][1] = v[1];
    res[92][2] = -v[2];
    phase[92] = (v[0]+v[2])*3./4;
    res[93][0] = v[0];
    res[93][1] = -v[1];
    res[93][2] = v[2];
    phase[93] = (v[0]+v[2])*3./4;
    res[94][0] = -v[0];
    res[94][1] = v[1];
    res[94][2] = -v[2];
    phase[94] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[95][0] = v[0];
    res[95][1] = -v[1];
    res[95][2] = v[2];
    phase[95] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fd_3c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[1];
    res[8][1] = v[0]+1./4;
    res[8][2] = v[2]+3./4;
    res[9][0] = v[1];
    res[9][1] = -v[0]+1./4;
    res[9][2] = -v[2]+3./4;
    res[10][0] = -v[1];
    res[10][1] = v[0]+3./4;
    res[10][2] = v[2]+1./4;
    res[11][0] = v[1];
    res[11][1] = -v[0]+3./4;
    res[11][2] = -v[2]+1./4;
    res[12][0] = -v[1]+1./2;
    res[12][1] = v[0]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = v[1]+1./2;
    res[13][1] = -v[0]+1./4;
    res[13][2] = -v[2]+1./4;
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0]+3./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = v[1]+1./2;
    res[15][1] = -v[0]+3./4;
    res[15][2] = -v[2]+3./4;
    res[16][0] = -v[0]+1./4;
    res[16][1] = -v[1]+1./4;
    res[16][2] = v[2];
    res[17][0] = v[0]+1./4;
    res[17][1] = v[1]+1./4;
    res[17][2] = -v[2];
    res[18][0] = -v[0]+1./4;
    res[18][1] = -v[1]+3./4;
    res[18][2] = v[2]+1./2;
    res[19][0] = v[0]+1./4;
    res[19][1] = v[1]+3./4;
    res[19][2] = -v[2]+1./2;
    res[20][0] = -v[0]+3./4;
    res[20][1] = -v[1]+1./4;
    res[20][2] = v[2]+1./2;
    res[21][0] = v[0]+3./4;
    res[21][1] = v[1]+1./4;
    res[21][2] = -v[2]+1./2;
    res[22][0] = -v[0]+3./4;
    res[22][1] = -v[1]+3./4;
    res[22][2] = v[2];
    res[23][0] = v[0]+3./4;
    res[23][1] = v[1]+3./4;
    res[23][2] = -v[2];
    res[24][0] = v[1]+1./4;
    res[24][1] = -v[0];
    res[24][2] = v[2]+3./4;
    res[25][0] = -v[1]+1./4;
    res[25][1] = v[0];
    res[25][2] = -v[2]+3./4;
    res[26][0] = v[1]+1./4;
    res[26][1] = -v[0]+1./2;
    res[26][2] = v[2]+1./4;
    res[27][0] = -v[1]+1./4;
    res[27][1] = v[0]+1./2;
    res[27][2] = -v[2]+1./4;
    res[28][0] = v[1]+3./4;
    res[28][1] = -v[0];
    res[28][2] = v[2]+1./4;
    res[29][0] = -v[1]+3./4;
    res[29][1] = v[0];
    res[29][2] = -v[2]+1./4;
    res[30][0] = v[1]+3./4;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[2]+3./4;
    res[31][0] = -v[1]+3./4;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[2]+3./4;
    res[32][0] = v[0]+1./4;
    res[32][1] = -v[2];
    res[32][2] = v[1]+3./4;
    res[33][0] = -v[0]+1./4;
    res[33][1] = v[2];
    res[33][2] = -v[1]+3./4;
    res[34][0] = v[0]+1./4;
    res[34][1] = -v[2]+1./2;
    res[34][2] = v[1]+1./4;
    res[35][0] = -v[0]+1./4;
    res[35][1] = v[2]+1./2;
    res[35][2] = -v[1]+1./4;
    res[36][0] = v[0]+3./4;
    res[36][1] = -v[2];
    res[36][2] = v[1]+1./4;
    res[37][0] = -v[0]+3./4;
    res[37][1] = v[2];
    res[37][2] = -v[1]+1./4;
    res[38][0] = v[0]+3./4;
    res[38][1] = -v[2]+1./2;
    res[38][2] = v[1]+3./4;
    res[39][0] = -v[0]+3./4;
    res[39][1] = v[2]+1./2;
    res[39][2] = -v[1]+3./4;
    res[40][0] = v[0];
    res[40][1] = -v[1]+1./4;
    res[40][2] = -v[2]+1./4;
    res[41][0] = -v[0];
    res[41][1] = v[1]+1./4;
    res[41][2] = v[2]+1./4;
    res[42][0] = v[0];
    res[42][1] = -v[1]+3./4;
    res[42][2] = -v[2]+3./4;
    res[43][0] = -v[0];
    res[43][1] = v[1]+3./4;
    res[43][2] = v[2]+3./4;
    res[44][0] = v[0]+1./2;
    res[44][1] = -v[1]+1./4;
    res[44][2] = -v[2]+3./4;
    res[45][0] = -v[0]+1./2;
    res[45][1] = v[1]+1./4;
    res[45][2] = v[2]+3./4;
    res[46][0] = v[0]+1./2;
    res[46][1] = -v[1]+3./4;
    res[46][2] = -v[2]+1./4;
    res[47][0] = -v[0]+1./2;
    res[47][1] = v[1]+3./4;
    res[47][2] = v[2]+1./4;
    res[48][0] = v[0]+1./4;
    res[48][1] = v[2]+3./4;
    res[48][2] = -v[1];
    res[49][0] = -v[0]+1./4;
    res[49][1] = -v[2]+3./4;
    res[49][2] = v[1];
    res[50][0] = v[0]+1./4;
    res[50][1] = v[2]+1./4;
    res[50][2] = -v[1]+1./2;
    res[51][0] = -v[0]+1./4;
    res[51][1] = -v[2]+1./4;
    res[51][2] = v[1]+1./2;
    res[52][0] = v[0]+3./4;
    res[52][1] = v[2]+3./4;
    res[52][2] = -v[1]+1./2;
    res[53][0] = -v[0]+3./4;
    res[53][1] = -v[2]+3./4;
    res[53][2] = v[1]+1./2;
    res[54][0] = v[0]+3./4;
    res[54][1] = v[2]+1./4;
    res[54][2] = -v[1];
    res[55][0] = -v[0]+3./4;
    res[55][1] = -v[2]+1./4;
    res[55][2] = v[1];
    res[56][0] = v[2]+1./4;
    res[56][1] = v[1]+3./4;
    res[56][2] = -v[0];
    res[57][0] = -v[2]+1./4;
    res[57][1] = -v[1]+3./4;
    res[57][2] = v[0];
    res[58][0] = v[2]+1./4;
    res[58][1] = v[1]+1./4;
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[2]+1./4;
    res[59][1] = -v[1]+1./4;
    res[59][2] = v[0]+1./2;
    res[60][0] = v[2]+3./4;
    res[60][1] = v[1]+3./4;
    res[60][2] = -v[0]+1./2;
    res[61][0] = -v[2]+3./4;
    res[61][1] = -v[1]+3./4;
    res[61][2] = v[0]+1./2;
    res[62][0] = v[2]+3./4;
    res[62][1] = v[1]+1./4;
    res[62][2] = -v[0];
    res[63][0] = -v[2]+3./4;
    res[63][1] = -v[1]+1./4;
    res[63][2] = v[0];
    res[64][0] = -v[0]+1./4;
    res[64][1] = v[1];
    res[64][2] = -v[2]+1./4;
    res[65][0] = v[0]+1./4;
    res[65][1] = -v[1];
    res[65][2] = v[2]+1./4;
    res[66][0] = -v[0]+1./4;
    res[66][1] = v[1]+1./2;
    res[66][2] = -v[2]+3./4;
    res[67][0] = v[0]+1./4;
    res[67][1] = -v[1]+1./2;
    res[67][2] = v[2]+3./4;
    res[68][0] = -v[0]+3./4;
    res[68][1] = v[1];
    res[68][2] = -v[2]+3./4;
    res[69][0] = v[0]+3./4;
    res[69][1] = -v[1];
    res[69][2] = v[2]+3./4;
    res[70][0] = -v[0]+3./4;
    res[70][1] = v[1]+1./2;
    res[70][2] = -v[2]+1./4;
    res[71][0] = v[0]+3./4;
    res[71][1] = -v[1]+1./2;
    res[71][2] = v[2]+1./4;
    res[72][0] = -v[2];
    res[72][1] = v[1]+1./4;
    res[72][2] = v[0]+3./4;
    res[73][0] = v[2];
    res[73][1] = -v[1]+1./4;
    res[73][2] = -v[0]+3./4;
    res[74][0] = -v[2];
    res[74][1] = v[1]+3./4;
    res[74][2] = v[0]+1./4;
    res[75][0] = v[2];
    res[75][1] = -v[1]+3./4;
    res[75][2] = -v[0]+1./4;
    res[76][0] = -v[2]+1./2;
    res[76][1] = v[1]+1./4;
    res[76][2] = v[0]+1./4;
    res[77][0] = v[2]+1./2;
    res[77][1] = -v[1]+1./4;
    res[77][2] = -v[0]+1./4;
    res[78][0] = -v[2]+1./2;
    res[78][1] = v[1]+3./4;
    res[78][2] = v[0]+3./4;
    res[79][0] = v[2]+1./2;
    res[79][1] = -v[1]+3./4;
    res[79][2] = -v[0]+3./4;
    res[80][0] = v[2];
    res[80][1] = v[0];
    res[80][2] = v[1];
    res[81][0] = -v[2];
    res[81][1] = -v[0];
    res[81][2] = -v[1];
    res[82][0] = v[2];
    res[82][1] = v[0]+1./2;
    res[82][2] = v[1]+1./2;
    res[83][0] = -v[2];
    res[83][1] = -v[0]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = v[2]+1./2;
    res[84][1] = v[0];
    res[84][2] = v[1]+1./2;
    res[85][0] = -v[2]+1./2;
    res[85][1] = -v[0];
    res[85][2] = -v[1]+1./2;
    res[86][0] = v[2]+1./2;
    res[86][1] = v[0]+1./2;
    res[86][2] = v[1];
    res[87][0] = -v[2]+1./2;
    res[87][1] = -v[0]+1./2;
    res[87][2] = -v[1];
    res[88][0] = v[1];
    res[88][1] = v[2];
    res[88][2] = v[0];
    res[89][0] = -v[1];
    res[89][1] = -v[2];
    res[89][2] = -v[0];
    res[90][0] = v[1];
    res[90][1] = v[2]+1./2;
    res[90][2] = v[0]+1./2;
    res[91][0] = -v[1];
    res[91][1] = -v[2]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = v[1]+1./2;
    res[92][1] = v[2];
    res[92][2] = v[0]+1./2;
    res[93][0] = -v[1]+1./2;
    res[93][1] = -v[2];
    res[93][2] = -v[0]+1./2;
    res[94][0] = v[1]+1./2;
    res[94][1] = v[2]+1./2;
    res[94][2] = v[0];
    res[95][0] = -v[1]+1./2;
    res[95][1] = -v[2]+1./2;
    res[95][2] = -v[0];
    res[96][0] = -v[1]+1./4;
    res[96][1] = -v[2]+1./4;
    res[96][2] = v[0];
    res[97][0] = v[1]+1./4;
    res[97][1] = v[2]+1./4;
    res[97][2] = -v[0];
    res[98][0] = -v[1]+1./4;
    res[98][1] = -v[2]+3./4;
    res[98][2] = v[0]+1./2;
    res[99][0] = v[1]+1./4;
    res[99][1] = v[2]+3./4;
    res[99][2] = -v[0]+1./2;
    res[100][0] = -v[1]+3./4;
    res[100][1] = -v[2]+1./4;
    res[100][2] = v[0]+1./2;
    res[101][0] = v[1]+3./4;
    res[101][1] = v[2]+1./4;
    res[101][2] = -v[0]+1./2;
    res[102][0] = -v[1]+3./4;
    res[102][1] = -v[2]+3./4;
    res[102][2] = v[0];
    res[103][0] = v[1]+3./4;
    res[103][1] = v[2]+3./4;
    res[103][2] = -v[0];
    res[104][0] = v[2];
    res[104][1] = -v[0]+1./4;
    res[104][2] = -v[1]+1./4;
    res[105][0] = -v[2];
    res[105][1] = v[0]+1./4;
    res[105][2] = v[1]+1./4;
    res[106][0] = v[2];
    res[106][1] = -v[0]+3./4;
    res[106][2] = -v[1]+3./4;
    res[107][0] = -v[2];
    res[107][1] = v[0]+3./4;
    res[107][2] = v[1]+3./4;
    res[108][0] = v[2]+1./2;
    res[108][1] = -v[0]+1./4;
    res[108][2] = -v[1]+3./4;
    res[109][0] = -v[2]+1./2;
    res[109][1] = v[0]+1./4;
    res[109][2] = v[1]+3./4;
    res[110][0] = v[2]+1./2;
    res[110][1] = -v[0]+3./4;
    res[110][2] = -v[1]+1./4;
    res[111][0] = -v[2]+1./2;
    res[111][1] = v[0]+3./4;
    res[111][2] = v[1]+1./4;
    res[112][0] = -v[1]+1./4;
    res[112][1] = v[2];
    res[112][2] = -v[0]+1./4;
    res[113][0] = v[1]+1./4;
    res[113][1] = -v[2];
    res[113][2] = v[0]+1./4;
    res[114][0] = -v[1]+1./4;
    res[114][1] = v[2]+1./2;
    res[114][2] = -v[0]+3./4;
    res[115][0] = v[1]+1./4;
    res[115][1] = -v[2]+1./2;
    res[115][2] = v[0]+3./4;
    res[116][0] = -v[1]+3./4;
    res[116][1] = v[2];
    res[116][2] = -v[0]+3./4;
    res[117][0] = v[1]+3./4;
    res[117][1] = -v[2];
    res[117][2] = v[0]+3./4;
    res[118][0] = -v[1]+3./4;
    res[118][1] = v[2]+1./2;
    res[118][2] = -v[0]+1./4;
    res[119][0] = v[1]+3./4;
    res[119][1] = -v[2]+1./2;
    res[119][2] = v[0]+1./4;
    res[120][0] = -v[2]+1./4;
    res[120][1] = -v[0]+1./4;
    res[120][2] = v[1];
    res[121][0] = v[2]+1./4;
    res[121][1] = v[0]+1./4;
    res[121][2] = -v[1];
    res[122][0] = -v[2]+1./4;
    res[122][1] = -v[0]+3./4;
    res[122][2] = v[1]+1./2;
    res[123][0] = v[2]+1./4;
    res[123][1] = v[0]+3./4;
    res[123][2] = -v[1]+1./2;
    res[124][0] = -v[2]+3./4;
    res[124][1] = -v[0]+1./4;
    res[124][2] = v[1]+1./2;
    res[125][0] = v[2]+3./4;
    res[125][1] = v[0]+1./4;
    res[125][2] = -v[1]+1./2;
    res[126][0] = -v[2]+3./4;
    res[126][1] = -v[0]+3./4;
    res[126][2] = v[1];
    res[127][0] = v[2]+3./4;
    res[127][1] = v[0]+3./4;
    res[127][2] = -v[1];
    res[128][0] = -v[2]+1./4;
    res[128][1] = v[0];
    res[128][2] = -v[1]+1./4;
    res[129][0] = v[2]+1./4;
    res[129][1] = -v[0];
    res[129][2] = v[1]+1./4;
    res[130][0] = -v[2]+1./4;
    res[130][1] = v[0]+1./2;
    res[130][2] = -v[1]+3./4;
    res[131][0] = v[2]+1./4;
    res[131][1] = -v[0]+1./2;
    res[131][2] = v[1]+3./4;
    res[132][0] = -v[2]+3./4;
    res[132][1] = v[0];
    res[132][2] = -v[1]+3./4;
    res[133][0] = v[2]+3./4;
    res[133][1] = -v[0];
    res[133][2] = v[1]+3./4;
    res[134][0] = -v[2]+3./4;
    res[134][1] = v[0]+1./2;
    res[134][2] = -v[1]+1./4;
    res[135][0] = v[2]+3./4;
    res[135][1] = -v[0]+1./2;
    res[135][2] = v[1]+1./4;
    res[136][0] = v[1];
    res[136][1] = -v[2]+1./4;
    res[136][2] = -v[0]+1./4;
    res[137][0] = -v[1];
    res[137][1] = v[2]+1./4;
    res[137][2] = v[0]+1./4;
    res[138][0] = v[1];
    res[138][1] = -v[2]+3./4;
    res[138][2] = -v[0]+3./4;
    res[139][0] = -v[1];
    res[139][1] = v[2]+3./4;
    res[139][2] = v[0]+3./4;
    res[140][0] = v[1]+1./2;
    res[140][1] = -v[2]+1./4;
    res[140][2] = -v[0]+3./4;
    res[141][0] = -v[1]+1./2;
    res[141][1] = v[2]+1./4;
    res[141][2] = v[0]+3./4;
    res[142][0] = v[1]+1./2;
    res[142][1] = -v[2]+3./4;
    res[142][2] = -v[0]+1./4;
    res[143][0] = -v[1]+1./2;
    res[143][1] = v[2]+3./4;
    res[143][2] = v[0]+1./4;
    res[144][0] = v[1]+1./4;
    res[144][1] = v[0]+3./4;
    res[144][2] = -v[2];
    res[145][0] = -v[1]+1./4;
    res[145][1] = -v[0]+3./4;
    res[145][2] = v[2];
    res[146][0] = v[1]+1./4;
    res[146][1] = v[0]+1./4;
    res[146][2] = -v[2]+1./2;
    res[147][0] = -v[1]+1./4;
    res[147][1] = -v[0]+1./4;
    res[147][2] = v[2]+1./2;
    res[148][0] = v[1]+3./4;
    res[148][1] = v[0]+3./4;
    res[148][2] = -v[2]+1./2;
    res[149][0] = -v[1]+3./4;
    res[149][1] = -v[0]+3./4;
    res[149][2] = v[2]+1./2;
    res[150][0] = v[1]+3./4;
    res[150][1] = v[0]+1./4;
    res[150][2] = -v[2];
    res[151][0] = -v[1]+3./4;
    res[151][1] = -v[0]+1./4;
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2]+1./2;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2]+1./2;
    res[154][0] = -v[1];
    res[154][1] = -v[0]+1./2;
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0]+1./2;
    res[155][2] = v[2];
    res[156][0] = -v[1]+1./2;
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1]+1./2;
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1]+1./2;
    res[158][1] = -v[0]+1./2;
    res[158][2] = -v[2]+1./2;
    res[159][0] = v[1]+1./2;
    res[159][1] = v[0]+1./2;
    res[159][2] = v[2]+1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2]+1./4;
    res[160][2] = v[1]+3./4;
    res[161][0] = v[0];
    res[161][1] = -v[2]+1./4;
    res[161][2] = -v[1]+3./4;
    res[162][0] = -v[0];
    res[162][1] = v[2]+3./4;
    res[162][2] = v[1]+1./4;
    res[163][0] = v[0];
    res[163][1] = -v[2]+3./4;
    res[163][2] = -v[1]+1./4;
    res[164][0] = -v[0]+1./2;
    res[164][1] = v[2]+1./4;
    res[164][2] = v[1]+1./4;
    res[165][0] = v[0]+1./2;
    res[165][1] = -v[2]+1./4;
    res[165][2] = -v[1]+1./4;
    res[166][0] = -v[0]+1./2;
    res[166][1] = v[2]+3./4;
    res[166][2] = v[1]+3./4;
    res[167][0] = v[0]+1./2;
    res[167][1] = -v[2]+3./4;
    res[167][2] = -v[1]+3./4;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1]+1./2;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1]+1./2;
    res[170][0] = -v[0];
    res[170][1] = -v[2]+1./2;
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2]+1./2;
    res[171][2] = v[1];
    res[172][0] = -v[0]+1./2;
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0]+1./2;
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0]+1./2;
    res[174][1] = -v[2]+1./2;
    res[174][2] = -v[1]+1./2;
    res[175][0] = v[0]+1./2;
    res[175][1] = v[2]+1./2;
    res[175][2] = v[1]+1./2;
    res[176][0] = v[2]+1./4;
    res[176][1] = -v[1];
    res[176][2] = v[0]+3./4;
    res[177][0] = -v[2]+1./4;
    res[177][1] = v[1];
    res[177][2] = -v[0]+3./4;
    res[178][0] = v[2]+1./4;
    res[178][1] = -v[1]+1./2;
    res[178][2] = v[0]+1./4;
    res[179][0] = -v[2]+1./4;
    res[179][1] = v[1]+1./2;
    res[179][2] = -v[0]+1./4;
    res[180][0] = v[2]+3./4;
    res[180][1] = -v[1];
    res[180][2] = v[0]+1./4;
    res[181][0] = -v[2]+3./4;
    res[181][1] = v[1];
    res[181][2] = -v[0]+1./4;
    res[182][0] = v[2]+3./4;
    res[182][1] = -v[1]+1./2;
    res[182][2] = v[0]+3./4;
    res[183][0] = -v[2]+3./4;
    res[183][1] = v[1]+1./2;
    res[183][2] = -v[0]+3./4;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0]+1./2;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0]+1./2;
    res[186][0] = -v[2];
    res[186][1] = -v[1]+1./2;
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1]+1./2;
    res[187][2] = v[0];
    res[188][0] = -v[2]+1./2;
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2]+1./2;
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2]+1./2;
    res[190][1] = -v[1]+1./2;
    res[190][2] = -v[0]+1./2;
    res[191][0] = v[2]+1./2;
    res[191][1] = v[1]+1./2;
    res[191][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] = v[1]*1./4+v[2]*3./4;
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] = v[1]*1./4+v[2]*3./4;
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    phase[10] = v[1]*3./4+v[2]*1./4;
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    phase[11] = v[1]*3./4+v[2]*1./4;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    phase[15] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    phase[16] = (v[0]+v[1])*1./4;
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[0]+v[1])*1./4;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    phase[20] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    phase[21] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    phase[22] = (v[0]+v[1])*3./4;
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*3./4;
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    phase[24] = v[0]*1./4+v[2]*3./4;
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    phase[25] = v[0]*1./4+v[2]*3./4;
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    phase[26] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    phase[27] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    phase[28] = v[0]*3./4+v[2]*1./4;
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    phase[29] = v[0]*3./4+v[2]*1./4;
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    phase[30] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    phase[31] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    phase[32] = v[0]*1./4+v[2]*3./4;
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    phase[33] = v[0]*1./4+v[2]*3./4;
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    phase[34] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    phase[35] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    phase[36] = v[0]*3./4+v[2]*1./4;
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    phase[37] = v[0]*3./4+v[2]*1./4;
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    phase[38] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    phase[39] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] = (v[1]+v[2])*1./4;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] = (v[1]+v[2])*1./4;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[1]+v[2])*3./4;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[1]+v[2])*3./4;
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    phase[44] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    phase[45] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    phase[46] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    phase[47] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    phase[48] = v[0]*1./4+v[1]*3./4;
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    phase[49] = v[0]*1./4+v[1]*3./4;
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    phase[50] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    phase[51] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    phase[52] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    phase[53] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    phase[54] = v[0]*3./4+v[1]*1./4;
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    phase[55] = v[0]*3./4+v[1]*1./4;
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    phase[56] = v[0]*1./4+v[1]*3./4;
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    phase[57] = v[0]*1./4+v[1]*3./4;
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    phase[58] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    phase[59] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    phase[60] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    phase[61] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    phase[62] = v[0]*3./4+v[1]*1./4;
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    phase[63] = v[0]*3./4+v[1]*1./4;
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    phase[64] = (v[0]+v[2])*1./4;
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    phase[65] = (v[0]+v[2])*1./4;
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    phase[66] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    phase[67] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    phase[68] = (v[0]+v[2])*3./4;
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    phase[69] = (v[0]+v[2])*3./4;
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    phase[70] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    phase[71] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    phase[72] = v[1]*1./4+v[2]*3./4;
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    phase[73] = v[1]*1./4+v[2]*3./4;
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    phase[74] = v[1]*3./4+v[2]*1./4;
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    phase[75] = v[1]*3./4+v[2]*1./4;
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    phase[76] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    phase[77] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    phase[78] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    phase[79] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    phase[80] =  0;
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    phase[81] =  0;
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    phase[82] = (v[1]+v[2])*1./2;
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    phase[83] = (v[1]+v[2])*1./2;
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    phase[84] = (v[0]+v[2])*1./2;
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    phase[85] = (v[0]+v[2])*1./2;
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    phase[86] = (v[0]+v[1])*1./2;
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    phase[89] =  0;
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    phase[90] = (v[1]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    phase[91] = (v[1]+v[2])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    phase[92] = (v[0]+v[2])*1./2;
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    phase[93] = (v[0]+v[2])*1./2;
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    phase[94] = (v[0]+v[1])*1./2;
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    phase[95] = (v[0]+v[1])*1./2;
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    phase[96] = (v[0]+v[1])*1./4;
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    phase[97] = (v[0]+v[1])*1./4;
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    phase[98] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    phase[99] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    phase[100] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    phase[101] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    phase[102] = (v[0]+v[1])*3./4;
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    phase[103] = (v[0]+v[1])*3./4;
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    phase[104] = (v[1]+v[2])*1./4;
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    phase[105] = (v[1]+v[2])*1./4;
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    phase[106] = (v[1]+v[2])*3./4;
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    phase[107] = (v[1]+v[2])*3./4;
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    phase[108] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    phase[109] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    phase[110] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    phase[111] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    phase[112] = (v[0]+v[2])*1./4;
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    phase[113] = (v[0]+v[2])*1./4;
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    phase[114] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    phase[115] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    phase[116] = (v[0]+v[2])*3./4;
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    phase[117] = (v[0]+v[2])*3./4;
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    phase[118] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    phase[119] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    phase[120] = (v[0]+v[1])*1./4;
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    phase[121] = (v[0]+v[1])*1./4;
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    phase[122] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    phase[123] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    phase[124] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    phase[125] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    phase[126] = (v[0]+v[1])*3./4;
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    phase[127] = (v[0]+v[1])*3./4;
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    phase[128] = (v[0]+v[2])*1./4;
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    phase[129] = (v[0]+v[2])*1./4;
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    phase[130] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    phase[131] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    phase[132] = (v[0]+v[2])*3./4;
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    phase[133] = (v[0]+v[2])*3./4;
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    phase[134] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    phase[135] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    phase[136] = (v[1]+v[2])*1./4;
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    phase[137] = (v[1]+v[2])*1./4;
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    phase[138] = (v[1]+v[2])*3./4;
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    phase[139] = (v[1]+v[2])*3./4;
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    phase[140] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    phase[141] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    phase[142] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    phase[143] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    phase[144] = v[0]*1./4+v[1]*3./4;
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    phase[145] = v[0]*1./4+v[1]*3./4;
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    phase[146] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    phase[147] = (v[0]+v[1])*1./4+v[2]*1./2;
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    phase[148] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    phase[149] = (v[0]+v[1])*3./4+v[2]*1./2;
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    phase[150] = v[0]*3./4+v[1]*1./4;
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    phase[151] = v[0]*3./4+v[1]*1./4;
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    phase[152] = v[2]*1./2;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    phase[153] = v[2]*1./2;
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    phase[154] = v[1]*1./2;
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    phase[155] = v[1]*1./2;
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    phase[156] = v[0]*1./2;
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    phase[157] = v[0]*1./2;
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    phase[158] = (v[0]+v[1]+v[2])*1./2;
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    phase[159] = (v[0]+v[1]+v[2])*1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    phase[160] = v[1]*1./4+v[2]*3./4;
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    phase[161] = v[1]*1./4+v[2]*3./4;
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    phase[162] = v[1]*3./4+v[2]*1./4;
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    phase[163] = v[1]*3./4+v[2]*1./4;
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    phase[164] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    phase[165] = v[0]*1./2+(v[1]+v[2])*1./4;
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    phase[166] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    phase[167] = v[0]*1./2+(v[1]+v[2])*3./4;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    phase[168] = v[2]*1./2;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    phase[169] = v[2]*1./2;
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    phase[170] = v[1]*1./2;
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    phase[171] = v[1]*1./2;
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    phase[172] = v[0]*1./2;
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    phase[173] = v[0]*1./2;
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    phase[174] = (v[0]+v[1]+v[2])*1./2;
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    phase[175] = (v[0]+v[1]+v[2])*1./2;
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    phase[176] = v[0]*1./4+v[2]*3./4;
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    phase[177] = v[0]*1./4+v[2]*3./4;
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    phase[178] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    phase[179] = (v[0]+v[2])*1./4+v[1]*1./2;
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    phase[180] = v[0]*3./4+v[2]*1./4;
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    phase[181] = v[0]*3./4+v[2]*1./4;
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    phase[182] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    phase[183] = (v[0]+v[2])*3./4+v[1]*1./2;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    phase[184] = v[2]*1./2;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    phase[185] = v[2]*1./2;
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    phase[186] = v[1]*1./2;
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    phase[187] = v[1]*1./2;
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    phase[188] = v[0]*1./2;
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    phase[189] = v[0]*1./2;
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    phase[190] = (v[0]+v[1]+v[2])*1./2;
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
    phase[191] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=192;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fd_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[1];
    res[8][1] = v[0]+1./4;
    res[8][2] = v[2]+1./4;
    res[9][0] = v[1];
    res[9][1] = -v[0]+1./4;
    res[9][2] = -v[2]+1./4;
    res[10][0] = -v[1];
    res[10][1] = v[0]+3./4;
    res[10][2] = v[2]+3./4;
    res[11][0] = v[1];
    res[11][1] = -v[0]+3./4;
    res[11][2] = -v[2]+3./4;
    res[12][0] = -v[1]+1./2;
    res[12][1] = v[0]+1./4;
    res[12][2] = v[2]+3./4;
    res[13][0] = v[1]+1./2;
    res[13][1] = -v[0]+1./4;
    res[13][2] = -v[2]+3./4;
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0]+3./4;
    res[14][2] = v[2]+1./4;
    res[15][0] = v[1]+1./2;
    res[15][1] = -v[0]+3./4;
    res[15][2] = -v[2]+1./4;
    res[16][0] = -v[0]+1./4;
    res[16][1] = -v[1]+1./4;
    res[16][2] = v[2];
    res[17][0] = v[0]+1./4;
    res[17][1] = v[1]+1./4;
    res[17][2] = -v[2];
    res[18][0] = -v[0]+1./4;
    res[18][1] = -v[1]+3./4;
    res[18][2] = v[2]+1./2;
    res[19][0] = v[0]+1./4;
    res[19][1] = v[1]+3./4;
    res[19][2] = -v[2]+1./2;
    res[20][0] = -v[0]+3./4;
    res[20][1] = -v[1]+1./4;
    res[20][2] = v[2]+1./2;
    res[21][0] = v[0]+3./4;
    res[21][1] = v[1]+1./4;
    res[21][2] = -v[2]+1./2;
    res[22][0] = -v[0]+3./4;
    res[22][1] = -v[1]+3./4;
    res[22][2] = v[2];
    res[23][0] = v[0]+3./4;
    res[23][1] = v[1]+3./4;
    res[23][2] = -v[2];
    res[24][0] = v[1]+1./4;
    res[24][1] = -v[0];
    res[24][2] = v[2]+1./4;
    res[25][0] = -v[1]+1./4;
    res[25][1] = v[0];
    res[25][2] = -v[2]+1./4;
    res[26][0] = v[1]+1./4;
    res[26][1] = -v[0]+1./2;
    res[26][2] = v[2]+3./4;
    res[27][0] = -v[1]+1./4;
    res[27][1] = v[0]+1./2;
    res[27][2] = -v[2]+3./4;
    res[28][0] = v[1]+3./4;
    res[28][1] = -v[0];
    res[28][2] = v[2]+3./4;
    res[29][0] = -v[1]+3./4;
    res[29][1] = v[0];
    res[29][2] = -v[2]+3./4;
    res[30][0] = v[1]+3./4;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[2]+1./4;
    res[31][0] = -v[1]+3./4;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[2]+1./4;
    res[32][0] = v[0]+1./4;
    res[32][1] = -v[2];
    res[32][2] = v[1]+1./4;
    res[33][0] = -v[0]+1./4;
    res[33][1] = v[2];
    res[33][2] = -v[1]+1./4;
    res[34][0] = v[0]+1./4;
    res[34][1] = -v[2]+1./2;
    res[34][2] = v[1]+3./4;
    res[35][0] = -v[0]+1./4;
    res[35][1] = v[2]+1./2;
    res[35][2] = -v[1]+3./4;
    res[36][0] = v[0]+3./4;
    res[36][1] = -v[2];
    res[36][2] = v[1]+3./4;
    res[37][0] = -v[0]+3./4;
    res[37][1] = v[2];
    res[37][2] = -v[1]+3./4;
    res[38][0] = v[0]+3./4;
    res[38][1] = -v[2]+1./2;
    res[38][2] = v[1]+1./4;
    res[39][0] = -v[0]+3./4;
    res[39][1] = v[2]+1./2;
    res[39][2] = -v[1]+1./4;
    res[40][0] = v[0];
    res[40][1] = -v[1]+1./4;
    res[40][2] = -v[2]+1./4;
    res[41][0] = -v[0];
    res[41][1] = v[1]+1./4;
    res[41][2] = v[2]+1./4;
    res[42][0] = v[0];
    res[42][1] = -v[1]+3./4;
    res[42][2] = -v[2]+3./4;
    res[43][0] = -v[0];
    res[43][1] = v[1]+3./4;
    res[43][2] = v[2]+3./4;
    res[44][0] = v[0]+1./2;
    res[44][1] = -v[1]+1./4;
    res[44][2] = -v[2]+3./4;
    res[45][0] = -v[0]+1./2;
    res[45][1] = v[1]+1./4;
    res[45][2] = v[2]+3./4;
    res[46][0] = v[0]+1./2;
    res[46][1] = -v[1]+3./4;
    res[46][2] = -v[2]+1./4;
    res[47][0] = -v[0]+1./2;
    res[47][1] = v[1]+3./4;
    res[47][2] = v[2]+1./4;
    res[48][0] = v[0]+1./4;
    res[48][1] = v[2]+1./4;
    res[48][2] = -v[1];
    res[49][0] = -v[0]+1./4;
    res[49][1] = -v[2]+1./4;
    res[49][2] = v[1];
    res[50][0] = v[0]+1./4;
    res[50][1] = v[2]+3./4;
    res[50][2] = -v[1]+1./2;
    res[51][0] = -v[0]+1./4;
    res[51][1] = -v[2]+3./4;
    res[51][2] = v[1]+1./2;
    res[52][0] = v[0]+3./4;
    res[52][1] = v[2]+1./4;
    res[52][2] = -v[1]+1./2;
    res[53][0] = -v[0]+3./4;
    res[53][1] = -v[2]+1./4;
    res[53][2] = v[1]+1./2;
    res[54][0] = v[0]+3./4;
    res[54][1] = v[2]+3./4;
    res[54][2] = -v[1];
    res[55][0] = -v[0]+3./4;
    res[55][1] = -v[2]+3./4;
    res[55][2] = v[1];
    res[56][0] = v[2]+1./4;
    res[56][1] = v[1]+1./4;
    res[56][2] = -v[0];
    res[57][0] = -v[2]+1./4;
    res[57][1] = -v[1]+1./4;
    res[57][2] = v[0];
    res[58][0] = v[2]+1./4;
    res[58][1] = v[1]+3./4;
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[2]+1./4;
    res[59][1] = -v[1]+3./4;
    res[59][2] = v[0]+1./2;
    res[60][0] = v[2]+3./4;
    res[60][1] = v[1]+1./4;
    res[60][2] = -v[0]+1./2;
    res[61][0] = -v[2]+3./4;
    res[61][1] = -v[1]+1./4;
    res[61][2] = v[0]+1./2;
    res[62][0] = v[2]+3./4;
    res[62][1] = v[1]+3./4;
    res[62][2] = -v[0];
    res[63][0] = -v[2]+3./4;
    res[63][1] = -v[1]+3./4;
    res[63][2] = v[0];
    res[64][0] = -v[0]+1./4;
    res[64][1] = v[1];
    res[64][2] = -v[2]+1./4;
    res[65][0] = v[0]+1./4;
    res[65][1] = -v[1];
    res[65][2] = v[2]+1./4;
    res[66][0] = -v[0]+1./4;
    res[66][1] = v[1]+1./2;
    res[66][2] = -v[2]+3./4;
    res[67][0] = v[0]+1./4;
    res[67][1] = -v[1]+1./2;
    res[67][2] = v[2]+3./4;
    res[68][0] = -v[0]+3./4;
    res[68][1] = v[1];
    res[68][2] = -v[2]+3./4;
    res[69][0] = v[0]+3./4;
    res[69][1] = -v[1];
    res[69][2] = v[2]+3./4;
    res[70][0] = -v[0]+3./4;
    res[70][1] = v[1]+1./2;
    res[70][2] = -v[2]+1./4;
    res[71][0] = v[0]+3./4;
    res[71][1] = -v[1]+1./2;
    res[71][2] = v[2]+1./4;
    res[72][0] = -v[2];
    res[72][1] = v[1]+1./4;
    res[72][2] = v[0]+1./4;
    res[73][0] = v[2];
    res[73][1] = -v[1]+1./4;
    res[73][2] = -v[0]+1./4;
    res[74][0] = -v[2];
    res[74][1] = v[1]+3./4;
    res[74][2] = v[0]+3./4;
    res[75][0] = v[2];
    res[75][1] = -v[1]+3./4;
    res[75][2] = -v[0]+3./4;
    res[76][0] = -v[2]+1./2;
    res[76][1] = v[1]+1./4;
    res[76][2] = v[0]+3./4;
    res[77][0] = v[2]+1./2;
    res[77][1] = -v[1]+1./4;
    res[77][2] = -v[0]+3./4;
    res[78][0] = -v[2]+1./2;
    res[78][1] = v[1]+3./4;
    res[78][2] = v[0]+1./4;
    res[79][0] = v[2]+1./2;
    res[79][1] = -v[1]+3./4;
    res[79][2] = -v[0]+1./4;
    res[80][0] = v[2];
    res[80][1] = v[0];
    res[80][2] = v[1];
    res[81][0] = -v[2];
    res[81][1] = -v[0];
    res[81][2] = -v[1];
    res[82][0] = v[2];
    res[82][1] = v[0]+1./2;
    res[82][2] = v[1]+1./2;
    res[83][0] = -v[2];
    res[83][1] = -v[0]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = v[2]+1./2;
    res[84][1] = v[0];
    res[84][2] = v[1]+1./2;
    res[85][0] = -v[2]+1./2;
    res[85][1] = -v[0];
    res[85][2] = -v[1]+1./2;
    res[86][0] = v[2]+1./2;
    res[86][1] = v[0]+1./2;
    res[86][2] = v[1];
    res[87][0] = -v[2]+1./2;
    res[87][1] = -v[0]+1./2;
    res[87][2] = -v[1];
    res[88][0] = v[1];
    res[88][1] = v[2];
    res[88][2] = v[0];
    res[89][0] = -v[1];
    res[89][1] = -v[2];
    res[89][2] = -v[0];
    res[90][0] = v[1];
    res[90][1] = v[2]+1./2;
    res[90][2] = v[0]+1./2;
    res[91][0] = -v[1];
    res[91][1] = -v[2]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = v[1]+1./2;
    res[92][1] = v[2];
    res[92][2] = v[0]+1./2;
    res[93][0] = -v[1]+1./2;
    res[93][1] = -v[2];
    res[93][2] = -v[0]+1./2;
    res[94][0] = v[1]+1./2;
    res[94][1] = v[2]+1./2;
    res[94][2] = v[0];
    res[95][0] = -v[1]+1./2;
    res[95][1] = -v[2]+1./2;
    res[95][2] = -v[0];
    res[96][0] = -v[1]+1./4;
    res[96][1] = -v[2]+1./4;
    res[96][2] = v[0];
    res[97][0] = v[1]+1./4;
    res[97][1] = v[2]+1./4;
    res[97][2] = -v[0];
    res[98][0] = -v[1]+1./4;
    res[98][1] = -v[2]+3./4;
    res[98][2] = v[0]+1./2;
    res[99][0] = v[1]+1./4;
    res[99][1] = v[2]+3./4;
    res[99][2] = -v[0]+1./2;
    res[100][0] = -v[1]+3./4;
    res[100][1] = -v[2]+1./4;
    res[100][2] = v[0]+1./2;
    res[101][0] = v[1]+3./4;
    res[101][1] = v[2]+1./4;
    res[101][2] = -v[0]+1./2;
    res[102][0] = -v[1]+3./4;
    res[102][1] = -v[2]+3./4;
    res[102][2] = v[0];
    res[103][0] = v[1]+3./4;
    res[103][1] = v[2]+3./4;
    res[103][2] = -v[0];
    res[104][0] = v[2];
    res[104][1] = -v[0]+1./4;
    res[104][2] = -v[1]+1./4;
    res[105][0] = -v[2];
    res[105][1] = v[0]+1./4;
    res[105][2] = v[1]+1./4;
    res[106][0] = v[2];
    res[106][1] = -v[0]+3./4;
    res[106][2] = -v[1]+3./4;
    res[107][0] = -v[2];
    res[107][1] = v[0]+3./4;
    res[107][2] = v[1]+3./4;
    res[108][0] = v[2]+1./2;
    res[108][1] = -v[0]+1./4;
    res[108][2] = -v[1]+3./4;
    res[109][0] = -v[2]+1./2;
    res[109][1] = v[0]+1./4;
    res[109][2] = v[1]+3./4;
    res[110][0] = v[2]+1./2;
    res[110][1] = -v[0]+3./4;
    res[110][2] = -v[1]+1./4;
    res[111][0] = -v[2]+1./2;
    res[111][1] = v[0]+3./4;
    res[111][2] = v[1]+1./4;
    res[112][0] = -v[1]+1./4;
    res[112][1] = v[2];
    res[112][2] = -v[0]+1./4;
    res[113][0] = v[1]+1./4;
    res[113][1] = -v[2];
    res[113][2] = v[0]+1./4;
    res[114][0] = -v[1]+1./4;
    res[114][1] = v[2]+1./2;
    res[114][2] = -v[0]+3./4;
    res[115][0] = v[1]+1./4;
    res[115][1] = -v[2]+1./2;
    res[115][2] = v[0]+3./4;
    res[116][0] = -v[1]+3./4;
    res[116][1] = v[2];
    res[116][2] = -v[0]+3./4;
    res[117][0] = v[1]+3./4;
    res[117][1] = -v[2];
    res[117][2] = v[0]+3./4;
    res[118][0] = -v[1]+3./4;
    res[118][1] = v[2]+1./2;
    res[118][2] = -v[0]+1./4;
    res[119][0] = v[1]+3./4;
    res[119][1] = -v[2]+1./2;
    res[119][2] = v[0]+1./4;
    res[120][0] = -v[2]+1./4;
    res[120][1] = -v[0]+1./4;
    res[120][2] = v[1];
    res[121][0] = v[2]+1./4;
    res[121][1] = v[0]+1./4;
    res[121][2] = -v[1];
    res[122][0] = -v[2]+1./4;
    res[122][1] = -v[0]+3./4;
    res[122][2] = v[1]+1./2;
    res[123][0] = v[2]+1./4;
    res[123][1] = v[0]+3./4;
    res[123][2] = -v[1]+1./2;
    res[124][0] = -v[2]+3./4;
    res[124][1] = -v[0]+1./4;
    res[124][2] = v[1]+1./2;
    res[125][0] = v[2]+3./4;
    res[125][1] = v[0]+1./4;
    res[125][2] = -v[1]+1./2;
    res[126][0] = -v[2]+3./4;
    res[126][1] = -v[0]+3./4;
    res[126][2] = v[1];
    res[127][0] = v[2]+3./4;
    res[127][1] = v[0]+3./4;
    res[127][2] = -v[1];
    res[128][0] = -v[2]+1./4;
    res[128][1] = v[0];
    res[128][2] = -v[1]+1./4;
    res[129][0] = v[2]+1./4;
    res[129][1] = -v[0];
    res[129][2] = v[1]+1./4;
    res[130][0] = -v[2]+1./4;
    res[130][1] = v[0]+1./2;
    res[130][2] = -v[1]+3./4;
    res[131][0] = v[2]+1./4;
    res[131][1] = -v[0]+1./2;
    res[131][2] = v[1]+3./4;
    res[132][0] = -v[2]+3./4;
    res[132][1] = v[0];
    res[132][2] = -v[1]+3./4;
    res[133][0] = v[2]+3./4;
    res[133][1] = -v[0];
    res[133][2] = v[1]+3./4;
    res[134][0] = -v[2]+3./4;
    res[134][1] = v[0]+1./2;
    res[134][2] = -v[1]+1./4;
    res[135][0] = v[2]+3./4;
    res[135][1] = -v[0]+1./2;
    res[135][2] = v[1]+1./4;
    res[136][0] = v[1];
    res[136][1] = -v[2]+1./4;
    res[136][2] = -v[0]+1./4;
    res[137][0] = -v[1];
    res[137][1] = v[2]+1./4;
    res[137][2] = v[0]+1./4;
    res[138][0] = v[1];
    res[138][1] = -v[2]+3./4;
    res[138][2] = -v[0]+3./4;
    res[139][0] = -v[1];
    res[139][1] = v[2]+3./4;
    res[139][2] = v[0]+3./4;
    res[140][0] = v[1]+1./2;
    res[140][1] = -v[2]+1./4;
    res[140][2] = -v[0]+3./4;
    res[141][0] = -v[1]+1./2;
    res[141][1] = v[2]+1./4;
    res[141][2] = v[0]+3./4;
    res[142][0] = v[1]+1./2;
    res[142][1] = -v[2]+3./4;
    res[142][2] = -v[0]+1./4;
    res[143][0] = -v[1]+1./2;
    res[143][1] = v[2]+3./4;
    res[143][2] = v[0]+1./4;
    res[144][0] = v[1]+1./4;
    res[144][1] = v[0]+1./4;
    res[144][2] = -v[2];
    res[145][0] = -v[1]+1./4;
    res[145][1] = -v[0]+1./4;
    res[145][2] = v[2];
    res[146][0] = v[1]+1./4;
    res[146][1] = v[0]+3./4;
    res[146][2] = -v[2]+1./2;
    res[147][0] = -v[1]+1./4;
    res[147][1] = -v[0]+3./4;
    res[147][2] = v[2]+1./2;
    res[148][0] = v[1]+3./4;
    res[148][1] = v[0]+1./4;
    res[148][2] = -v[2]+1./2;
    res[149][0] = -v[1]+3./4;
    res[149][1] = -v[0]+1./4;
    res[149][2] = v[2]+1./2;
    res[150][0] = v[1]+3./4;
    res[150][1] = v[0]+3./4;
    res[150][2] = -v[2];
    res[151][0] = -v[1]+3./4;
    res[151][1] = -v[0]+3./4;
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0]+1./2;
    res[154][2] = -v[2]+1./2;
    res[155][0] = v[1];
    res[155][1] = v[0]+1./2;
    res[155][2] = v[2]+1./2;
    res[156][0] = -v[1]+1./2;
    res[156][1] = -v[0];
    res[156][2] = -v[2]+1./2;
    res[157][0] = v[1]+1./2;
    res[157][1] = v[0];
    res[157][2] = v[2]+1./2;
    res[158][0] = -v[1]+1./2;
    res[158][1] = -v[0]+1./2;
    res[158][2] = -v[2];
    res[159][0] = v[1]+1./2;
    res[159][1] = v[0]+1./2;
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2]+1./4;
    res[160][2] = v[1]+1./4;
    res[161][0] = v[0];
    res[161][1] = -v[2]+1./4;
    res[161][2] = -v[1]+1./4;
    res[162][0] = -v[0];
    res[162][1] = v[2]+3./4;
    res[162][2] = v[1]+3./4;
    res[163][0] = v[0];
    res[163][1] = -v[2]+3./4;
    res[163][2] = -v[1]+3./4;
    res[164][0] = -v[0]+1./2;
    res[164][1] = v[2]+1./4;
    res[164][2] = v[1]+3./4;
    res[165][0] = v[0]+1./2;
    res[165][1] = -v[2]+1./4;
    res[165][2] = -v[1]+3./4;
    res[166][0] = -v[0]+1./2;
    res[166][1] = v[2]+3./4;
    res[166][2] = v[1]+1./4;
    res[167][0] = v[0]+1./2;
    res[167][1] = -v[2]+3./4;
    res[167][2] = -v[1]+1./4;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2]+1./2;
    res[170][2] = -v[1]+1./2;
    res[171][0] = v[0];
    res[171][1] = v[2]+1./2;
    res[171][2] = v[1]+1./2;
    res[172][0] = -v[0]+1./2;
    res[172][1] = -v[2];
    res[172][2] = -v[1]+1./2;
    res[173][0] = v[0]+1./2;
    res[173][1] = v[2];
    res[173][2] = v[1]+1./2;
    res[174][0] = -v[0]+1./2;
    res[174][1] = -v[2]+1./2;
    res[174][2] = -v[1];
    res[175][0] = v[0]+1./2;
    res[175][1] = v[2]+1./2;
    res[175][2] = v[1];
    res[176][0] = v[2]+1./4;
    res[176][1] = -v[1];
    res[176][2] = v[0]+1./4;
    res[177][0] = -v[2]+1./4;
    res[177][1] = v[1];
    res[177][2] = -v[0]+1./4;
    res[178][0] = v[2]+1./4;
    res[178][1] = -v[1]+1./2;
    res[178][2] = v[0]+3./4;
    res[179][0] = -v[2]+1./4;
    res[179][1] = v[1]+1./2;
    res[179][2] = -v[0]+3./4;
    res[180][0] = v[2]+3./4;
    res[180][1] = -v[1];
    res[180][2] = v[0]+3./4;
    res[181][0] = -v[2]+3./4;
    res[181][1] = v[1];
    res[181][2] = -v[0]+3./4;
    res[182][0] = v[2]+3./4;
    res[182][1] = -v[1]+1./2;
    res[182][2] = v[0]+1./4;
    res[183][0] = -v[2]+3./4;
    res[183][1] = v[1]+1./2;
    res[183][2] = -v[0]+1./4;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1]+1./2;
    res[186][2] = -v[0]+1./2;
    res[187][0] = v[2];
    res[187][1] = v[1]+1./2;
    res[187][2] = v[0]+1./2;
    res[188][0] = -v[2]+1./2;
    res[188][1] = -v[1];
    res[188][2] = -v[0]+1./2;
    res[189][0] = v[2]+1./2;
    res[189][1] = v[1];
    res[189][2] = v[0]+1./2;
    res[190][0] = -v[2]+1./2;
    res[190][1] = -v[1]+1./2;
    res[190][2] = -v[0];
    res[191][0] = v[2]+1./2;
    res[191][1] = v[1]+1./2;
    res[191][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] = (v[1]+v[2])*1./4;
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] = (v[1]+v[2])*1./4;
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    phase[10] = (v[1]+v[2])*3./4;
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    phase[11] = (v[1]+v[2])*3./4;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    phase[15] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    phase[16] = (v[0]+v[1])*1./4;
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[0]+v[1])*1./4;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    phase[20] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    phase[21] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    phase[22] = (v[0]+v[1])*3./4;
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*3./4;
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    phase[24] = (v[0]+v[2])*1./4;
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    phase[25] = (v[0]+v[2])*1./4;
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    phase[26] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    phase[27] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    phase[28] = (v[0]+v[2])*3./4;
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    phase[29] = (v[0]+v[2])*3./4;
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    phase[30] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    phase[31] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    phase[32] = (v[0]+v[2])*1./4;
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    phase[33] = (v[0]+v[2])*1./4;
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    phase[34] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    phase[35] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    phase[36] = (v[0]+v[2])*3./4;
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    phase[37] = (v[0]+v[2])*3./4;
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    phase[38] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    phase[39] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] = (v[1]+v[2])*1./4;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] = (v[1]+v[2])*1./4;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[1]+v[2])*3./4;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[1]+v[2])*3./4;
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    phase[44] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    phase[45] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    phase[46] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    phase[47] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    phase[48] = (v[0]+v[1])*1./4;
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    phase[49] = (v[0]+v[1])*1./4;
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    phase[50] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    phase[51] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    phase[52] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    phase[53] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    phase[54] = (v[0]+v[1])*3./4;
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    phase[55] = (v[0]+v[1])*3./4;
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    phase[56] = (v[0]+v[1])*1./4;
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    phase[57] = (v[0]+v[1])*1./4;
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    phase[58] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    phase[59] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    phase[60] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    phase[61] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    phase[62] = (v[0]+v[1])*3./4;
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*3./4;
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    phase[64] = (v[0]+v[2])*1./4;
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    phase[65] = (v[0]+v[2])*1./4;
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    phase[66] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    phase[67] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    phase[68] = (v[0]+v[2])*3./4;
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    phase[69] = (v[0]+v[2])*3./4;
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    phase[70] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    phase[71] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    phase[72] = (v[1]+v[2])*1./4;
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    phase[73] = (v[1]+v[2])*1./4;
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    phase[74] = (v[1]+v[2])*3./4;
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    phase[75] = (v[1]+v[2])*3./4;
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    phase[76] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    phase[77] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    phase[78] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    phase[79] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    phase[80] =  0;
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    phase[81] =  0;
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    phase[82] = (v[1]+v[2])*1./2;
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    phase[83] = (v[1]+v[2])*1./2;
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    phase[84] = (v[0]+v[2])*1./2;
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    phase[85] = (v[0]+v[2])*1./2;
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    phase[86] = (v[0]+v[1])*1./2;
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    phase[89] =  0;
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    phase[90] = (v[1]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    phase[91] = (v[1]+v[2])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    phase[92] = (v[0]+v[2])*1./2;
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    phase[93] = (v[0]+v[2])*1./2;
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    phase[94] = (v[0]+v[1])*1./2;
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    phase[95] = (v[0]+v[1])*1./2;
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    phase[96] = (v[0]+v[1])*1./4;
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    phase[97] = (v[0]+v[1])*1./4;
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    phase[98] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    phase[99] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    phase[100] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    phase[101] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    phase[102] = (v[0]+v[1])*3./4;
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    phase[103] = (v[0]+v[1])*3./4;
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    phase[104] = (v[1]+v[2])*1./4;
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    phase[105] = (v[1]+v[2])*1./4;
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    phase[106] = (v[1]+v[2])*3./4;
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    phase[107] = (v[1]+v[2])*3./4;
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    phase[108] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    phase[109] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    phase[110] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    phase[111] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    phase[112] = (v[0]+v[2])*1./4;
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    phase[113] = (v[0]+v[2])*1./4;
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    phase[114] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    phase[115] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    phase[116] = (v[0]+v[2])*3./4;
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    phase[117] = (v[0]+v[2])*3./4;
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    phase[118] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    phase[119] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    phase[120] = (v[0]+v[1])*1./4;
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    phase[121] = (v[0]+v[1])*1./4;
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    phase[122] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    phase[123] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    phase[124] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    phase[125] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    phase[126] = (v[0]+v[1])*3./4;
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    phase[127] = (v[0]+v[1])*3./4;
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    phase[128] = (v[0]+v[2])*1./4;
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    phase[129] = (v[0]+v[2])*1./4;
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    phase[130] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    phase[131] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    phase[132] = (v[0]+v[2])*3./4;
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    phase[133] = (v[0]+v[2])*3./4;
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    phase[134] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    phase[135] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    phase[136] = (v[1]+v[2])*1./4;
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    phase[137] = (v[1]+v[2])*1./4;
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    phase[138] = (v[1]+v[2])*3./4;
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    phase[139] = (v[1]+v[2])*3./4;
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    phase[140] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    phase[141] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    phase[142] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    phase[143] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    phase[144] = (v[0]+v[1])*1./4;
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    phase[145] = (v[0]+v[1])*1./4;
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    phase[146] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    phase[147] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    phase[148] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    phase[149] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    phase[150] = (v[0]+v[1])*3./4;
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    phase[151] = (v[0]+v[1])*3./4;
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    phase[152] =  0;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    phase[153] =  0;
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    phase[154] = (v[1]+v[2])*1./2;
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    phase[155] = (v[1]+v[2])*1./2;
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    phase[156] = (v[0]+v[2])*1./2;
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    phase[157] = (v[0]+v[2])*1./2;
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    phase[158] = (v[0]+v[1])*1./2;
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    phase[159] = (v[0]+v[1])*1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    phase[160] = (v[1]+v[2])*1./4;
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    phase[161] = (v[1]+v[2])*1./4;
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    phase[162] = (v[1]+v[2])*3./4;
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    phase[163] = (v[1]+v[2])*3./4;
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    phase[164] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    phase[165] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    phase[166] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    phase[167] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    phase[168] =  0;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    phase[169] =  0;
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    phase[170] = (v[1]+v[2])*1./2;
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    phase[171] = (v[1]+v[2])*1./2;
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    phase[172] = (v[0]+v[2])*1./2;
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    phase[173] = (v[0]+v[2])*1./2;
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    phase[174] = (v[0]+v[1])*1./2;
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    phase[175] = (v[0]+v[1])*1./2;
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    phase[176] = (v[0]+v[2])*1./4;
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    phase[177] = (v[0]+v[2])*1./4;
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    phase[178] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    phase[179] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    phase[180] = (v[0]+v[2])*3./4;
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    phase[181] = (v[0]+v[2])*3./4;
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    phase[182] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    phase[183] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    phase[184] =  0;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    phase[185] =  0;
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    phase[186] = (v[1]+v[2])*1./2;
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    phase[187] = (v[1]+v[2])*1./2;
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    phase[188] = (v[0]+v[2])*1./2;
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    phase[189] = (v[0]+v[2])*1./2;
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    phase[190] = (v[0]+v[1])*1./2;
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
    phase[191] = (v[0]+v[1])*1./2;
  }
  static const short size=192;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fd2d {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./4;
    res[8][1] = v[1]+1./4;
    res[8][2] = -v[2]+1./4;
    res[9][0] = v[0]+1./4;
    res[9][1] = v[1]+3./4;
    res[9][2] = -v[2]+3./4;
    res[10][0] = v[0]+3./4;
    res[10][1] = v[1]+1./4;
    res[10][2] = -v[2]+3./4;
    res[11][0] = v[0]+3./4;
    res[11][1] = v[1]+3./4;
    res[11][2] = -v[2]+1./4;
    res[12][0] = -v[0]+1./4;
    res[12][1] = v[1]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = -v[0]+1./4;
    res[13][1] = v[1]+3./4;
    res[13][2] = v[2]+3./4;
    res[14][0] = -v[0]+3./4;
    res[14][1] = v[1]+1./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = -v[0]+3./4;
    res[15][1] = v[1]+3./4;
    res[15][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = v[2];
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1]+v[2])*1./4;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./4;
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fdd2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
    res[8][0] = -v[0]+1./4;
    res[8][1] = v[1]+1./4;
    res[8][2] = v[2]+1./4;
    res[9][0] = -v[0]+1./4;
    res[9][1] = v[1]+3./4;
    res[9][2] = v[2]+3./4;
    res[10][0] = -v[0]+3./4;
    res[10][1] = v[1]+1./4;
    res[10][2] = v[2]+3./4;
    res[11][0] = -v[0]+3./4;
    res[11][1] = v[1]+3./4;
    res[11][2] = v[2]+1./4;
    res[12][0] = v[0]+1./4;
    res[12][1] = -v[1]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = v[0]+1./4;
    res[13][1] = -v[1]+3./4;
    res[13][2] = v[2]+3./4;
    res[14][0] = v[0]+3./4;
    res[14][1] = -v[1]+1./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = v[0]+3./4;
    res[15][1] = -v[1]+3./4;
    res[15][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] = (v[0]+v[1]+v[2])*1./4;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./4;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fddd {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[0]+1./4;
    res[8][1] = -v[1]+1./4;
    res[8][2] = v[2];
    res[9][0] = v[0]+1./4;
    res[9][1] = v[1]+1./4;
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./4;
    res[10][1] = -v[1]+3./4;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./4;
    res[11][1] = v[1]+3./4;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[0]+3./4;
    res[12][1] = -v[1]+1./4;
    res[12][2] = v[2]+1./2;
    res[13][0] = v[0]+3./4;
    res[13][1] = v[1]+1./4;
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[0]+3./4;
    res[14][1] = -v[1]+3./4;
    res[14][2] = v[2];
    res[15][0] = v[0]+3./4;
    res[15][1] = v[1]+3./4;
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1]+1./4;
    res[16][2] = -v[2]+1./4;
    res[17][0] = -v[0];
    res[17][1] = v[1]+1./4;
    res[17][2] = v[2]+1./4;
    res[18][0] = v[0];
    res[18][1] = -v[1]+3./4;
    res[18][2] = -v[2]+3./4;
    res[19][0] = -v[0];
    res[19][1] = v[1]+3./4;
    res[19][2] = v[2]+3./4;
    res[20][0] = v[0]+1./2;
    res[20][1] = -v[1]+1./4;
    res[20][2] = -v[2]+3./4;
    res[21][0] = -v[0]+1./2;
    res[21][1] = v[1]+1./4;
    res[21][2] = v[2]+3./4;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1]+3./4;
    res[22][2] = -v[2]+1./4;
    res[23][0] = -v[0]+1./2;
    res[23][1] = v[1]+3./4;
    res[23][2] = v[2]+1./4;
    res[24][0] = -v[0]+1./4;
    res[24][1] = v[1];
    res[24][2] = -v[2]+1./4;
    res[25][0] = v[0]+1./4;
    res[25][1] = -v[1];
    res[25][2] = v[2]+1./4;
    res[26][0] = -v[0]+1./4;
    res[26][1] = v[1]+1./2;
    res[26][2] = -v[2]+3./4;
    res[27][0] = v[0]+1./4;
    res[27][1] = -v[1]+1./2;
    res[27][2] = v[2]+3./4;
    res[28][0] = -v[0]+3./4;
    res[28][1] = v[1];
    res[28][2] = -v[2]+3./4;
    res[29][0] = v[0]+3./4;
    res[29][1] = -v[1];
    res[29][2] = v[2]+3./4;
    res[30][0] = -v[0]+3./4;
    res[30][1] = v[1]+1./2;
    res[30][2] = -v[2]+1./4;
    res[31][0] = v[0]+3./4;
    res[31][1] = -v[1]+1./2;
    res[31][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    res[14][0] = -v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    res[24][0] = -v[0];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    res[27][0] = v[0];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    res[28][0] = -v[0];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    res[29][0] = v[0];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    res[30][0] = -v[0];
    res[30][1] = v[1];
    res[30][2] = -v[2];
    res[31][0] = v[0];
    res[31][1] = -v[1];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] = (v[0]+v[1])*1./4;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = (v[0]+v[1])*1./4;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./4+v[1]*3./4+v[2]*1./2;
    res[12][0] = -v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    phase[13] = v[0]*3./4+v[1]*1./4+v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*3./4;
    res[15][0] = v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*3./4;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] = (v[1]+v[2])*1./4;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] = (v[1]+v[2])*1./4;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[1]+v[2])*3./4;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[1]+v[2])*3./4;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] = v[0]*1./2+v[1]*1./4+v[2]*3./4;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = v[0]*1./2+v[1]*3./4+v[2]*1./4;
    res[24][0] = -v[0];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    phase[24] = (v[0]+v[2])*1./4;
    res[25][0] = v[0];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    phase[25] = (v[0]+v[2])*1./4;
    res[26][0] = -v[0];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    phase[26] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[27][0] = v[0];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    phase[27] = v[0]*1./4+v[1]*1./2+v[2]*3./4;
    res[28][0] = -v[0];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    phase[28] = (v[0]+v[2])*3./4;
    res[29][0] = v[0];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    phase[29] = (v[0]+v[2])*3./4;
    res[30][0] = -v[0];
    res[30][1] = v[1];
    res[30][2] = -v[2];
    phase[30] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
    res[31][0] = v[0];
    res[31][1] = -v[1];
    res[31][2] = v[2];
    phase[31] = v[0]*3./4+v[1]*1./2+v[2]*1./4;
  }
  static const short size=32;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fm_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    res[10][0] = v[2];
    res[10][1] = v[0]+1./2;
    res[10][2] = v[1]+1./2;
    res[11][0] = -v[2];
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[1]+1./2;
    res[12][0] = v[2]+1./2;
    res[12][1] = v[0];
    res[12][2] = v[1]+1./2;
    res[13][0] = -v[2]+1./2;
    res[13][1] = -v[0];
    res[13][2] = -v[1]+1./2;
    res[14][0] = v[2]+1./2;
    res[14][1] = v[0]+1./2;
    res[14][2] = v[1];
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[1];
    res[16][0] = v[1];
    res[16][1] = v[2];
    res[16][2] = v[0];
    res[17][0] = -v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = v[1];
    res[18][1] = v[2]+1./2;
    res[18][2] = v[0]+1./2;
    res[19][0] = -v[1];
    res[19][1] = -v[2]+1./2;
    res[19][2] = -v[0]+1./2;
    res[20][0] = v[1]+1./2;
    res[20][1] = v[2];
    res[20][2] = v[0]+1./2;
    res[21][0] = -v[1]+1./2;
    res[21][1] = -v[2];
    res[21][2] = -v[0]+1./2;
    res[22][0] = v[1]+1./2;
    res[22][1] = v[2]+1./2;
    res[22][2] = v[0];
    res[23][0] = -v[1]+1./2;
    res[23][1] = -v[2]+1./2;
    res[23][2] = -v[0];
    res[24][0] = -v[1];
    res[24][1] = -v[2];
    res[24][2] = v[0];
    res[25][0] = v[1];
    res[25][1] = v[2];
    res[25][2] = -v[0];
    res[26][0] = -v[1];
    res[26][1] = -v[2]+1./2;
    res[26][2] = v[0]+1./2;
    res[27][0] = v[1];
    res[27][1] = v[2]+1./2;
    res[27][2] = -v[0]+1./2;
    res[28][0] = -v[1]+1./2;
    res[28][1] = -v[2];
    res[28][2] = v[0]+1./2;
    res[29][0] = v[1]+1./2;
    res[29][1] = v[2];
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[1]+1./2;
    res[30][1] = -v[2]+1./2;
    res[30][2] = v[0];
    res[31][0] = v[1]+1./2;
    res[31][1] = v[2]+1./2;
    res[31][2] = -v[0];
    res[32][0] = v[2];
    res[32][1] = -v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2];
    res[33][1] = v[0];
    res[33][2] = v[1];
    res[34][0] = v[2];
    res[34][1] = -v[0]+1./2;
    res[34][2] = -v[1]+1./2;
    res[35][0] = -v[2];
    res[35][1] = v[0]+1./2;
    res[35][2] = v[1]+1./2;
    res[36][0] = v[2]+1./2;
    res[36][1] = -v[0];
    res[36][2] = -v[1]+1./2;
    res[37][0] = -v[2]+1./2;
    res[37][1] = v[0];
    res[37][2] = v[1]+1./2;
    res[38][0] = v[2]+1./2;
    res[38][1] = -v[0]+1./2;
    res[38][2] = -v[1];
    res[39][0] = -v[2]+1./2;
    res[39][1] = v[0]+1./2;
    res[39][2] = v[1];
    res[40][0] = -v[1];
    res[40][1] = v[2];
    res[40][2] = -v[0];
    res[41][0] = v[1];
    res[41][1] = -v[2];
    res[41][2] = v[0];
    res[42][0] = -v[1];
    res[42][1] = v[2]+1./2;
    res[42][2] = -v[0]+1./2;
    res[43][0] = v[1];
    res[43][1] = -v[2]+1./2;
    res[43][2] = v[0]+1./2;
    res[44][0] = -v[1]+1./2;
    res[44][1] = v[2];
    res[44][2] = -v[0]+1./2;
    res[45][0] = v[1]+1./2;
    res[45][1] = -v[2];
    res[45][2] = v[0]+1./2;
    res[46][0] = -v[1]+1./2;
    res[46][1] = v[2]+1./2;
    res[46][2] = -v[0];
    res[47][0] = v[1]+1./2;
    res[47][1] = -v[2]+1./2;
    res[47][2] = v[0];
    res[48][0] = -v[2];
    res[48][1] = -v[0];
    res[48][2] = v[1];
    res[49][0] = v[2];
    res[49][1] = v[0];
    res[49][2] = -v[1];
    res[50][0] = -v[2];
    res[50][1] = -v[0]+1./2;
    res[50][2] = v[1]+1./2;
    res[51][0] = v[2];
    res[51][1] = v[0]+1./2;
    res[51][2] = -v[1]+1./2;
    res[52][0] = -v[2]+1./2;
    res[52][1] = -v[0];
    res[52][2] = v[1]+1./2;
    res[53][0] = v[2]+1./2;
    res[53][1] = v[0];
    res[53][2] = -v[1]+1./2;
    res[54][0] = -v[2]+1./2;
    res[54][1] = -v[0]+1./2;
    res[54][2] = v[1];
    res[55][0] = v[2]+1./2;
    res[55][1] = v[0]+1./2;
    res[55][2] = -v[1];
    res[56][0] = -v[2];
    res[56][1] = v[0];
    res[56][2] = -v[1];
    res[57][0] = v[2];
    res[57][1] = -v[0];
    res[57][2] = v[1];
    res[58][0] = -v[2];
    res[58][1] = v[0]+1./2;
    res[58][2] = -v[1]+1./2;
    res[59][0] = v[2];
    res[59][1] = -v[0]+1./2;
    res[59][2] = v[1]+1./2;
    res[60][0] = -v[2]+1./2;
    res[60][1] = v[0];
    res[60][2] = -v[1]+1./2;
    res[61][0] = v[2]+1./2;
    res[61][1] = -v[0];
    res[61][2] = v[1]+1./2;
    res[62][0] = -v[2]+1./2;
    res[62][1] = v[0]+1./2;
    res[62][2] = -v[1];
    res[63][0] = v[2]+1./2;
    res[63][1] = -v[0]+1./2;
    res[63][2] = v[1];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = -v[1];
    res[65][1] = v[2];
    res[65][2] = v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2]+1./2;
    res[66][2] = -v[0]+1./2;
    res[67][0] = -v[1];
    res[67][1] = v[2]+1./2;
    res[67][2] = v[0]+1./2;
    res[68][0] = v[1]+1./2;
    res[68][1] = -v[2];
    res[68][2] = -v[0]+1./2;
    res[69][0] = -v[1]+1./2;
    res[69][1] = v[2];
    res[69][2] = v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2]+1./2;
    res[70][2] = -v[0];
    res[71][0] = -v[1]+1./2;
    res[71][1] = v[2]+1./2;
    res[71][2] = v[0];
    res[72][0] = -v[0];
    res[72][1] = -v[1];
    res[72][2] = v[2];
    res[73][0] = v[0];
    res[73][1] = v[1];
    res[73][2] = -v[2];
    res[74][0] = -v[0];
    res[74][1] = -v[1]+1./2;
    res[74][2] = v[2]+1./2;
    res[75][0] = v[0];
    res[75][1] = v[1]+1./2;
    res[75][2] = -v[2]+1./2;
    res[76][0] = -v[0]+1./2;
    res[76][1] = -v[1];
    res[76][2] = v[2]+1./2;
    res[77][0] = v[0]+1./2;
    res[77][1] = v[1];
    res[77][2] = -v[2]+1./2;
    res[78][0] = -v[0]+1./2;
    res[78][1] = -v[1]+1./2;
    res[78][2] = v[2];
    res[79][0] = v[0]+1./2;
    res[79][1] = v[1]+1./2;
    res[79][2] = -v[2];
    res[80][0] = v[0];
    res[80][1] = -v[1];
    res[80][2] = -v[2];
    res[81][0] = -v[0];
    res[81][1] = v[1];
    res[81][2] = v[2];
    res[82][0] = v[0];
    res[82][1] = -v[1]+1./2;
    res[82][2] = -v[2]+1./2;
    res[83][0] = -v[0];
    res[83][1] = v[1]+1./2;
    res[83][2] = v[2]+1./2;
    res[84][0] = v[0]+1./2;
    res[84][1] = -v[1];
    res[84][2] = -v[2]+1./2;
    res[85][0] = -v[0]+1./2;
    res[85][1] = v[1];
    res[85][2] = v[2]+1./2;
    res[86][0] = v[0]+1./2;
    res[86][1] = -v[1]+1./2;
    res[86][2] = -v[2];
    res[87][0] = -v[0]+1./2;
    res[87][1] = v[1]+1./2;
    res[87][2] = v[2];
    res[88][0] = -v[0];
    res[88][1] = v[1];
    res[88][2] = -v[2];
    res[89][0] = v[0];
    res[89][1] = -v[1];
    res[89][2] = v[2];
    res[90][0] = -v[0];
    res[90][1] = v[1]+1./2;
    res[90][2] = -v[2]+1./2;
    res[91][0] = v[0];
    res[91][1] = -v[1]+1./2;
    res[91][2] = v[2]+1./2;
    res[92][0] = -v[0]+1./2;
    res[92][1] = v[1];
    res[92][2] = -v[2]+1./2;
    res[93][0] = v[0]+1./2;
    res[93][1] = -v[1];
    res[93][2] = v[2]+1./2;
    res[94][0] = -v[0]+1./2;
    res[94][1] = v[1]+1./2;
    res[94][2] = -v[2];
    res[95][0] = v[0]+1./2;
    res[95][1] = -v[1]+1./2;
    res[95][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = -v[1];
    res[11][1] = -v[2];
    res[11][2] = -v[0];
    res[12][0] = v[1];
    res[12][1] = v[2];
    res[12][2] = v[0];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = -v[0];
    res[14][0] = v[1];
    res[14][1] = v[2];
    res[14][2] = v[0];
    res[15][0] = -v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    res[16][0] = v[2];
    res[16][1] = v[0];
    res[16][2] = v[1];
    res[17][0] = -v[2];
    res[17][1] = -v[0];
    res[17][2] = -v[1];
    res[18][0] = v[2];
    res[18][1] = v[0];
    res[18][2] = v[1];
    res[19][0] = -v[2];
    res[19][1] = -v[0];
    res[19][2] = -v[1];
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    res[28][0] = v[2];
    res[28][1] = -v[0];
    res[28][2] = -v[1];
    res[29][0] = -v[2];
    res[29][1] = v[0];
    res[29][2] = v[1];
    res[30][0] = v[2];
    res[30][1] = -v[0];
    res[30][2] = -v[1];
    res[31][0] = -v[2];
    res[31][1] = v[0];
    res[31][2] = v[1];
    res[32][0] = -v[1];
    res[32][1] = -v[2];
    res[32][2] = v[0];
    res[33][0] = v[1];
    res[33][1] = v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[1];
    res[34][1] = -v[2];
    res[34][2] = v[0];
    res[35][0] = v[1];
    res[35][1] = v[2];
    res[35][2] = -v[0];
    res[36][0] = -v[1];
    res[36][1] = -v[2];
    res[36][2] = v[0];
    res[37][0] = v[1];
    res[37][1] = v[2];
    res[37][2] = -v[0];
    res[38][0] = -v[1];
    res[38][1] = -v[2];
    res[38][2] = v[0];
    res[39][0] = v[1];
    res[39][1] = v[2];
    res[39][2] = -v[0];
    res[40][0] = -v[2];
    res[40][1] = -v[0];
    res[40][2] = v[1];
    res[41][0] = v[2];
    res[41][1] = v[0];
    res[41][2] = -v[1];
    res[42][0] = -v[2];
    res[42][1] = -v[0];
    res[42][2] = v[1];
    res[43][0] = v[2];
    res[43][1] = v[0];
    res[43][2] = -v[1];
    res[44][0] = -v[2];
    res[44][1] = -v[0];
    res[44][2] = v[1];
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = -v[1];
    res[46][0] = -v[2];
    res[46][1] = -v[0];
    res[46][2] = v[1];
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = -v[1];
    res[48][0] = -v[1];
    res[48][1] = v[2];
    res[48][2] = -v[0];
    res[49][0] = v[1];
    res[49][1] = -v[2];
    res[49][2] = v[0];
    res[50][0] = -v[1];
    res[50][1] = v[2];
    res[50][2] = -v[0];
    res[51][0] = v[1];
    res[51][1] = -v[2];
    res[51][2] = v[0];
    res[52][0] = -v[1];
    res[52][1] = v[2];
    res[52][2] = -v[0];
    res[53][0] = v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    res[54][0] = -v[1];
    res[54][1] = v[2];
    res[54][2] = -v[0];
    res[55][0] = v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    res[56][0] = v[1];
    res[56][1] = -v[2];
    res[56][2] = -v[0];
    res[57][0] = -v[1];
    res[57][1] = v[2];
    res[57][2] = v[0];
    res[58][0] = v[1];
    res[58][1] = -v[2];
    res[58][2] = -v[0];
    res[59][0] = -v[1];
    res[59][1] = v[2];
    res[59][2] = v[0];
    res[60][0] = v[1];
    res[60][1] = -v[2];
    res[60][2] = -v[0];
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = v[0];
    res[62][0] = v[1];
    res[62][1] = -v[2];
    res[62][2] = -v[0];
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = v[0];
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = v[2];
    res[65][1] = -v[0];
    res[65][2] = v[1];
    res[66][0] = -v[2];
    res[66][1] = v[0];
    res[66][2] = -v[1];
    res[67][0] = v[2];
    res[67][1] = -v[0];
    res[67][2] = v[1];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    res[72][0] = -v[0];
    res[72][1] = -v[1];
    res[72][2] = v[2];
    res[73][0] = v[0];
    res[73][1] = v[1];
    res[73][2] = -v[2];
    res[74][0] = -v[0];
    res[74][1] = -v[1];
    res[74][2] = v[2];
    res[75][0] = v[0];
    res[75][1] = v[1];
    res[75][2] = -v[2];
    res[76][0] = -v[0];
    res[76][1] = -v[1];
    res[76][2] = v[2];
    res[77][0] = v[0];
    res[77][1] = v[1];
    res[77][2] = -v[2];
    res[78][0] = -v[0];
    res[78][1] = -v[1];
    res[78][2] = v[2];
    res[79][0] = v[0];
    res[79][1] = v[1];
    res[79][2] = -v[2];
    res[80][0] = v[0];
    res[80][1] = -v[1];
    res[80][2] = -v[2];
    res[81][0] = -v[0];
    res[81][1] = v[1];
    res[81][2] = v[2];
    res[82][0] = v[0];
    res[82][1] = -v[1];
    res[82][2] = -v[2];
    res[83][0] = -v[0];
    res[83][1] = v[1];
    res[83][2] = v[2];
    res[84][0] = v[0];
    res[84][1] = -v[1];
    res[84][2] = -v[2];
    res[85][0] = -v[0];
    res[85][1] = v[1];
    res[85][2] = v[2];
    res[86][0] = v[0];
    res[86][1] = -v[1];
    res[86][2] = -v[2];
    res[87][0] = -v[0];
    res[87][1] = v[1];
    res[87][2] = v[2];
    res[88][0] = -v[0];
    res[88][1] = v[1];
    res[88][2] = -v[2];
    res[89][0] = v[0];
    res[89][1] = -v[1];
    res[89][2] = v[2];
    res[90][0] = -v[0];
    res[90][1] = v[1];
    res[90][2] = -v[2];
    res[91][0] = v[0];
    res[91][1] = -v[1];
    res[91][2] = v[2];
    res[92][0] = -v[0];
    res[92][1] = v[1];
    res[92][2] = -v[2];
    res[93][0] = v[0];
    res[93][1] = -v[1];
    res[93][2] = v[2];
    res[94][0] = -v[0];
    res[94][1] = v[1];
    res[94][2] = -v[2];
    res[95][0] = v[0];
    res[95][1] = -v[1];
    res[95][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[2];
    res[11][2] = -v[0];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[2];
    res[12][2] = v[0];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = -v[0];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = v[2];
    res[14][2] = v[0];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = -v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = v[2];
    res[16][1] = v[0];
    res[16][2] = v[1];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = -v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = v[2];
    res[18][1] = v[0];
    res[18][2] = v[1];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = -v[2];
    res[19][1] = -v[0];
    res[19][2] = -v[1];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    phase[20] = (v[0]+v[2])*1./2;
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    phase[21] = (v[0]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] =  0;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    phase[26] = (v[1]+v[2])*1./2;
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    phase[27] = (v[1]+v[2])*1./2;
    res[28][0] = v[2];
    res[28][1] = -v[0];
    res[28][2] = -v[1];
    phase[28] = (v[0]+v[2])*1./2;
    res[29][0] = -v[2];
    res[29][1] = v[0];
    res[29][2] = v[1];
    phase[29] = (v[0]+v[2])*1./2;
    res[30][0] = v[2];
    res[30][1] = -v[0];
    res[30][2] = -v[1];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = -v[2];
    res[31][1] = v[0];
    res[31][2] = v[1];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = -v[1];
    res[32][1] = -v[2];
    res[32][2] = v[0];
    phase[32] =  0;
    res[33][0] = v[1];
    res[33][1] = v[2];
    res[33][2] = -v[0];
    phase[33] =  0;
    res[34][0] = -v[1];
    res[34][1] = -v[2];
    res[34][2] = v[0];
    phase[34] = (v[1]+v[2])*1./2;
    res[35][0] = v[1];
    res[35][1] = v[2];
    res[35][2] = -v[0];
    phase[35] = (v[1]+v[2])*1./2;
    res[36][0] = -v[1];
    res[36][1] = -v[2];
    res[36][2] = v[0];
    phase[36] = (v[0]+v[2])*1./2;
    res[37][0] = v[1];
    res[37][1] = v[2];
    res[37][2] = -v[0];
    phase[37] = (v[0]+v[2])*1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[2];
    res[38][2] = v[0];
    phase[38] = (v[0]+v[1])*1./2;
    res[39][0] = v[1];
    res[39][1] = v[2];
    res[39][2] = -v[0];
    phase[39] = (v[0]+v[1])*1./2;
    res[40][0] = -v[2];
    res[40][1] = -v[0];
    res[40][2] = v[1];
    phase[40] =  0;
    res[41][0] = v[2];
    res[41][1] = v[0];
    res[41][2] = -v[1];
    phase[41] =  0;
    res[42][0] = -v[2];
    res[42][1] = -v[0];
    res[42][2] = v[1];
    phase[42] = (v[1]+v[2])*1./2;
    res[43][0] = v[2];
    res[43][1] = v[0];
    res[43][2] = -v[1];
    phase[43] = (v[1]+v[2])*1./2;
    res[44][0] = -v[2];
    res[44][1] = -v[0];
    res[44][2] = v[1];
    phase[44] = (v[0]+v[2])*1./2;
    res[45][0] = v[2];
    res[45][1] = v[0];
    res[45][2] = -v[1];
    phase[45] = (v[0]+v[2])*1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[1])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[0];
    res[47][2] = -v[1];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = -v[1];
    res[48][1] = v[2];
    res[48][2] = -v[0];
    phase[48] =  0;
    res[49][0] = v[1];
    res[49][1] = -v[2];
    res[49][2] = v[0];
    phase[49] =  0;
    res[50][0] = -v[1];
    res[50][1] = v[2];
    res[50][2] = -v[0];
    phase[50] = (v[1]+v[2])*1./2;
    res[51][0] = v[1];
    res[51][1] = -v[2];
    res[51][2] = v[0];
    phase[51] = (v[1]+v[2])*1./2;
    res[52][0] = -v[1];
    res[52][1] = v[2];
    res[52][2] = -v[0];
    phase[52] = (v[0]+v[2])*1./2;
    res[53][0] = v[1];
    res[53][1] = -v[2];
    res[53][2] = v[0];
    phase[53] = (v[0]+v[2])*1./2;
    res[54][0] = -v[1];
    res[54][1] = v[2];
    res[54][2] = -v[0];
    phase[54] = (v[0]+v[1])*1./2;
    res[55][0] = v[1];
    res[55][1] = -v[2];
    res[55][2] = v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = v[1];
    res[56][1] = -v[2];
    res[56][2] = -v[0];
    phase[56] =  0;
    res[57][0] = -v[1];
    res[57][1] = v[2];
    res[57][2] = v[0];
    phase[57] =  0;
    res[58][0] = v[1];
    res[58][1] = -v[2];
    res[58][2] = -v[0];
    phase[58] = (v[1]+v[2])*1./2;
    res[59][0] = -v[1];
    res[59][1] = v[2];
    res[59][2] = v[0];
    phase[59] = (v[1]+v[2])*1./2;
    res[60][0] = v[1];
    res[60][1] = -v[2];
    res[60][2] = -v[0];
    phase[60] = (v[0]+v[2])*1./2;
    res[61][0] = -v[1];
    res[61][1] = v[2];
    res[61][2] = v[0];
    phase[61] = (v[0]+v[2])*1./2;
    res[62][0] = v[1];
    res[62][1] = -v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[1])*1./2;
    res[63][0] = -v[1];
    res[63][1] = v[2];
    res[63][2] = v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    phase[64] =  0;
    res[65][0] = v[2];
    res[65][1] = -v[0];
    res[65][2] = v[1];
    phase[65] =  0;
    res[66][0] = -v[2];
    res[66][1] = v[0];
    res[66][2] = -v[1];
    phase[66] = (v[1]+v[2])*1./2;
    res[67][0] = v[2];
    res[67][1] = -v[0];
    res[67][2] = v[1];
    phase[67] = (v[1]+v[2])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] = (v[0]+v[2])*1./2;
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    phase[69] = (v[0]+v[2])*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[1])*1./2;
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = -v[0];
    res[72][1] = -v[1];
    res[72][2] = v[2];
    phase[72] =  0;
    res[73][0] = v[0];
    res[73][1] = v[1];
    res[73][2] = -v[2];
    phase[73] =  0;
    res[74][0] = -v[0];
    res[74][1] = -v[1];
    res[74][2] = v[2];
    phase[74] = (v[1]+v[2])*1./2;
    res[75][0] = v[0];
    res[75][1] = v[1];
    res[75][2] = -v[2];
    phase[75] = (v[1]+v[2])*1./2;
    res[76][0] = -v[0];
    res[76][1] = -v[1];
    res[76][2] = v[2];
    phase[76] = (v[0]+v[2])*1./2;
    res[77][0] = v[0];
    res[77][1] = v[1];
    res[77][2] = -v[2];
    phase[77] = (v[0]+v[2])*1./2;
    res[78][0] = -v[0];
    res[78][1] = -v[1];
    res[78][2] = v[2];
    phase[78] = (v[0]+v[1])*1./2;
    res[79][0] = v[0];
    res[79][1] = v[1];
    res[79][2] = -v[2];
    phase[79] = (v[0]+v[1])*1./2;
    res[80][0] = v[0];
    res[80][1] = -v[1];
    res[80][2] = -v[2];
    phase[80] =  0;
    res[81][0] = -v[0];
    res[81][1] = v[1];
    res[81][2] = v[2];
    phase[81] =  0;
    res[82][0] = v[0];
    res[82][1] = -v[1];
    res[82][2] = -v[2];
    phase[82] = (v[1]+v[2])*1./2;
    res[83][0] = -v[0];
    res[83][1] = v[1];
    res[83][2] = v[2];
    phase[83] = (v[1]+v[2])*1./2;
    res[84][0] = v[0];
    res[84][1] = -v[1];
    res[84][2] = -v[2];
    phase[84] = (v[0]+v[2])*1./2;
    res[85][0] = -v[0];
    res[85][1] = v[1];
    res[85][2] = v[2];
    phase[85] = (v[0]+v[2])*1./2;
    res[86][0] = v[0];
    res[86][1] = -v[1];
    res[86][2] = -v[2];
    phase[86] = (v[0]+v[1])*1./2;
    res[87][0] = -v[0];
    res[87][1] = v[1];
    res[87][2] = v[2];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = -v[0];
    res[88][1] = v[1];
    res[88][2] = -v[2];
    phase[88] =  0;
    res[89][0] = v[0];
    res[89][1] = -v[1];
    res[89][2] = v[2];
    phase[89] =  0;
    res[90][0] = -v[0];
    res[90][1] = v[1];
    res[90][2] = -v[2];
    phase[90] = (v[1]+v[2])*1./2;
    res[91][0] = v[0];
    res[91][1] = -v[1];
    res[91][2] = v[2];
    phase[91] = (v[1]+v[2])*1./2;
    res[92][0] = -v[0];
    res[92][1] = v[1];
    res[92][2] = -v[2];
    phase[92] = (v[0]+v[2])*1./2;
    res[93][0] = v[0];
    res[93][1] = -v[1];
    res[93][2] = v[2];
    phase[93] = (v[0]+v[2])*1./2;
    res[94][0] = -v[0];
    res[94][1] = v[1];
    res[94][2] = -v[2];
    phase[94] = (v[0]+v[1])*1./2;
    res[95][0] = v[0];
    res[95][1] = -v[1];
    res[95][2] = v[2];
    phase[95] = (v[0]+v[1])*1./2;
  }
  static const short size=96;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fm_3c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[1];
    res[8][1] = v[0];
    res[8][2] = v[2]+1./2;
    res[9][0] = v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+1./2;
    res[10][0] = -v[1];
    res[10][1] = v[0]+1./2;
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[2];
    res[12][0] = -v[1]+1./2;
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1]+1./2;
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0]+1./2;
    res[14][2] = v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[2]+1./2;
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1]+1./2;
    res[18][2] = v[2]+1./2;
    res[19][0] = v[0];
    res[19][1] = v[1]+1./2;
    res[19][2] = -v[2]+1./2;
    res[20][0] = -v[0]+1./2;
    res[20][1] = -v[1];
    res[20][2] = v[2]+1./2;
    res[21][0] = v[0]+1./2;
    res[21][1] = v[1];
    res[21][2] = -v[2]+1./2;
    res[22][0] = -v[0]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = v[2];
    res[23][0] = v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = v[1];
    res[24][1] = -v[0];
    res[24][2] = v[2]+1./2;
    res[25][0] = -v[1];
    res[25][1] = v[0];
    res[25][2] = -v[2]+1./2;
    res[26][0] = v[1];
    res[26][1] = -v[0]+1./2;
    res[26][2] = v[2];
    res[27][0] = -v[1];
    res[27][1] = v[0]+1./2;
    res[27][2] = -v[2];
    res[28][0] = v[1]+1./2;
    res[28][1] = -v[0];
    res[28][2] = v[2];
    res[29][0] = -v[1]+1./2;
    res[29][1] = v[0];
    res[29][2] = -v[2];
    res[30][0] = v[1]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[2]+1./2;
    res[31][0] = -v[1]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[2]+1./2;
    res[32][0] = v[0];
    res[32][1] = -v[2];
    res[32][2] = v[1]+1./2;
    res[33][0] = -v[0];
    res[33][1] = v[2];
    res[33][2] = -v[1]+1./2;
    res[34][0] = v[0];
    res[34][1] = -v[2]+1./2;
    res[34][2] = v[1];
    res[35][0] = -v[0];
    res[35][1] = v[2]+1./2;
    res[35][2] = -v[1];
    res[36][0] = v[0]+1./2;
    res[36][1] = -v[2];
    res[36][2] = v[1];
    res[37][0] = -v[0]+1./2;
    res[37][1] = v[2];
    res[37][2] = -v[1];
    res[38][0] = v[0]+1./2;
    res[38][1] = -v[2]+1./2;
    res[38][2] = v[1]+1./2;
    res[39][0] = -v[0]+1./2;
    res[39][1] = v[2]+1./2;
    res[39][2] = -v[1]+1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1]+1./2;
    res[42][2] = -v[2]+1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1]+1./2;
    res[43][2] = v[2]+1./2;
    res[44][0] = v[0]+1./2;
    res[44][1] = -v[1];
    res[44][2] = -v[2]+1./2;
    res[45][0] = -v[0]+1./2;
    res[45][1] = v[1];
    res[45][2] = v[2]+1./2;
    res[46][0] = v[0]+1./2;
    res[46][1] = -v[1]+1./2;
    res[46][2] = -v[2];
    res[47][0] = -v[0]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = v[2];
    res[48][2] = -v[1]+1./2;
    res[49][0] = -v[0];
    res[49][1] = -v[2];
    res[49][2] = v[1]+1./2;
    res[50][0] = v[0];
    res[50][1] = v[2]+1./2;
    res[50][2] = -v[1];
    res[51][0] = -v[0];
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[1];
    res[52][0] = v[0]+1./2;
    res[52][1] = v[2];
    res[52][2] = -v[1];
    res[53][0] = -v[0]+1./2;
    res[53][1] = -v[2];
    res[53][2] = v[1];
    res[54][0] = v[0]+1./2;
    res[54][1] = v[2]+1./2;
    res[54][2] = -v[1]+1./2;
    res[55][0] = -v[0]+1./2;
    res[55][1] = -v[2]+1./2;
    res[55][2] = v[1]+1./2;
    res[56][0] = v[2];
    res[56][1] = v[1];
    res[56][2] = -v[0]+1./2;
    res[57][0] = -v[2];
    res[57][1] = -v[1];
    res[57][2] = v[0]+1./2;
    res[58][0] = v[2];
    res[58][1] = v[1]+1./2;
    res[58][2] = -v[0];
    res[59][0] = -v[2];
    res[59][1] = -v[1]+1./2;
    res[59][2] = v[0];
    res[60][0] = v[2]+1./2;
    res[60][1] = v[1];
    res[60][2] = -v[0];
    res[61][0] = -v[2]+1./2;
    res[61][1] = -v[1];
    res[61][2] = v[0];
    res[62][0] = v[2]+1./2;
    res[62][1] = v[1]+1./2;
    res[62][2] = -v[0]+1./2;
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[1]+1./2;
    res[63][2] = v[0]+1./2;
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1]+1./2;
    res[66][2] = -v[2]+1./2;
    res[67][0] = v[0];
    res[67][1] = -v[1]+1./2;
    res[67][2] = v[2]+1./2;
    res[68][0] = -v[0]+1./2;
    res[68][1] = v[1];
    res[68][2] = -v[2]+1./2;
    res[69][0] = v[0]+1./2;
    res[69][1] = -v[1];
    res[69][2] = v[2]+1./2;
    res[70][0] = -v[0]+1./2;
    res[70][1] = v[1]+1./2;
    res[70][2] = -v[2];
    res[71][0] = v[0]+1./2;
    res[71][1] = -v[1]+1./2;
    res[71][2] = v[2];
    res[72][0] = -v[2];
    res[72][1] = v[1];
    res[72][2] = v[0]+1./2;
    res[73][0] = v[2];
    res[73][1] = -v[1];
    res[73][2] = -v[0]+1./2;
    res[74][0] = -v[2];
    res[74][1] = v[1]+1./2;
    res[74][2] = v[0];
    res[75][0] = v[2];
    res[75][1] = -v[1]+1./2;
    res[75][2] = -v[0];
    res[76][0] = -v[2]+1./2;
    res[76][1] = v[1];
    res[76][2] = v[0];
    res[77][0] = v[2]+1./2;
    res[77][1] = -v[1];
    res[77][2] = -v[0];
    res[78][0] = -v[2]+1./2;
    res[78][1] = v[1]+1./2;
    res[78][2] = v[0]+1./2;
    res[79][0] = v[2]+1./2;
    res[79][1] = -v[1]+1./2;
    res[79][2] = -v[0]+1./2;
    res[80][0] = v[2];
    res[80][1] = v[0];
    res[80][2] = v[1];
    res[81][0] = -v[2];
    res[81][1] = -v[0];
    res[81][2] = -v[1];
    res[82][0] = v[2];
    res[82][1] = v[0]+1./2;
    res[82][2] = v[1]+1./2;
    res[83][0] = -v[2];
    res[83][1] = -v[0]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = v[2]+1./2;
    res[84][1] = v[0];
    res[84][2] = v[1]+1./2;
    res[85][0] = -v[2]+1./2;
    res[85][1] = -v[0];
    res[85][2] = -v[1]+1./2;
    res[86][0] = v[2]+1./2;
    res[86][1] = v[0]+1./2;
    res[86][2] = v[1];
    res[87][0] = -v[2]+1./2;
    res[87][1] = -v[0]+1./2;
    res[87][2] = -v[1];
    res[88][0] = v[1];
    res[88][1] = v[2];
    res[88][2] = v[0];
    res[89][0] = -v[1];
    res[89][1] = -v[2];
    res[89][2] = -v[0];
    res[90][0] = v[1];
    res[90][1] = v[2]+1./2;
    res[90][2] = v[0]+1./2;
    res[91][0] = -v[1];
    res[91][1] = -v[2]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = v[1]+1./2;
    res[92][1] = v[2];
    res[92][2] = v[0]+1./2;
    res[93][0] = -v[1]+1./2;
    res[93][1] = -v[2];
    res[93][2] = -v[0]+1./2;
    res[94][0] = v[1]+1./2;
    res[94][1] = v[2]+1./2;
    res[94][2] = v[0];
    res[95][0] = -v[1]+1./2;
    res[95][1] = -v[2]+1./2;
    res[95][2] = -v[0];
    res[96][0] = -v[1];
    res[96][1] = -v[2];
    res[96][2] = v[0];
    res[97][0] = v[1];
    res[97][1] = v[2];
    res[97][2] = -v[0];
    res[98][0] = -v[1];
    res[98][1] = -v[2]+1./2;
    res[98][2] = v[0]+1./2;
    res[99][0] = v[1];
    res[99][1] = v[2]+1./2;
    res[99][2] = -v[0]+1./2;
    res[100][0] = -v[1]+1./2;
    res[100][1] = -v[2];
    res[100][2] = v[0]+1./2;
    res[101][0] = v[1]+1./2;
    res[101][1] = v[2];
    res[101][2] = -v[0]+1./2;
    res[102][0] = -v[1]+1./2;
    res[102][1] = -v[2]+1./2;
    res[102][2] = v[0];
    res[103][0] = v[1]+1./2;
    res[103][1] = v[2]+1./2;
    res[103][2] = -v[0];
    res[104][0] = v[2];
    res[104][1] = -v[0];
    res[104][2] = -v[1];
    res[105][0] = -v[2];
    res[105][1] = v[0];
    res[105][2] = v[1];
    res[106][0] = v[2];
    res[106][1] = -v[0]+1./2;
    res[106][2] = -v[1]+1./2;
    res[107][0] = -v[2];
    res[107][1] = v[0]+1./2;
    res[107][2] = v[1]+1./2;
    res[108][0] = v[2]+1./2;
    res[108][1] = -v[0];
    res[108][2] = -v[1]+1./2;
    res[109][0] = -v[2]+1./2;
    res[109][1] = v[0];
    res[109][2] = v[1]+1./2;
    res[110][0] = v[2]+1./2;
    res[110][1] = -v[0]+1./2;
    res[110][2] = -v[1];
    res[111][0] = -v[2]+1./2;
    res[111][1] = v[0]+1./2;
    res[111][2] = v[1];
    res[112][0] = -v[1];
    res[112][1] = v[2];
    res[112][2] = -v[0];
    res[113][0] = v[1];
    res[113][1] = -v[2];
    res[113][2] = v[0];
    res[114][0] = -v[1];
    res[114][1] = v[2]+1./2;
    res[114][2] = -v[0]+1./2;
    res[115][0] = v[1];
    res[115][1] = -v[2]+1./2;
    res[115][2] = v[0]+1./2;
    res[116][0] = -v[1]+1./2;
    res[116][1] = v[2];
    res[116][2] = -v[0]+1./2;
    res[117][0] = v[1]+1./2;
    res[117][1] = -v[2];
    res[117][2] = v[0]+1./2;
    res[118][0] = -v[1]+1./2;
    res[118][1] = v[2]+1./2;
    res[118][2] = -v[0];
    res[119][0] = v[1]+1./2;
    res[119][1] = -v[2]+1./2;
    res[119][2] = v[0];
    res[120][0] = -v[2];
    res[120][1] = -v[0];
    res[120][2] = v[1];
    res[121][0] = v[2];
    res[121][1] = v[0];
    res[121][2] = -v[1];
    res[122][0] = -v[2];
    res[122][1] = -v[0]+1./2;
    res[122][2] = v[1]+1./2;
    res[123][0] = v[2];
    res[123][1] = v[0]+1./2;
    res[123][2] = -v[1]+1./2;
    res[124][0] = -v[2]+1./2;
    res[124][1] = -v[0];
    res[124][2] = v[1]+1./2;
    res[125][0] = v[2]+1./2;
    res[125][1] = v[0];
    res[125][2] = -v[1]+1./2;
    res[126][0] = -v[2]+1./2;
    res[126][1] = -v[0]+1./2;
    res[126][2] = v[1];
    res[127][0] = v[2]+1./2;
    res[127][1] = v[0]+1./2;
    res[127][2] = -v[1];
    res[128][0] = -v[2];
    res[128][1] = v[0];
    res[128][2] = -v[1];
    res[129][0] = v[2];
    res[129][1] = -v[0];
    res[129][2] = v[1];
    res[130][0] = -v[2];
    res[130][1] = v[0]+1./2;
    res[130][2] = -v[1]+1./2;
    res[131][0] = v[2];
    res[131][1] = -v[0]+1./2;
    res[131][2] = v[1]+1./2;
    res[132][0] = -v[2]+1./2;
    res[132][1] = v[0];
    res[132][2] = -v[1]+1./2;
    res[133][0] = v[2]+1./2;
    res[133][1] = -v[0];
    res[133][2] = v[1]+1./2;
    res[134][0] = -v[2]+1./2;
    res[134][1] = v[0]+1./2;
    res[134][2] = -v[1];
    res[135][0] = v[2]+1./2;
    res[135][1] = -v[0]+1./2;
    res[135][2] = v[1];
    res[136][0] = v[1];
    res[136][1] = -v[2];
    res[136][2] = -v[0];
    res[137][0] = -v[1];
    res[137][1] = v[2];
    res[137][2] = v[0];
    res[138][0] = v[1];
    res[138][1] = -v[2]+1./2;
    res[138][2] = -v[0]+1./2;
    res[139][0] = -v[1];
    res[139][1] = v[2]+1./2;
    res[139][2] = v[0]+1./2;
    res[140][0] = v[1]+1./2;
    res[140][1] = -v[2];
    res[140][2] = -v[0]+1./2;
    res[141][0] = -v[1]+1./2;
    res[141][1] = v[2];
    res[141][2] = v[0]+1./2;
    res[142][0] = v[1]+1./2;
    res[142][1] = -v[2]+1./2;
    res[142][2] = -v[0];
    res[143][0] = -v[1]+1./2;
    res[143][1] = v[2]+1./2;
    res[143][2] = v[0];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2]+1./2;
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2]+1./2;
    res[146][0] = v[1];
    res[146][1] = v[0]+1./2;
    res[146][2] = -v[2];
    res[147][0] = -v[1];
    res[147][1] = -v[0]+1./2;
    res[147][2] = v[2];
    res[148][0] = v[1]+1./2;
    res[148][1] = v[0];
    res[148][2] = -v[2];
    res[149][0] = -v[1]+1./2;
    res[149][1] = -v[0];
    res[149][2] = v[2];
    res[150][0] = v[1]+1./2;
    res[150][1] = v[0]+1./2;
    res[150][2] = -v[2]+1./2;
    res[151][0] = -v[1]+1./2;
    res[151][1] = -v[0]+1./2;
    res[151][2] = v[2]+1./2;
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2]+1./2;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2]+1./2;
    res[154][0] = -v[1];
    res[154][1] = -v[0]+1./2;
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0]+1./2;
    res[155][2] = v[2];
    res[156][0] = -v[1]+1./2;
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1]+1./2;
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1]+1./2;
    res[158][1] = -v[0]+1./2;
    res[158][2] = -v[2]+1./2;
    res[159][0] = v[1]+1./2;
    res[159][1] = v[0]+1./2;
    res[159][2] = v[2]+1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1]+1./2;
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1]+1./2;
    res[162][0] = -v[0];
    res[162][1] = v[2]+1./2;
    res[162][2] = v[1];
    res[163][0] = v[0];
    res[163][1] = -v[2]+1./2;
    res[163][2] = -v[1];
    res[164][0] = -v[0]+1./2;
    res[164][1] = v[2];
    res[164][2] = v[1];
    res[165][0] = v[0]+1./2;
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    res[166][0] = -v[0]+1./2;
    res[166][1] = v[2]+1./2;
    res[166][2] = v[1]+1./2;
    res[167][0] = v[0]+1./2;
    res[167][1] = -v[2]+1./2;
    res[167][2] = -v[1]+1./2;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1]+1./2;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1]+1./2;
    res[170][0] = -v[0];
    res[170][1] = -v[2]+1./2;
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2]+1./2;
    res[171][2] = v[1];
    res[172][0] = -v[0]+1./2;
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0]+1./2;
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0]+1./2;
    res[174][1] = -v[2]+1./2;
    res[174][2] = -v[1]+1./2;
    res[175][0] = v[0]+1./2;
    res[175][1] = v[2]+1./2;
    res[175][2] = v[1]+1./2;
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0]+1./2;
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0]+1./2;
    res[178][0] = v[2];
    res[178][1] = -v[1]+1./2;
    res[178][2] = v[0];
    res[179][0] = -v[2];
    res[179][1] = v[1]+1./2;
    res[179][2] = -v[0];
    res[180][0] = v[2]+1./2;
    res[180][1] = -v[1];
    res[180][2] = v[0];
    res[181][0] = -v[2]+1./2;
    res[181][1] = v[1];
    res[181][2] = -v[0];
    res[182][0] = v[2]+1./2;
    res[182][1] = -v[1]+1./2;
    res[182][2] = v[0]+1./2;
    res[183][0] = -v[2]+1./2;
    res[183][1] = v[1]+1./2;
    res[183][2] = -v[0]+1./2;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0]+1./2;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0]+1./2;
    res[186][0] = -v[2];
    res[186][1] = -v[1]+1./2;
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1]+1./2;
    res[187][2] = v[0];
    res[188][0] = -v[2]+1./2;
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2]+1./2;
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2]+1./2;
    res[190][1] = -v[1]+1./2;
    res[190][2] = -v[0]+1./2;
    res[191][0] = v[2]+1./2;
    res[191][1] = v[1]+1./2;
    res[191][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    phase[16] =  0;
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] =  0;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    phase[20] = (v[0]+v[2])*1./2;
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    phase[21] = (v[0]+v[2])*1./2;
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    phase[24] = v[2]*1./2;
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    phase[25] = v[2]*1./2;
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    phase[26] = v[1]*1./2;
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    phase[27] = v[1]*1./2;
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    phase[28] = v[0]*1./2;
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    phase[29] = v[0]*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    phase[30] = (v[0]+v[1]+v[2])*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    phase[32] = v[2]*1./2;
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    phase[33] = v[2]*1./2;
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    phase[34] = v[1]*1./2;
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    phase[35] = v[1]*1./2;
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    phase[36] = v[0]*1./2;
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    phase[37] = v[0]*1./2;
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    phase[38] = (v[0]+v[1]+v[2])*1./2;
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] =  0;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] =  0;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[1]+v[2])*1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[1]+v[2])*1./2;
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    phase[44] = (v[0]+v[2])*1./2;
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    phase[45] = (v[0]+v[2])*1./2;
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    phase[46] = (v[0]+v[1])*1./2;
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    phase[48] = v[2]*1./2;
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    phase[49] = v[2]*1./2;
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    phase[50] = v[1]*1./2;
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    phase[51] = v[1]*1./2;
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    phase[52] = v[0]*1./2;
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    phase[53] = v[0]*1./2;
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    phase[54] = (v[0]+v[1]+v[2])*1./2;
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    phase[55] = (v[0]+v[1]+v[2])*1./2;
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    phase[56] = v[2]*1./2;
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    phase[57] = v[2]*1./2;
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    phase[58] = v[1]*1./2;
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    phase[59] = v[1]*1./2;
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    phase[60] = v[0]*1./2;
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    phase[61] = v[0]*1./2;
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    phase[62] = (v[0]+v[1]+v[2])*1./2;
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1]+v[2])*1./2;
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    phase[64] =  0;
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    phase[65] =  0;
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    phase[66] = (v[1]+v[2])*1./2;
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    phase[67] = (v[1]+v[2])*1./2;
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    phase[68] = (v[0]+v[2])*1./2;
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    phase[69] = (v[0]+v[2])*1./2;
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    phase[70] = (v[0]+v[1])*1./2;
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    phase[72] = v[2]*1./2;
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    phase[73] = v[2]*1./2;
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    phase[74] = v[1]*1./2;
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    phase[75] = v[1]*1./2;
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    phase[76] = v[0]*1./2;
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    phase[77] = v[0]*1./2;
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    phase[78] = (v[0]+v[1]+v[2])*1./2;
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    phase[79] = (v[0]+v[1]+v[2])*1./2;
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    phase[80] =  0;
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    phase[81] =  0;
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    phase[82] = (v[1]+v[2])*1./2;
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    phase[83] = (v[1]+v[2])*1./2;
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    phase[84] = (v[0]+v[2])*1./2;
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    phase[85] = (v[0]+v[2])*1./2;
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    phase[86] = (v[0]+v[1])*1./2;
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    phase[89] =  0;
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    phase[90] = (v[1]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    phase[91] = (v[1]+v[2])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    phase[92] = (v[0]+v[2])*1./2;
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    phase[93] = (v[0]+v[2])*1./2;
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    phase[94] = (v[0]+v[1])*1./2;
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    phase[95] = (v[0]+v[1])*1./2;
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    phase[96] =  0;
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    phase[97] =  0;
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    phase[98] = (v[1]+v[2])*1./2;
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    phase[99] = (v[1]+v[2])*1./2;
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    phase[100] = (v[0]+v[2])*1./2;
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    phase[101] = (v[0]+v[2])*1./2;
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    phase[102] = (v[0]+v[1])*1./2;
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    phase[103] = (v[0]+v[1])*1./2;
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    phase[104] =  0;
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    phase[105] =  0;
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    phase[106] = (v[1]+v[2])*1./2;
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    phase[107] = (v[1]+v[2])*1./2;
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    phase[108] = (v[0]+v[2])*1./2;
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    phase[109] = (v[0]+v[2])*1./2;
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    phase[110] = (v[0]+v[1])*1./2;
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    phase[111] = (v[0]+v[1])*1./2;
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    phase[112] =  0;
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    phase[113] =  0;
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    phase[114] = (v[1]+v[2])*1./2;
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    phase[115] = (v[1]+v[2])*1./2;
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    phase[116] = (v[0]+v[2])*1./2;
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    phase[117] = (v[0]+v[2])*1./2;
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    phase[118] = (v[0]+v[1])*1./2;
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    phase[119] = (v[0]+v[1])*1./2;
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    phase[120] =  0;
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    phase[121] =  0;
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    phase[122] = (v[1]+v[2])*1./2;
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    phase[123] = (v[1]+v[2])*1./2;
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    phase[124] = (v[0]+v[2])*1./2;
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    phase[125] = (v[0]+v[2])*1./2;
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    phase[126] = (v[0]+v[1])*1./2;
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    phase[127] = (v[0]+v[1])*1./2;
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    phase[128] =  0;
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    phase[129] =  0;
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    phase[130] = (v[1]+v[2])*1./2;
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    phase[131] = (v[1]+v[2])*1./2;
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    phase[132] = (v[0]+v[2])*1./2;
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    phase[133] = (v[0]+v[2])*1./2;
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    phase[134] = (v[0]+v[1])*1./2;
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    phase[135] = (v[0]+v[1])*1./2;
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    phase[136] =  0;
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    phase[137] =  0;
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    phase[138] = (v[1]+v[2])*1./2;
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    phase[139] = (v[1]+v[2])*1./2;
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    phase[140] = (v[0]+v[2])*1./2;
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    phase[141] = (v[0]+v[2])*1./2;
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    phase[142] = (v[0]+v[1])*1./2;
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    phase[143] = (v[0]+v[1])*1./2;
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    phase[144] = v[2]*1./2;
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    phase[145] = v[2]*1./2;
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    phase[146] = v[1]*1./2;
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    phase[147] = v[1]*1./2;
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    phase[148] = v[0]*1./2;
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    phase[149] = v[0]*1./2;
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    phase[150] = (v[0]+v[1]+v[2])*1./2;
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    phase[151] = (v[0]+v[1]+v[2])*1./2;
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    phase[152] = v[2]*1./2;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    phase[153] = v[2]*1./2;
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    phase[154] = v[1]*1./2;
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    phase[155] = v[1]*1./2;
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    phase[156] = v[0]*1./2;
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    phase[157] = v[0]*1./2;
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    phase[158] = (v[0]+v[1]+v[2])*1./2;
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    phase[159] = (v[0]+v[1]+v[2])*1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    phase[160] = v[2]*1./2;
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    phase[161] = v[2]*1./2;
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    phase[162] = v[1]*1./2;
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    phase[163] = v[1]*1./2;
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    phase[164] = v[0]*1./2;
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    phase[165] = v[0]*1./2;
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    phase[166] = (v[0]+v[1]+v[2])*1./2;
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    phase[167] = (v[0]+v[1]+v[2])*1./2;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    phase[168] = v[2]*1./2;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    phase[169] = v[2]*1./2;
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    phase[170] = v[1]*1./2;
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    phase[171] = v[1]*1./2;
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    phase[172] = v[0]*1./2;
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    phase[173] = v[0]*1./2;
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    phase[174] = (v[0]+v[1]+v[2])*1./2;
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    phase[175] = (v[0]+v[1]+v[2])*1./2;
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    phase[176] = v[2]*1./2;
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    phase[177] = v[2]*1./2;
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    phase[178] = v[1]*1./2;
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    phase[179] = v[1]*1./2;
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    phase[180] = v[0]*1./2;
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    phase[181] = v[0]*1./2;
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    phase[182] = (v[0]+v[1]+v[2])*1./2;
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    phase[183] = (v[0]+v[1]+v[2])*1./2;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    phase[184] = v[2]*1./2;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    phase[185] = v[2]*1./2;
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    phase[186] = v[1]*1./2;
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    phase[187] = v[1]*1./2;
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    phase[188] = v[0]*1./2;
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    phase[189] = v[0]*1./2;
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    phase[190] = (v[0]+v[1]+v[2])*1./2;
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
    phase[191] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=192;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fm_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[1];
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[1]+1./2;
    res[12][1] = v[0];
    res[12][2] = v[2]+1./2;
    res[13][0] = v[1]+1./2;
    res[13][1] = -v[0];
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = v[0]+1./2;
    res[14][2] = v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1]+1./2;
    res[18][2] = v[2]+1./2;
    res[19][0] = v[0];
    res[19][1] = v[1]+1./2;
    res[19][2] = -v[2]+1./2;
    res[20][0] = -v[0]+1./2;
    res[20][1] = -v[1];
    res[20][2] = v[2]+1./2;
    res[21][0] = v[0]+1./2;
    res[21][1] = v[1];
    res[21][2] = -v[2]+1./2;
    res[22][0] = -v[0]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = v[2];
    res[23][0] = v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = -v[2];
    res[24][0] = v[1];
    res[24][1] = -v[0];
    res[24][2] = v[2];
    res[25][0] = -v[1];
    res[25][1] = v[0];
    res[25][2] = -v[2];
    res[26][0] = v[1];
    res[26][1] = -v[0]+1./2;
    res[26][2] = v[2]+1./2;
    res[27][0] = -v[1];
    res[27][1] = v[0]+1./2;
    res[27][2] = -v[2]+1./2;
    res[28][0] = v[1]+1./2;
    res[28][1] = -v[0];
    res[28][2] = v[2]+1./2;
    res[29][0] = -v[1]+1./2;
    res[29][1] = v[0];
    res[29][2] = -v[2]+1./2;
    res[30][0] = v[1]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[2];
    res[31][0] = -v[1]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[2];
    res[32][0] = v[0];
    res[32][1] = -v[2];
    res[32][2] = v[1];
    res[33][0] = -v[0];
    res[33][1] = v[2];
    res[33][2] = -v[1];
    res[34][0] = v[0];
    res[34][1] = -v[2]+1./2;
    res[34][2] = v[1]+1./2;
    res[35][0] = -v[0];
    res[35][1] = v[2]+1./2;
    res[35][2] = -v[1]+1./2;
    res[36][0] = v[0]+1./2;
    res[36][1] = -v[2];
    res[36][2] = v[1]+1./2;
    res[37][0] = -v[0]+1./2;
    res[37][1] = v[2];
    res[37][2] = -v[1]+1./2;
    res[38][0] = v[0]+1./2;
    res[38][1] = -v[2]+1./2;
    res[38][2] = v[1];
    res[39][0] = -v[0]+1./2;
    res[39][1] = v[2]+1./2;
    res[39][2] = -v[1];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1]+1./2;
    res[42][2] = -v[2]+1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1]+1./2;
    res[43][2] = v[2]+1./2;
    res[44][0] = v[0]+1./2;
    res[44][1] = -v[1];
    res[44][2] = -v[2]+1./2;
    res[45][0] = -v[0]+1./2;
    res[45][1] = v[1];
    res[45][2] = v[2]+1./2;
    res[46][0] = v[0]+1./2;
    res[46][1] = -v[1]+1./2;
    res[46][2] = -v[2];
    res[47][0] = -v[0]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = v[2];
    res[48][2] = -v[1];
    res[49][0] = -v[0];
    res[49][1] = -v[2];
    res[49][2] = v[1];
    res[50][0] = v[0];
    res[50][1] = v[2]+1./2;
    res[50][2] = -v[1]+1./2;
    res[51][0] = -v[0];
    res[51][1] = -v[2]+1./2;
    res[51][2] = v[1]+1./2;
    res[52][0] = v[0]+1./2;
    res[52][1] = v[2];
    res[52][2] = -v[1]+1./2;
    res[53][0] = -v[0]+1./2;
    res[53][1] = -v[2];
    res[53][2] = v[1]+1./2;
    res[54][0] = v[0]+1./2;
    res[54][1] = v[2]+1./2;
    res[54][2] = -v[1];
    res[55][0] = -v[0]+1./2;
    res[55][1] = -v[2]+1./2;
    res[55][2] = v[1];
    res[56][0] = v[2];
    res[56][1] = v[1];
    res[56][2] = -v[0];
    res[57][0] = -v[2];
    res[57][1] = -v[1];
    res[57][2] = v[0];
    res[58][0] = v[2];
    res[58][1] = v[1]+1./2;
    res[58][2] = -v[0]+1./2;
    res[59][0] = -v[2];
    res[59][1] = -v[1]+1./2;
    res[59][2] = v[0]+1./2;
    res[60][0] = v[2]+1./2;
    res[60][1] = v[1];
    res[60][2] = -v[0]+1./2;
    res[61][0] = -v[2]+1./2;
    res[61][1] = -v[1];
    res[61][2] = v[0]+1./2;
    res[62][0] = v[2]+1./2;
    res[62][1] = v[1]+1./2;
    res[62][2] = -v[0];
    res[63][0] = -v[2]+1./2;
    res[63][1] = -v[1]+1./2;
    res[63][2] = v[0];
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1]+1./2;
    res[66][2] = -v[2]+1./2;
    res[67][0] = v[0];
    res[67][1] = -v[1]+1./2;
    res[67][2] = v[2]+1./2;
    res[68][0] = -v[0]+1./2;
    res[68][1] = v[1];
    res[68][2] = -v[2]+1./2;
    res[69][0] = v[0]+1./2;
    res[69][1] = -v[1];
    res[69][2] = v[2]+1./2;
    res[70][0] = -v[0]+1./2;
    res[70][1] = v[1]+1./2;
    res[70][2] = -v[2];
    res[71][0] = v[0]+1./2;
    res[71][1] = -v[1]+1./2;
    res[71][2] = v[2];
    res[72][0] = -v[2];
    res[72][1] = v[1];
    res[72][2] = v[0];
    res[73][0] = v[2];
    res[73][1] = -v[1];
    res[73][2] = -v[0];
    res[74][0] = -v[2];
    res[74][1] = v[1]+1./2;
    res[74][2] = v[0]+1./2;
    res[75][0] = v[2];
    res[75][1] = -v[1]+1./2;
    res[75][2] = -v[0]+1./2;
    res[76][0] = -v[2]+1./2;
    res[76][1] = v[1];
    res[76][2] = v[0]+1./2;
    res[77][0] = v[2]+1./2;
    res[77][1] = -v[1];
    res[77][2] = -v[0]+1./2;
    res[78][0] = -v[2]+1./2;
    res[78][1] = v[1]+1./2;
    res[78][2] = v[0];
    res[79][0] = v[2]+1./2;
    res[79][1] = -v[1]+1./2;
    res[79][2] = -v[0];
    res[80][0] = v[2];
    res[80][1] = v[0];
    res[80][2] = v[1];
    res[81][0] = -v[2];
    res[81][1] = -v[0];
    res[81][2] = -v[1];
    res[82][0] = v[2];
    res[82][1] = v[0]+1./2;
    res[82][2] = v[1]+1./2;
    res[83][0] = -v[2];
    res[83][1] = -v[0]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = v[2]+1./2;
    res[84][1] = v[0];
    res[84][2] = v[1]+1./2;
    res[85][0] = -v[2]+1./2;
    res[85][1] = -v[0];
    res[85][2] = -v[1]+1./2;
    res[86][0] = v[2]+1./2;
    res[86][1] = v[0]+1./2;
    res[86][2] = v[1];
    res[87][0] = -v[2]+1./2;
    res[87][1] = -v[0]+1./2;
    res[87][2] = -v[1];
    res[88][0] = v[1];
    res[88][1] = v[2];
    res[88][2] = v[0];
    res[89][0] = -v[1];
    res[89][1] = -v[2];
    res[89][2] = -v[0];
    res[90][0] = v[1];
    res[90][1] = v[2]+1./2;
    res[90][2] = v[0]+1./2;
    res[91][0] = -v[1];
    res[91][1] = -v[2]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = v[1]+1./2;
    res[92][1] = v[2];
    res[92][2] = v[0]+1./2;
    res[93][0] = -v[1]+1./2;
    res[93][1] = -v[2];
    res[93][2] = -v[0]+1./2;
    res[94][0] = v[1]+1./2;
    res[94][1] = v[2]+1./2;
    res[94][2] = v[0];
    res[95][0] = -v[1]+1./2;
    res[95][1] = -v[2]+1./2;
    res[95][2] = -v[0];
    res[96][0] = -v[1];
    res[96][1] = -v[2];
    res[96][2] = v[0];
    res[97][0] = v[1];
    res[97][1] = v[2];
    res[97][2] = -v[0];
    res[98][0] = -v[1];
    res[98][1] = -v[2]+1./2;
    res[98][2] = v[0]+1./2;
    res[99][0] = v[1];
    res[99][1] = v[2]+1./2;
    res[99][2] = -v[0]+1./2;
    res[100][0] = -v[1]+1./2;
    res[100][1] = -v[2];
    res[100][2] = v[0]+1./2;
    res[101][0] = v[1]+1./2;
    res[101][1] = v[2];
    res[101][2] = -v[0]+1./2;
    res[102][0] = -v[1]+1./2;
    res[102][1] = -v[2]+1./2;
    res[102][2] = v[0];
    res[103][0] = v[1]+1./2;
    res[103][1] = v[2]+1./2;
    res[103][2] = -v[0];
    res[104][0] = v[2];
    res[104][1] = -v[0];
    res[104][2] = -v[1];
    res[105][0] = -v[2];
    res[105][1] = v[0];
    res[105][2] = v[1];
    res[106][0] = v[2];
    res[106][1] = -v[0]+1./2;
    res[106][2] = -v[1]+1./2;
    res[107][0] = -v[2];
    res[107][1] = v[0]+1./2;
    res[107][2] = v[1]+1./2;
    res[108][0] = v[2]+1./2;
    res[108][1] = -v[0];
    res[108][2] = -v[1]+1./2;
    res[109][0] = -v[2]+1./2;
    res[109][1] = v[0];
    res[109][2] = v[1]+1./2;
    res[110][0] = v[2]+1./2;
    res[110][1] = -v[0]+1./2;
    res[110][2] = -v[1];
    res[111][0] = -v[2]+1./2;
    res[111][1] = v[0]+1./2;
    res[111][2] = v[1];
    res[112][0] = -v[1];
    res[112][1] = v[2];
    res[112][2] = -v[0];
    res[113][0] = v[1];
    res[113][1] = -v[2];
    res[113][2] = v[0];
    res[114][0] = -v[1];
    res[114][1] = v[2]+1./2;
    res[114][2] = -v[0]+1./2;
    res[115][0] = v[1];
    res[115][1] = -v[2]+1./2;
    res[115][2] = v[0]+1./2;
    res[116][0] = -v[1]+1./2;
    res[116][1] = v[2];
    res[116][2] = -v[0]+1./2;
    res[117][0] = v[1]+1./2;
    res[117][1] = -v[2];
    res[117][2] = v[0]+1./2;
    res[118][0] = -v[1]+1./2;
    res[118][1] = v[2]+1./2;
    res[118][2] = -v[0];
    res[119][0] = v[1]+1./2;
    res[119][1] = -v[2]+1./2;
    res[119][2] = v[0];
    res[120][0] = -v[2];
    res[120][1] = -v[0];
    res[120][2] = v[1];
    res[121][0] = v[2];
    res[121][1] = v[0];
    res[121][2] = -v[1];
    res[122][0] = -v[2];
    res[122][1] = -v[0]+1./2;
    res[122][2] = v[1]+1./2;
    res[123][0] = v[2];
    res[123][1] = v[0]+1./2;
    res[123][2] = -v[1]+1./2;
    res[124][0] = -v[2]+1./2;
    res[124][1] = -v[0];
    res[124][2] = v[1]+1./2;
    res[125][0] = v[2]+1./2;
    res[125][1] = v[0];
    res[125][2] = -v[1]+1./2;
    res[126][0] = -v[2]+1./2;
    res[126][1] = -v[0]+1./2;
    res[126][2] = v[1];
    res[127][0] = v[2]+1./2;
    res[127][1] = v[0]+1./2;
    res[127][2] = -v[1];
    res[128][0] = -v[2];
    res[128][1] = v[0];
    res[128][2] = -v[1];
    res[129][0] = v[2];
    res[129][1] = -v[0];
    res[129][2] = v[1];
    res[130][0] = -v[2];
    res[130][1] = v[0]+1./2;
    res[130][2] = -v[1]+1./2;
    res[131][0] = v[2];
    res[131][1] = -v[0]+1./2;
    res[131][2] = v[1]+1./2;
    res[132][0] = -v[2]+1./2;
    res[132][1] = v[0];
    res[132][2] = -v[1]+1./2;
    res[133][0] = v[2]+1./2;
    res[133][1] = -v[0];
    res[133][2] = v[1]+1./2;
    res[134][0] = -v[2]+1./2;
    res[134][1] = v[0]+1./2;
    res[134][2] = -v[1];
    res[135][0] = v[2]+1./2;
    res[135][1] = -v[0]+1./2;
    res[135][2] = v[1];
    res[136][0] = v[1];
    res[136][1] = -v[2];
    res[136][2] = -v[0];
    res[137][0] = -v[1];
    res[137][1] = v[2];
    res[137][2] = v[0];
    res[138][0] = v[1];
    res[138][1] = -v[2]+1./2;
    res[138][2] = -v[0]+1./2;
    res[139][0] = -v[1];
    res[139][1] = v[2]+1./2;
    res[139][2] = v[0]+1./2;
    res[140][0] = v[1]+1./2;
    res[140][1] = -v[2];
    res[140][2] = -v[0]+1./2;
    res[141][0] = -v[1]+1./2;
    res[141][1] = v[2];
    res[141][2] = v[0]+1./2;
    res[142][0] = v[1]+1./2;
    res[142][1] = -v[2]+1./2;
    res[142][2] = -v[0];
    res[143][0] = -v[1]+1./2;
    res[143][1] = v[2]+1./2;
    res[143][2] = v[0];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    res[146][0] = v[1];
    res[146][1] = v[0]+1./2;
    res[146][2] = -v[2]+1./2;
    res[147][0] = -v[1];
    res[147][1] = -v[0]+1./2;
    res[147][2] = v[2]+1./2;
    res[148][0] = v[1]+1./2;
    res[148][1] = v[0];
    res[148][2] = -v[2]+1./2;
    res[149][0] = -v[1]+1./2;
    res[149][1] = -v[0];
    res[149][2] = v[2]+1./2;
    res[150][0] = v[1]+1./2;
    res[150][1] = v[0]+1./2;
    res[150][2] = -v[2];
    res[151][0] = -v[1]+1./2;
    res[151][1] = -v[0]+1./2;
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0]+1./2;
    res[154][2] = -v[2]+1./2;
    res[155][0] = v[1];
    res[155][1] = v[0]+1./2;
    res[155][2] = v[2]+1./2;
    res[156][0] = -v[1]+1./2;
    res[156][1] = -v[0];
    res[156][2] = -v[2]+1./2;
    res[157][0] = v[1]+1./2;
    res[157][1] = v[0];
    res[157][2] = v[2]+1./2;
    res[158][0] = -v[1]+1./2;
    res[158][1] = -v[0]+1./2;
    res[158][2] = -v[2];
    res[159][0] = v[1]+1./2;
    res[159][1] = v[0]+1./2;
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    res[162][0] = -v[0];
    res[162][1] = v[2]+1./2;
    res[162][2] = v[1]+1./2;
    res[163][0] = v[0];
    res[163][1] = -v[2]+1./2;
    res[163][2] = -v[1]+1./2;
    res[164][0] = -v[0]+1./2;
    res[164][1] = v[2];
    res[164][2] = v[1]+1./2;
    res[165][0] = v[0]+1./2;
    res[165][1] = -v[2];
    res[165][2] = -v[1]+1./2;
    res[166][0] = -v[0]+1./2;
    res[166][1] = v[2]+1./2;
    res[166][2] = v[1];
    res[167][0] = v[0]+1./2;
    res[167][1] = -v[2]+1./2;
    res[167][2] = -v[1];
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2]+1./2;
    res[170][2] = -v[1]+1./2;
    res[171][0] = v[0];
    res[171][1] = v[2]+1./2;
    res[171][2] = v[1]+1./2;
    res[172][0] = -v[0]+1./2;
    res[172][1] = -v[2];
    res[172][2] = -v[1]+1./2;
    res[173][0] = v[0]+1./2;
    res[173][1] = v[2];
    res[173][2] = v[1]+1./2;
    res[174][0] = -v[0]+1./2;
    res[174][1] = -v[2]+1./2;
    res[174][2] = -v[1];
    res[175][0] = v[0]+1./2;
    res[175][1] = v[2]+1./2;
    res[175][2] = v[1];
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    res[178][0] = v[2];
    res[178][1] = -v[1]+1./2;
    res[178][2] = v[0]+1./2;
    res[179][0] = -v[2];
    res[179][1] = v[1]+1./2;
    res[179][2] = -v[0]+1./2;
    res[180][0] = v[2]+1./2;
    res[180][1] = -v[1];
    res[180][2] = v[0]+1./2;
    res[181][0] = -v[2]+1./2;
    res[181][1] = v[1];
    res[181][2] = -v[0]+1./2;
    res[182][0] = v[2]+1./2;
    res[182][1] = -v[1]+1./2;
    res[182][2] = v[0];
    res[183][0] = -v[2]+1./2;
    res[183][1] = v[1]+1./2;
    res[183][2] = -v[0];
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1]+1./2;
    res[186][2] = -v[0]+1./2;
    res[187][0] = v[2];
    res[187][1] = v[1]+1./2;
    res[187][2] = v[0]+1./2;
    res[188][0] = -v[2]+1./2;
    res[188][1] = -v[1];
    res[188][2] = -v[0]+1./2;
    res[189][0] = v[2]+1./2;
    res[189][1] = v[1];
    res[189][2] = v[0]+1./2;
    res[190][0] = -v[2]+1./2;
    res[190][1] = -v[1]+1./2;
    res[190][2] = -v[0];
    res[191][0] = v[2]+1./2;
    res[191][1] = v[1]+1./2;
    res[191][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = -v[0];
    res[10][2] = v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[1];
    res[11][1] = v[0];
    res[11][2] = -v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = -v[0];
    res[16][1] = -v[1];
    res[16][2] = v[2];
    phase[16] =  0;
    res[17][0] = v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] =  0;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = -v[0];
    res[20][1] = -v[1];
    res[20][2] = v[2];
    phase[20] = (v[0]+v[2])*1./2;
    res[21][0] = v[0];
    res[21][1] = v[1];
    res[21][2] = -v[2];
    phase[21] = (v[0]+v[2])*1./2;
    res[22][0] = -v[0];
    res[22][1] = -v[1];
    res[22][2] = v[2];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[1];
    res[24][1] = v[0];
    res[24][2] = v[2];
    phase[24] =  0;
    res[25][0] = v[1];
    res[25][1] = -v[0];
    res[25][2] = -v[2];
    phase[25] =  0;
    res[26][0] = -v[1];
    res[26][1] = v[0];
    res[26][2] = v[2];
    phase[26] = (v[1]+v[2])*1./2;
    res[27][0] = v[1];
    res[27][1] = -v[0];
    res[27][2] = -v[2];
    phase[27] = (v[1]+v[2])*1./2;
    res[28][0] = -v[1];
    res[28][1] = v[0];
    res[28][2] = v[2];
    phase[28] = (v[0]+v[2])*1./2;
    res[29][0] = v[1];
    res[29][1] = -v[0];
    res[29][2] = -v[2];
    phase[29] = (v[0]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[0];
    res[30][2] = v[2];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[0];
    res[31][2] = -v[2];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = v[0];
    res[32][1] = v[2];
    res[32][2] = -v[1];
    phase[32] =  0;
    res[33][0] = -v[0];
    res[33][1] = -v[2];
    res[33][2] = v[1];
    phase[33] =  0;
    res[34][0] = v[0];
    res[34][1] = v[2];
    res[34][2] = -v[1];
    phase[34] = (v[1]+v[2])*1./2;
    res[35][0] = -v[0];
    res[35][1] = -v[2];
    res[35][2] = v[1];
    phase[35] = (v[1]+v[2])*1./2;
    res[36][0] = v[0];
    res[36][1] = v[2];
    res[36][2] = -v[1];
    phase[36] = (v[0]+v[2])*1./2;
    res[37][0] = -v[0];
    res[37][1] = -v[2];
    res[37][2] = v[1];
    phase[37] = (v[0]+v[2])*1./2;
    res[38][0] = v[0];
    res[38][1] = v[2];
    res[38][2] = -v[1];
    phase[38] = (v[0]+v[1])*1./2;
    res[39][0] = -v[0];
    res[39][1] = -v[2];
    res[39][2] = v[1];
    phase[39] = (v[0]+v[1])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] =  0;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] =  0;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[1]+v[2])*1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[1]+v[2])*1./2;
    res[44][0] = v[0];
    res[44][1] = -v[1];
    res[44][2] = -v[2];
    phase[44] = (v[0]+v[2])*1./2;
    res[45][0] = -v[0];
    res[45][1] = v[1];
    res[45][2] = v[2];
    phase[45] = (v[0]+v[2])*1./2;
    res[46][0] = v[0];
    res[46][1] = -v[1];
    res[46][2] = -v[2];
    phase[46] = (v[0]+v[1])*1./2;
    res[47][0] = -v[0];
    res[47][1] = v[1];
    res[47][2] = v[2];
    phase[47] = (v[0]+v[1])*1./2;
    res[48][0] = v[0];
    res[48][1] = -v[2];
    res[48][2] = v[1];
    phase[48] =  0;
    res[49][0] = -v[0];
    res[49][1] = v[2];
    res[49][2] = -v[1];
    phase[49] =  0;
    res[50][0] = v[0];
    res[50][1] = -v[2];
    res[50][2] = v[1];
    phase[50] = (v[1]+v[2])*1./2;
    res[51][0] = -v[0];
    res[51][1] = v[2];
    res[51][2] = -v[1];
    phase[51] = (v[1]+v[2])*1./2;
    res[52][0] = v[0];
    res[52][1] = -v[2];
    res[52][2] = v[1];
    phase[52] = (v[0]+v[2])*1./2;
    res[53][0] = -v[0];
    res[53][1] = v[2];
    res[53][2] = -v[1];
    phase[53] = (v[0]+v[2])*1./2;
    res[54][0] = v[0];
    res[54][1] = -v[2];
    res[54][2] = v[1];
    phase[54] = (v[0]+v[1])*1./2;
    res[55][0] = -v[0];
    res[55][1] = v[2];
    res[55][2] = -v[1];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = v[1];
    res[56][2] = v[0];
    phase[56] =  0;
    res[57][0] = v[2];
    res[57][1] = -v[1];
    res[57][2] = -v[0];
    phase[57] =  0;
    res[58][0] = -v[2];
    res[58][1] = v[1];
    res[58][2] = v[0];
    phase[58] = (v[1]+v[2])*1./2;
    res[59][0] = v[2];
    res[59][1] = -v[1];
    res[59][2] = -v[0];
    phase[59] = (v[1]+v[2])*1./2;
    res[60][0] = -v[2];
    res[60][1] = v[1];
    res[60][2] = v[0];
    phase[60] = (v[0]+v[2])*1./2;
    res[61][0] = v[2];
    res[61][1] = -v[1];
    res[61][2] = -v[0];
    phase[61] = (v[0]+v[2])*1./2;
    res[62][0] = -v[2];
    res[62][1] = v[1];
    res[62][2] = v[0];
    phase[62] = (v[0]+v[1])*1./2;
    res[63][0] = v[2];
    res[63][1] = -v[1];
    res[63][2] = -v[0];
    phase[63] = (v[0]+v[1])*1./2;
    res[64][0] = -v[0];
    res[64][1] = v[1];
    res[64][2] = -v[2];
    phase[64] =  0;
    res[65][0] = v[0];
    res[65][1] = -v[1];
    res[65][2] = v[2];
    phase[65] =  0;
    res[66][0] = -v[0];
    res[66][1] = v[1];
    res[66][2] = -v[2];
    phase[66] = (v[1]+v[2])*1./2;
    res[67][0] = v[0];
    res[67][1] = -v[1];
    res[67][2] = v[2];
    phase[67] = (v[1]+v[2])*1./2;
    res[68][0] = -v[0];
    res[68][1] = v[1];
    res[68][2] = -v[2];
    phase[68] = (v[0]+v[2])*1./2;
    res[69][0] = v[0];
    res[69][1] = -v[1];
    res[69][2] = v[2];
    phase[69] = (v[0]+v[2])*1./2;
    res[70][0] = -v[0];
    res[70][1] = v[1];
    res[70][2] = -v[2];
    phase[70] = (v[0]+v[1])*1./2;
    res[71][0] = v[0];
    res[71][1] = -v[1];
    res[71][2] = v[2];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = v[2];
    res[72][1] = v[1];
    res[72][2] = -v[0];
    phase[72] =  0;
    res[73][0] = -v[2];
    res[73][1] = -v[1];
    res[73][2] = v[0];
    phase[73] =  0;
    res[74][0] = v[2];
    res[74][1] = v[1];
    res[74][2] = -v[0];
    phase[74] = (v[1]+v[2])*1./2;
    res[75][0] = -v[2];
    res[75][1] = -v[1];
    res[75][2] = v[0];
    phase[75] = (v[1]+v[2])*1./2;
    res[76][0] = v[2];
    res[76][1] = v[1];
    res[76][2] = -v[0];
    phase[76] = (v[0]+v[2])*1./2;
    res[77][0] = -v[2];
    res[77][1] = -v[1];
    res[77][2] = v[0];
    phase[77] = (v[0]+v[2])*1./2;
    res[78][0] = v[2];
    res[78][1] = v[1];
    res[78][2] = -v[0];
    phase[78] = (v[0]+v[1])*1./2;
    res[79][0] = -v[2];
    res[79][1] = -v[1];
    res[79][2] = v[0];
    phase[79] = (v[0]+v[1])*1./2;
    res[80][0] = v[1];
    res[80][1] = v[2];
    res[80][2] = v[0];
    phase[80] =  0;
    res[81][0] = -v[1];
    res[81][1] = -v[2];
    res[81][2] = -v[0];
    phase[81] =  0;
    res[82][0] = v[1];
    res[82][1] = v[2];
    res[82][2] = v[0];
    phase[82] = (v[1]+v[2])*1./2;
    res[83][0] = -v[1];
    res[83][1] = -v[2];
    res[83][2] = -v[0];
    phase[83] = (v[1]+v[2])*1./2;
    res[84][0] = v[1];
    res[84][1] = v[2];
    res[84][2] = v[0];
    phase[84] = (v[0]+v[2])*1./2;
    res[85][0] = -v[1];
    res[85][1] = -v[2];
    res[85][2] = -v[0];
    phase[85] = (v[0]+v[2])*1./2;
    res[86][0] = v[1];
    res[86][1] = v[2];
    res[86][2] = v[0];
    phase[86] = (v[0]+v[1])*1./2;
    res[87][0] = -v[1];
    res[87][1] = -v[2];
    res[87][2] = -v[0];
    phase[87] = (v[0]+v[1])*1./2;
    res[88][0] = v[2];
    res[88][1] = v[0];
    res[88][2] = v[1];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = -v[0];
    res[89][2] = -v[1];
    phase[89] =  0;
    res[90][0] = v[2];
    res[90][1] = v[0];
    res[90][2] = v[1];
    phase[90] = (v[1]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = -v[0];
    res[91][2] = -v[1];
    phase[91] = (v[1]+v[2])*1./2;
    res[92][0] = v[2];
    res[92][1] = v[0];
    res[92][2] = v[1];
    phase[92] = (v[0]+v[2])*1./2;
    res[93][0] = -v[2];
    res[93][1] = -v[0];
    res[93][2] = -v[1];
    phase[93] = (v[0]+v[2])*1./2;
    res[94][0] = v[2];
    res[94][1] = v[0];
    res[94][2] = v[1];
    phase[94] = (v[0]+v[1])*1./2;
    res[95][0] = -v[2];
    res[95][1] = -v[0];
    res[95][2] = -v[1];
    phase[95] = (v[0]+v[1])*1./2;
    res[96][0] = v[2];
    res[96][1] = -v[0];
    res[96][2] = -v[1];
    phase[96] =  0;
    res[97][0] = -v[2];
    res[97][1] = v[0];
    res[97][2] = v[1];
    phase[97] =  0;
    res[98][0] = v[2];
    res[98][1] = -v[0];
    res[98][2] = -v[1];
    phase[98] = (v[1]+v[2])*1./2;
    res[99][0] = -v[2];
    res[99][1] = v[0];
    res[99][2] = v[1];
    phase[99] = (v[1]+v[2])*1./2;
    res[100][0] = v[2];
    res[100][1] = -v[0];
    res[100][2] = -v[1];
    phase[100] = (v[0]+v[2])*1./2;
    res[101][0] = -v[2];
    res[101][1] = v[0];
    res[101][2] = v[1];
    phase[101] = (v[0]+v[2])*1./2;
    res[102][0] = v[2];
    res[102][1] = -v[0];
    res[102][2] = -v[1];
    phase[102] = (v[0]+v[1])*1./2;
    res[103][0] = -v[2];
    res[103][1] = v[0];
    res[103][2] = v[1];
    phase[103] = (v[0]+v[1])*1./2;
    res[104][0] = -v[1];
    res[104][1] = -v[2];
    res[104][2] = v[0];
    phase[104] =  0;
    res[105][0] = v[1];
    res[105][1] = v[2];
    res[105][2] = -v[0];
    phase[105] =  0;
    res[106][0] = -v[1];
    res[106][1] = -v[2];
    res[106][2] = v[0];
    phase[106] = (v[1]+v[2])*1./2;
    res[107][0] = v[1];
    res[107][1] = v[2];
    res[107][2] = -v[0];
    phase[107] = (v[1]+v[2])*1./2;
    res[108][0] = -v[1];
    res[108][1] = -v[2];
    res[108][2] = v[0];
    phase[108] = (v[0]+v[2])*1./2;
    res[109][0] = v[1];
    res[109][1] = v[2];
    res[109][2] = -v[0];
    phase[109] = (v[0]+v[2])*1./2;
    res[110][0] = -v[1];
    res[110][1] = -v[2];
    res[110][2] = v[0];
    phase[110] = (v[0]+v[1])*1./2;
    res[111][0] = v[1];
    res[111][1] = v[2];
    res[111][2] = -v[0];
    phase[111] = (v[0]+v[1])*1./2;
    res[112][0] = -v[2];
    res[112][1] = -v[0];
    res[112][2] = v[1];
    phase[112] =  0;
    res[113][0] = v[2];
    res[113][1] = v[0];
    res[113][2] = -v[1];
    phase[113] =  0;
    res[114][0] = -v[2];
    res[114][1] = -v[0];
    res[114][2] = v[1];
    phase[114] = (v[1]+v[2])*1./2;
    res[115][0] = v[2];
    res[115][1] = v[0];
    res[115][2] = -v[1];
    phase[115] = (v[1]+v[2])*1./2;
    res[116][0] = -v[2];
    res[116][1] = -v[0];
    res[116][2] = v[1];
    phase[116] = (v[0]+v[2])*1./2;
    res[117][0] = v[2];
    res[117][1] = v[0];
    res[117][2] = -v[1];
    phase[117] = (v[0]+v[2])*1./2;
    res[118][0] = -v[2];
    res[118][1] = -v[0];
    res[118][2] = v[1];
    phase[118] = (v[0]+v[1])*1./2;
    res[119][0] = v[2];
    res[119][1] = v[0];
    res[119][2] = -v[1];
    phase[119] = (v[0]+v[1])*1./2;
    res[120][0] = -v[1];
    res[120][1] = v[2];
    res[120][2] = -v[0];
    phase[120] =  0;
    res[121][0] = v[1];
    res[121][1] = -v[2];
    res[121][2] = v[0];
    phase[121] =  0;
    res[122][0] = -v[1];
    res[122][1] = v[2];
    res[122][2] = -v[0];
    phase[122] = (v[1]+v[2])*1./2;
    res[123][0] = v[1];
    res[123][1] = -v[2];
    res[123][2] = v[0];
    phase[123] = (v[1]+v[2])*1./2;
    res[124][0] = -v[1];
    res[124][1] = v[2];
    res[124][2] = -v[0];
    phase[124] = (v[0]+v[2])*1./2;
    res[125][0] = v[1];
    res[125][1] = -v[2];
    res[125][2] = v[0];
    phase[125] = (v[0]+v[2])*1./2;
    res[126][0] = -v[1];
    res[126][1] = v[2];
    res[126][2] = -v[0];
    phase[126] = (v[0]+v[1])*1./2;
    res[127][0] = v[1];
    res[127][1] = -v[2];
    res[127][2] = v[0];
    phase[127] = (v[0]+v[1])*1./2;
    res[128][0] = v[1];
    res[128][1] = -v[2];
    res[128][2] = -v[0];
    phase[128] =  0;
    res[129][0] = -v[1];
    res[129][1] = v[2];
    res[129][2] = v[0];
    phase[129] =  0;
    res[130][0] = v[1];
    res[130][1] = -v[2];
    res[130][2] = -v[0];
    phase[130] = (v[1]+v[2])*1./2;
    res[131][0] = -v[1];
    res[131][1] = v[2];
    res[131][2] = v[0];
    phase[131] = (v[1]+v[2])*1./2;
    res[132][0] = v[1];
    res[132][1] = -v[2];
    res[132][2] = -v[0];
    phase[132] = (v[0]+v[2])*1./2;
    res[133][0] = -v[1];
    res[133][1] = v[2];
    res[133][2] = v[0];
    phase[133] = (v[0]+v[2])*1./2;
    res[134][0] = v[1];
    res[134][1] = -v[2];
    res[134][2] = -v[0];
    phase[134] = (v[0]+v[1])*1./2;
    res[135][0] = -v[1];
    res[135][1] = v[2];
    res[135][2] = v[0];
    phase[135] = (v[0]+v[1])*1./2;
    res[136][0] = -v[2];
    res[136][1] = v[0];
    res[136][2] = -v[1];
    phase[136] =  0;
    res[137][0] = v[2];
    res[137][1] = -v[0];
    res[137][2] = v[1];
    phase[137] =  0;
    res[138][0] = -v[2];
    res[138][1] = v[0];
    res[138][2] = -v[1];
    phase[138] = (v[1]+v[2])*1./2;
    res[139][0] = v[2];
    res[139][1] = -v[0];
    res[139][2] = v[1];
    phase[139] = (v[1]+v[2])*1./2;
    res[140][0] = -v[2];
    res[140][1] = v[0];
    res[140][2] = -v[1];
    phase[140] = (v[0]+v[2])*1./2;
    res[141][0] = v[2];
    res[141][1] = -v[0];
    res[141][2] = v[1];
    phase[141] = (v[0]+v[2])*1./2;
    res[142][0] = -v[2];
    res[142][1] = v[0];
    res[142][2] = -v[1];
    phase[142] = (v[0]+v[1])*1./2;
    res[143][0] = v[2];
    res[143][1] = -v[0];
    res[143][2] = v[1];
    phase[143] = (v[0]+v[1])*1./2;
    res[144][0] = v[1];
    res[144][1] = v[0];
    res[144][2] = -v[2];
    phase[144] =  0;
    res[145][0] = -v[1];
    res[145][1] = -v[0];
    res[145][2] = v[2];
    phase[145] =  0;
    res[146][0] = v[1];
    res[146][1] = v[0];
    res[146][2] = -v[2];
    phase[146] = (v[1]+v[2])*1./2;
    res[147][0] = -v[1];
    res[147][1] = -v[0];
    res[147][2] = v[2];
    phase[147] = (v[1]+v[2])*1./2;
    res[148][0] = v[1];
    res[148][1] = v[0];
    res[148][2] = -v[2];
    phase[148] = (v[0]+v[2])*1./2;
    res[149][0] = -v[1];
    res[149][1] = -v[0];
    res[149][2] = v[2];
    phase[149] = (v[0]+v[2])*1./2;
    res[150][0] = v[1];
    res[150][1] = v[0];
    res[150][2] = -v[2];
    phase[150] = (v[0]+v[1])*1./2;
    res[151][0] = -v[1];
    res[151][1] = -v[0];
    res[151][2] = v[2];
    phase[151] = (v[0]+v[1])*1./2;
    res[152][0] = -v[1];
    res[152][1] = -v[0];
    res[152][2] = -v[2];
    phase[152] =  0;
    res[153][0] = v[1];
    res[153][1] = v[0];
    res[153][2] = v[2];
    phase[153] =  0;
    res[154][0] = -v[1];
    res[154][1] = -v[0];
    res[154][2] = -v[2];
    phase[154] = (v[1]+v[2])*1./2;
    res[155][0] = v[1];
    res[155][1] = v[0];
    res[155][2] = v[2];
    phase[155] = (v[1]+v[2])*1./2;
    res[156][0] = -v[1];
    res[156][1] = -v[0];
    res[156][2] = -v[2];
    phase[156] = (v[0]+v[2])*1./2;
    res[157][0] = v[1];
    res[157][1] = v[0];
    res[157][2] = v[2];
    phase[157] = (v[0]+v[2])*1./2;
    res[158][0] = -v[1];
    res[158][1] = -v[0];
    res[158][2] = -v[2];
    phase[158] = (v[0]+v[1])*1./2;
    res[159][0] = v[1];
    res[159][1] = v[0];
    res[159][2] = v[2];
    phase[159] = (v[0]+v[1])*1./2;
    res[160][0] = -v[0];
    res[160][1] = v[2];
    res[160][2] = v[1];
    phase[160] =  0;
    res[161][0] = v[0];
    res[161][1] = -v[2];
    res[161][2] = -v[1];
    phase[161] =  0;
    res[162][0] = -v[0];
    res[162][1] = v[2];
    res[162][2] = v[1];
    phase[162] = (v[1]+v[2])*1./2;
    res[163][0] = v[0];
    res[163][1] = -v[2];
    res[163][2] = -v[1];
    phase[163] = (v[1]+v[2])*1./2;
    res[164][0] = -v[0];
    res[164][1] = v[2];
    res[164][2] = v[1];
    phase[164] = (v[0]+v[2])*1./2;
    res[165][0] = v[0];
    res[165][1] = -v[2];
    res[165][2] = -v[1];
    phase[165] = (v[0]+v[2])*1./2;
    res[166][0] = -v[0];
    res[166][1] = v[2];
    res[166][2] = v[1];
    phase[166] = (v[0]+v[1])*1./2;
    res[167][0] = v[0];
    res[167][1] = -v[2];
    res[167][2] = -v[1];
    phase[167] = (v[0]+v[1])*1./2;
    res[168][0] = -v[0];
    res[168][1] = -v[2];
    res[168][2] = -v[1];
    phase[168] =  0;
    res[169][0] = v[0];
    res[169][1] = v[2];
    res[169][2] = v[1];
    phase[169] =  0;
    res[170][0] = -v[0];
    res[170][1] = -v[2];
    res[170][2] = -v[1];
    phase[170] = (v[1]+v[2])*1./2;
    res[171][0] = v[0];
    res[171][1] = v[2];
    res[171][2] = v[1];
    phase[171] = (v[1]+v[2])*1./2;
    res[172][0] = -v[0];
    res[172][1] = -v[2];
    res[172][2] = -v[1];
    phase[172] = (v[0]+v[2])*1./2;
    res[173][0] = v[0];
    res[173][1] = v[2];
    res[173][2] = v[1];
    phase[173] = (v[0]+v[2])*1./2;
    res[174][0] = -v[0];
    res[174][1] = -v[2];
    res[174][2] = -v[1];
    phase[174] = (v[0]+v[1])*1./2;
    res[175][0] = v[0];
    res[175][1] = v[2];
    res[175][2] = v[1];
    phase[175] = (v[0]+v[1])*1./2;
    res[176][0] = v[2];
    res[176][1] = -v[1];
    res[176][2] = v[0];
    phase[176] =  0;
    res[177][0] = -v[2];
    res[177][1] = v[1];
    res[177][2] = -v[0];
    phase[177] =  0;
    res[178][0] = v[2];
    res[178][1] = -v[1];
    res[178][2] = v[0];
    phase[178] = (v[1]+v[2])*1./2;
    res[179][0] = -v[2];
    res[179][1] = v[1];
    res[179][2] = -v[0];
    phase[179] = (v[1]+v[2])*1./2;
    res[180][0] = v[2];
    res[180][1] = -v[1];
    res[180][2] = v[0];
    phase[180] = (v[0]+v[2])*1./2;
    res[181][0] = -v[2];
    res[181][1] = v[1];
    res[181][2] = -v[0];
    phase[181] = (v[0]+v[2])*1./2;
    res[182][0] = v[2];
    res[182][1] = -v[1];
    res[182][2] = v[0];
    phase[182] = (v[0]+v[1])*1./2;
    res[183][0] = -v[2];
    res[183][1] = v[1];
    res[183][2] = -v[0];
    phase[183] = (v[0]+v[1])*1./2;
    res[184][0] = -v[2];
    res[184][1] = -v[1];
    res[184][2] = -v[0];
    phase[184] =  0;
    res[185][0] = v[2];
    res[185][1] = v[1];
    res[185][2] = v[0];
    phase[185] =  0;
    res[186][0] = -v[2];
    res[186][1] = -v[1];
    res[186][2] = -v[0];
    phase[186] = (v[1]+v[2])*1./2;
    res[187][0] = v[2];
    res[187][1] = v[1];
    res[187][2] = v[0];
    phase[187] = (v[1]+v[2])*1./2;
    res[188][0] = -v[2];
    res[188][1] = -v[1];
    res[188][2] = -v[0];
    phase[188] = (v[0]+v[2])*1./2;
    res[189][0] = v[2];
    res[189][1] = v[1];
    res[189][2] = v[0];
    phase[189] = (v[0]+v[2])*1./2;
    res[190][0] = -v[2];
    res[190][1] = -v[1];
    res[190][2] = -v[0];
    phase[190] = (v[0]+v[1])*1./2;
    res[191][0] = v[2];
    res[191][1] = v[1];
    res[191][2] = v[0];
    phase[191] = (v[0]+v[1])*1./2;
  }
  static const short size=192;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fm2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = v[2]+1./2;
    res[15][0] = -v[0]+1./2;
    res[15][1] = v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = v[2];
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = -v[0];
    res[15][1] = v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fmm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[0]+1./2;
    res[14][1] = -v[1];
    res[14][2] = v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = (v[1]+v[2])*1./2;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fmmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[0]+1./2;
    res[12][1] = -v[1];
    res[12][2] = v[2]+1./2;
    res[13][0] = v[0]+1./2;
    res[13][1] = v[1];
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = -v[1]+1./2;
    res[14][2] = v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = v[1]+1./2;
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1]+1./2;
    res[18][2] = -v[2]+1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1]+1./2;
    res[19][2] = v[2]+1./2;
    res[20][0] = v[0]+1./2;
    res[20][1] = -v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = -v[0]+1./2;
    res[21][1] = v[1];
    res[21][2] = v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = -v[2];
    res[23][0] = -v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = v[2];
    res[24][0] = -v[0];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0];
    res[26][1] = v[1]+1./2;
    res[26][2] = -v[2]+1./2;
    res[27][0] = v[0];
    res[27][1] = -v[1]+1./2;
    res[27][2] = v[2]+1./2;
    res[28][0] = -v[0]+1./2;
    res[28][1] = v[1];
    res[28][2] = -v[2]+1./2;
    res[29][0] = v[0]+1./2;
    res[29][1] = -v[1];
    res[29][2] = v[2]+1./2;
    res[30][0] = -v[0]+1./2;
    res[30][1] = v[1]+1./2;
    res[30][2] = -v[2];
    res[31][0] = v[0]+1./2;
    res[31][1] = -v[1]+1./2;
    res[31][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    res[14][0] = -v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    res[24][0] = -v[0];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    res[27][0] = v[0];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    res[28][0] = -v[0];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    res[29][0] = v[0];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    res[30][0] = -v[0];
    res[30][1] = v[1];
    res[30][2] = -v[2];
    res[31][0] = v[0];
    res[31][1] = -v[1];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = -v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = v[0];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = -v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = v[1];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = (v[0]+v[2])*1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] = (v[0]+v[2])*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = -v[0];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    phase[24] =  0;
    res[25][0] = v[0];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    phase[25] =  0;
    res[26][0] = -v[0];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    phase[26] = (v[1]+v[2])*1./2;
    res[27][0] = v[0];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    phase[27] = (v[1]+v[2])*1./2;
    res[28][0] = -v[0];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    phase[28] = (v[0]+v[2])*1./2;
    res[29][0] = v[0];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    phase[29] = (v[0]+v[2])*1./2;
    res[30][0] = -v[0];
    res[30][1] = v[1];
    res[30][2] = -v[2];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = v[0];
    res[31][1] = -v[1];
    res[31][2] = v[2];
    phase[31] = (v[0]+v[1])*1./2;
  }
  static const short size=32;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Fx {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='F';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_4 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_42d {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./4;
    res[9][0] = v[0]+1./2;
    res[9][1] = -v[1];
    res[9][2] = -v[2]+3./4;
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./4;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+3./4;
    res[12][0] = -v[1];
    res[12][1] = -v[0]+1./2;
    res[12][2] = v[2]+1./4;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0];
    res[13][2] = v[2]+3./4;
    res[14][0] = v[1];
    res[14][1] = v[0]+1./2;
    res[14][2] = v[2]+1./4;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0];
    res[15][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2+v[2]*1./4;
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*1./2+v[2]*3./4;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2+v[2]*1./4;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./2+v[2]*3./4;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[1]*1./2+v[2]*1./4;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2+v[2]*3./4;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[1]*1./2+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2+v[2]*3./4;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_42m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0]+1./2;
    res[9][1] = -v[1]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_43d {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1]+1./4;
    res[2][1] = -v[0]+3./4;
    res[2][2] = -v[2]+1./4;
    res[3][0] = v[1]+3./4;
    res[3][1] = -v[0]+1./4;
    res[3][2] = -v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1]+1./4;
    res[6][1] = v[0]+1./4;
    res[6][2] = -v[2]+3./4;
    res[7][0] = -v[1]+3./4;
    res[7][1] = v[0]+3./4;
    res[7][2] = -v[2]+1./4;
    res[8][0] = -v[0]+1./4;
    res[8][1] = v[2]+1./4;
    res[8][2] = -v[1]+3./4;
    res[9][0] = -v[0]+3./4;
    res[9][1] = v[2]+3./4;
    res[9][2] = -v[1]+1./4;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = -v[2];
    res[12][0] = -v[0]+3./4;
    res[12][1] = -v[2]+1./4;
    res[12][2] = v[1]+1./4;
    res[13][0] = -v[0]+1./4;
    res[13][1] = -v[2]+3./4;
    res[13][2] = v[1]+3./4;
    res[14][0] = -v[2]+3./4;
    res[14][1] = -v[1]+1./4;
    res[14][2] = v[0]+1./4;
    res[15][0] = -v[2]+1./4;
    res[15][1] = -v[1]+3./4;
    res[15][2] = v[0]+3./4;
    res[16][0] = -v[0]+1./2;
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1]+1./2;
    res[17][2] = -v[2]+1./2;
    res[18][0] = v[2]+1./4;
    res[18][1] = -v[1]+3./4;
    res[18][2] = -v[0]+1./4;
    res[19][0] = v[2]+3./4;
    res[19][1] = -v[1]+1./4;
    res[19][2] = -v[0]+3./4;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = v[2]+1./2;
    res[21][1] = v[0]+1./2;
    res[21][2] = v[1]+1./2;
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = v[1]+1./2;
    res[23][1] = v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[1];
    res[24][1] = -v[2]+1./2;
    res[24][2] = v[0];
    res[25][0] = -v[1]+1./2;
    res[25][1] = -v[2];
    res[25][2] = v[0]+1./2;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1]+1./2;
    res[27][0] = v[2]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = -v[1];
    res[28][0] = -v[1]+1./2;
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1];
    res[29][1] = v[2]+1./2;
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[2];
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[1];
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[0];
    res[31][2] = v[1]+1./2;
    res[32][0] = -v[2]+1./2;
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2];
    res[33][1] = v[0]+1./2;
    res[33][2] = -v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0]+1./2;
    res[35][0] = v[1]+1./2;
    res[35][1] = -v[2]+1./2;
    res[35][2] = -v[0];
    res[36][0] = -v[1]+3./4;
    res[36][1] = -v[0]+1./4;
    res[36][2] = v[2]+1./4;
    res[37][0] = -v[1]+1./4;
    res[37][1] = -v[0]+3./4;
    res[37][2] = v[2]+3./4;
    res[38][0] = v[1]+1./4;
    res[38][1] = v[0]+1./4;
    res[38][2] = v[2]+1./4;
    res[39][0] = v[1]+3./4;
    res[39][1] = v[0]+3./4;
    res[39][2] = v[2]+3./4;
    res[40][0] = v[0]+1./4;
    res[40][1] = -v[2]+3./4;
    res[40][2] = -v[1]+1./4;
    res[41][0] = v[0]+3./4;
    res[41][1] = -v[2]+1./4;
    res[41][2] = -v[1]+3./4;
    res[42][0] = v[0]+1./4;
    res[42][1] = v[2]+1./4;
    res[42][2] = v[1]+1./4;
    res[43][0] = v[0]+3./4;
    res[43][1] = v[2]+3./4;
    res[43][2] = v[1]+3./4;
    res[44][0] = -v[2]+1./4;
    res[44][1] = v[1]+1./4;
    res[44][2] = -v[0]+3./4;
    res[45][0] = -v[2]+3./4;
    res[45][1] = v[1]+3./4;
    res[45][2] = -v[0]+1./4;
    res[46][0] = v[2]+1./4;
    res[46][1] = v[1]+1./4;
    res[46][2] = v[0]+1./4;
    res[47][0] = v[2]+3./4;
    res[47][1] = v[1]+3./4;
    res[47][2] = v[0]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = v[2];
    res[14][1] = -v[1];
    res[14][2] = -v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[2];
    res[18][1] = -v[1];
    res[18][2] = v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    res[36][0] = -v[1];
    res[36][1] = -v[0];
    res[36][2] = v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = v[1];
    res[38][1] = v[0];
    res[38][2] = v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = v[0];
    res[40][1] = -v[2];
    res[40][2] = -v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = v[0];
    res[42][1] = v[2];
    res[42][2] = v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = -v[2];
    res[44][1] = v[1];
    res[44][2] = -v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = v[2];
    res[46][1] = v[1];
    res[46][2] = v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    phase[8] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    phase[12] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = v[2];
    res[14][1] = -v[1];
    res[14][2] = -v[0];
    phase[14] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] = v[0]*1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = -v[2];
    res[18][1] = -v[1];
    res[18][2] = v[0];
    phase[18] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] = v[1]*1./2;
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    phase[25] = (v[0]+v[2])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] = v[2]*1./2;
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] = v[0]*1./2;
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    phase[29] = (v[1]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] = v[1]*1./2;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[2])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] = v[0]*1./2;
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = v[2]*1./2;
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = -v[1];
    res[36][1] = -v[0];
    res[36][2] = v[2];
    phase[36] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[38][0] = v[1];
    res[38][1] = v[0];
    res[38][2] = v[2];
    phase[38] = (v[0]+v[1]+v[2])*1./4;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] = (v[0]+v[1]+v[2])*3./4;
    res[40][0] = v[0];
    res[40][1] = -v[2];
    res[40][2] = -v[1];
    phase[40] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[42][0] = v[0];
    res[42][1] = v[2];
    res[42][2] = v[1];
    phase[42] = (v[0]+v[1]+v[2])*1./4;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] = (v[0]+v[1]+v[2])*3./4;
    res[44][0] = -v[2];
    res[44][1] = v[1];
    res[44][2] = -v[0];
    phase[44] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[46][0] = v[2];
    res[46][1] = v[1];
    res[46][2] = v[0];
    phase[46] = (v[0]+v[1]+v[2])*1./4;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_43m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[2]+1./2;
    res[9][2] = -v[1]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = -v[0]+1./2;
    res[13][1] = -v[2]+1./2;
    res[13][2] = v[1]+1./2;
    res[14][0] = -v[2];
    res[14][1] = -v[1];
    res[14][2] = v[0];
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[0]+1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0]+1./2;
    res[17][1] = v[1]+1./2;
    res[17][2] = -v[2]+1./2;
    res[18][0] = v[2];
    res[18][1] = -v[1];
    res[18][2] = -v[0];
    res[19][0] = v[2]+1./2;
    res[19][1] = -v[1]+1./2;
    res[19][2] = -v[0]+1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = v[2]+1./2;
    res[21][1] = v[0]+1./2;
    res[21][2] = v[1]+1./2;
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = v[1]+1./2;
    res[23][1] = v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[1];
    res[24][1] = -v[2];
    res[24][2] = v[0];
    res[25][0] = -v[1]+1./2;
    res[25][1] = -v[2]+1./2;
    res[25][2] = v[0]+1./2;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = v[2]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = -v[1]+1./2;
    res[28][0] = -v[1];
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1]+1./2;
    res[29][1] = v[2]+1./2;
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[2];
    res[30][1] = -v[0];
    res[30][2] = v[1];
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[0]+1./2;
    res[31][2] = v[1]+1./2;
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2]+1./2;
    res[33][1] = v[0]+1./2;
    res[33][2] = -v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0];
    res[35][0] = v[1]+1./2;
    res[35][1] = -v[2]+1./2;
    res[35][2] = -v[0]+1./2;
    res[36][0] = -v[1];
    res[36][1] = -v[0];
    res[36][2] = v[2];
    res[37][0] = -v[1]+1./2;
    res[37][1] = -v[0]+1./2;
    res[37][2] = v[2]+1./2;
    res[38][0] = v[1];
    res[38][1] = v[0];
    res[38][2] = v[2];
    res[39][0] = v[1]+1./2;
    res[39][1] = v[0]+1./2;
    res[39][2] = v[2]+1./2;
    res[40][0] = v[0];
    res[40][1] = -v[2];
    res[40][2] = -v[1];
    res[41][0] = v[0]+1./2;
    res[41][1] = -v[2]+1./2;
    res[41][2] = -v[1]+1./2;
    res[42][0] = v[0];
    res[42][1] = v[2];
    res[42][2] = v[1];
    res[43][0] = v[0]+1./2;
    res[43][1] = v[2]+1./2;
    res[43][2] = v[1]+1./2;
    res[44][0] = -v[2];
    res[44][1] = v[1];
    res[44][2] = -v[0];
    res[45][0] = -v[2]+1./2;
    res[45][1] = v[1]+1./2;
    res[45][2] = -v[0]+1./2;
    res[46][0] = v[2];
    res[46][1] = v[1];
    res[46][2] = v[0];
    res[47][0] = v[2]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = v[2];
    res[14][1] = -v[1];
    res[14][2] = -v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = -v[2];
    res[18][1] = -v[1];
    res[18][2] = v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    res[36][0] = -v[1];
    res[36][1] = -v[0];
    res[36][2] = v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = v[1];
    res[38][1] = v[0];
    res[38][2] = v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = v[0];
    res[40][1] = -v[2];
    res[40][2] = -v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = v[0];
    res[42][1] = v[2];
    res[42][2] = v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = -v[2];
    res[44][1] = v[1];
    res[44][2] = -v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = v[2];
    res[46][1] = v[1];
    res[46][2] = v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = v[2];
    res[14][1] = -v[1];
    res[14][2] = -v[0];
    phase[14] =  0;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[0]+v[1]+v[2])*1./2;
    res[18][0] = -v[2];
    res[18][1] = -v[1];
    res[18][2] = v[0];
    phase[18] =  0;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    phase[25] = (v[0]+v[1]+v[2])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] =  0;
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] =  0;
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    phase[29] = (v[0]+v[1]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] =  0;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] =  0;
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    phase[33] = (v[0]+v[1]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] =  0;
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    phase[35] = (v[0]+v[1]+v[2])*1./2;
    res[36][0] = -v[1];
    res[36][1] = -v[0];
    res[36][2] = v[2];
    phase[36] =  0;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] = (v[0]+v[1]+v[2])*1./2;
    res[38][0] = v[1];
    res[38][1] = v[0];
    res[38][2] = v[2];
    phase[38] =  0;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[2];
    res[40][2] = -v[1];
    phase[40] =  0;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] = (v[0]+v[1]+v[2])*1./2;
    res[42][0] = v[0];
    res[42][1] = v[2];
    res[42][2] = v[1];
    phase[42] =  0;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = -v[2];
    res[44][1] = v[1];
    res[44][2] = -v[0];
    phase[44] =  0;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] = (v[0]+v[1]+v[2])*1./2;
    res[46][0] = v[2];
    res[46][1] = v[1];
    res[46][2] = v[0];
    phase[46] =  0;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_4c2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2]+1./2;
    res[9][0] = v[1]+1./2;
    res[9][1] = v[0]+1./2;
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[1]+1./2;
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2]+1./2;
    res[13][0] = -v[0]+1./2;
    res[13][1] = v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I_4m2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = -v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1]+1./2;
    res[9][1] = v[0]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1]+1./2;
    res[11][1] = -v[0]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0]+1./2;
    res[13][1] = v[1]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = -v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[1];
    res[10][1] = -v[0];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[1];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = v[0];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] =  0;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I112 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I112_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I112_b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I112_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I11a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I11b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I11m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_b11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_c11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2_m11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I211 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I212121 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I213 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[2]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[1]+1./2;
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = v[1]+1./2;
    res[5][1] = v[2]+1./2;
    res[5][2] = v[0]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[2]+1./2;
    res[6][2] = v[0];
    res[7][0] = -v[1]+1./2;
    res[7][1] = -v[2];
    res[7][2] = v[0]+1./2;
    res[8][0] = v[2];
    res[8][1] = -v[0];
    res[8][2] = -v[1]+1./2;
    res[9][0] = v[2]+1./2;
    res[9][1] = -v[0]+1./2;
    res[9][2] = -v[1];
    res[10][0] = -v[1]+1./2;
    res[10][1] = v[2];
    res[10][2] = -v[0];
    res[11][0] = -v[1];
    res[11][1] = v[2]+1./2;
    res[11][2] = -v[0]+1./2;
    res[12][0] = -v[2];
    res[12][1] = -v[0]+1./2;
    res[12][2] = v[1];
    res[13][0] = -v[2]+1./2;
    res[13][1] = -v[0];
    res[13][2] = v[1]+1./2;
    res[14][0] = -v[2]+1./2;
    res[14][1] = v[0];
    res[14][2] = -v[1];
    res[15][0] = -v[2];
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[1]+1./2;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0]+1./2;
    res[17][0] = v[1]+1./2;
    res[17][1] = -v[2]+1./2;
    res[17][2] = -v[0];
    res[18][0] = -v[0];
    res[18][1] = -v[1]+1./2;
    res[18][2] = v[2];
    res[19][0] = -v[0]+1./2;
    res[19][1] = -v[1];
    res[19][2] = v[2]+1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = v[0]+1./2;
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2];
    res[22][0] = -v[0]+1./2;
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1]+1./2;
    res[23][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = v[1];
    res[3][1] = v[2];
    res[3][2] = v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[0];
    res[5][2] = v[1];
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    res[7][0] = v[2];
    res[7][1] = -v[0];
    res[7][2] = -v[1];
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = v[0];
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = v[1];
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    res[13][0] = -v[1];
    res[13][1] = v[2];
    res[13][2] = -v[0];
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    res[15][0] = v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = -v[0];
    res[19][1] = -v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[2];
    res[3][2] = v[0];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = v[2];
    res[5][1] = v[0];
    res[5][2] = v[1];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    phase[6] = v[1]*1./2;
    res[7][0] = v[2];
    res[7][1] = -v[0];
    res[7][2] = -v[1];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = v[0];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    phase[10] = v[0]*1./2;
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = v[1];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    phase[12] = v[1]*1./2;
    res[13][0] = -v[1];
    res[13][1] = v[2];
    res[13][2] = -v[0];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    phase[14] = v[0]*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    phase[15] = (v[1]+v[2])*1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] = (v[0]+v[1])*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = v[1]*1./2;
    res[19][0] = -v[0];
    res[19][1] = -v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[0]+v[1])*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = v[0]*1./2;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[1]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I23 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[2]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[1]+1./2;
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = v[1]+1./2;
    res[5][1] = v[2]+1./2;
    res[5][2] = v[0]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[2];
    res[6][2] = v[0];
    res[7][0] = -v[1]+1./2;
    res[7][1] = -v[2]+1./2;
    res[7][2] = v[0]+1./2;
    res[8][0] = v[2];
    res[8][1] = -v[0];
    res[8][2] = -v[1];
    res[9][0] = v[2]+1./2;
    res[9][1] = -v[0]+1./2;
    res[9][2] = -v[1]+1./2;
    res[10][0] = -v[1];
    res[10][1] = v[2];
    res[10][2] = -v[0];
    res[11][0] = -v[1]+1./2;
    res[11][1] = v[2]+1./2;
    res[11][2] = -v[0]+1./2;
    res[12][0] = -v[2];
    res[12][1] = -v[0];
    res[12][2] = v[1];
    res[13][0] = -v[2]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[1]+1./2;
    res[14][0] = -v[2];
    res[14][1] = v[0];
    res[14][2] = -v[1];
    res[15][0] = -v[2]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[1]+1./2;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = v[1]+1./2;
    res[17][1] = -v[2]+1./2;
    res[17][2] = -v[0]+1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = -v[0]+1./2;
    res[19][1] = -v[1]+1./2;
    res[19][2] = v[2]+1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0]+1./2;
    res[21][1] = -v[1]+1./2;
    res[21][2] = -v[2]+1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = v[1];
    res[3][1] = v[2];
    res[3][2] = v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[0];
    res[5][2] = v[1];
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    res[7][0] = v[2];
    res[7][1] = -v[0];
    res[7][2] = -v[1];
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = v[0];
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = v[1];
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    res[13][0] = -v[1];
    res[13][1] = v[2];
    res[13][2] = -v[0];
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    res[15][0] = v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = -v[0];
    res[19][1] = -v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[2];
    res[3][2] = v[0];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = v[2];
    res[5][1] = v[0];
    res[5][2] = v[1];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    phase[6] =  0;
    res[7][0] = v[2];
    res[7][1] = -v[0];
    res[7][2] = -v[1];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = v[0];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    phase[10] =  0;
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = v[1];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = v[2];
    res[13][2] = -v[0];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = -v[2];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] = (v[0]+v[1]+v[2])*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] =  0;
    res[19][0] = -v[0];
    res[19][1] = -v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = -v[2];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] =  0;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = -v[2];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2cb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2mb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = v[2]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4_mcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = v[2]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2]+1./2;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2]+1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2]+1./2;
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[1]+1./2;
    res[18][2] = -v[2];
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2]+1./2;
    res[22][0] = -v[0]+1./2;
    res[22][1] = v[1]+1./2;
    res[22][2] = -v[2];
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = v[2];
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2]+1./2;
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2]+1./2;
    res[26][0] = v[1]+1./2;
    res[26][1] = v[0]+1./2;
    res[26][2] = -v[2];
    res[27][0] = -v[1]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = v[2];
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2]+1./2;
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2]+1./2;
    res[30][0] = -v[1]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = -v[2];
    res[31][0] = v[1]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] = v[2]*1./2;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[0]+v[1])*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    phase[20] = v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    phase[21] = v[2]*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    phase[24] = v[2]*1./2;
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    phase[25] = v[2]*1./2;
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    phase[26] = (v[0]+v[1])*1./2;
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    phase[28] = v[2]*1./2;
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    phase[29] = v[2]*1./2;
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
    phase[31] = (v[0]+v[1])*1./2;
  }
  static const short size=32;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4_mmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = v[2]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2]+1./2;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[1]+1./2;
    res[18][2] = -v[2]+1./2;
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = v[2]+1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0]+1./2;
    res[22][1] = v[1]+1./2;
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = v[2]+1./2;
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    res[26][0] = v[1]+1./2;
    res[26][1] = v[0]+1./2;
    res[26][2] = -v[2]+1./2;
    res[27][0] = -v[1]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = v[2]+1./2;
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    res[30][0] = -v[1]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = -v[2]+1./2;
    res[31][0] = v[1]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    phase[21] =  0;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[1]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    phase[24] =  0;
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    phase[25] =  0;
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    phase[26] = (v[0]+v[1]+v[2])*1./2;
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    phase[28] =  0;
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    phase[29] =  0;
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    phase[30] = (v[0]+v[1]+v[2])*1./2;
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=32;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./4;
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0];
    res[3][2] = v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./4;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0];
    res[7][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2+v[2]*1./4;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2+v[2]*3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2+v[2]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2+v[2]*3./4;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1]+3./4;
    res[4][1] = v[0]+1./4;
    res[4][2] = v[2]+1./4;
    res[5][0] = v[1]+3./4;
    res[5][1] = -v[0]+1./4;
    res[5][2] = -v[2]+1./4;
    res[6][0] = -v[1]+1./4;
    res[6][1] = v[0]+3./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = v[1]+1./4;
    res[7][1] = -v[0]+3./4;
    res[7][2] = -v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1]+1./4;
    res[12][1] = -v[0]+1./4;
    res[12][2] = v[2]+1./4;
    res[13][0] = -v[1]+1./4;
    res[13][1] = v[0]+1./4;
    res[13][2] = -v[2]+1./4;
    res[14][0] = v[1]+3./4;
    res[14][1] = -v[0]+3./4;
    res[14][2] = v[2]+3./4;
    res[15][0] = -v[1]+3./4;
    res[15][1] = v[0]+3./4;
    res[15][2] = -v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./4;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./4;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*3./4;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41_acd {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1]+1./4;
    res[4][1] = v[0]+3./4;
    res[4][2] = v[2]+1./4;
    res[5][0] = v[1]+1./4;
    res[5][1] = -v[0]+3./4;
    res[5][2] = -v[2]+1./4;
    res[6][0] = -v[1]+3./4;
    res[6][1] = v[0]+1./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = v[1]+3./4;
    res[7][1] = -v[0]+1./4;
    res[7][2] = -v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1]+1./4;
    res[12][1] = -v[0]+1./4;
    res[12][2] = v[2]+3./4;
    res[13][0] = -v[1]+1./4;
    res[13][1] = v[0]+1./4;
    res[13][2] = -v[2]+3./4;
    res[14][0] = v[1]+3./4;
    res[14][1] = -v[0]+3./4;
    res[14][2] = v[2]+1./4;
    res[15][0] = -v[1]+3./4;
    res[15][1] = v[0]+3./4;
    res[15][2] = -v[2]+1./4;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2]+1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2]+1./2;
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[1]+1./2;
    res[18][2] = -v[2];
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = v[2];
    res[20][0] = -v[0]+1./2;
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0]+1./2;
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1]+1./2;
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1]+1./2;
    res[23][2] = v[2]+1./2;
    res[24][0] = v[1]+3./4;
    res[24][1] = v[0]+1./4;
    res[24][2] = -v[2]+1./4;
    res[25][0] = -v[1]+3./4;
    res[25][1] = -v[0]+1./4;
    res[25][2] = v[2]+1./4;
    res[26][0] = v[1]+1./4;
    res[26][1] = v[0]+3./4;
    res[26][2] = -v[2]+3./4;
    res[27][0] = -v[1]+1./4;
    res[27][1] = -v[0]+3./4;
    res[27][2] = v[2]+3./4;
    res[28][0] = -v[1]+1./4;
    res[28][1] = -v[0]+1./4;
    res[28][2] = -v[2]+1./4;
    res[29][0] = v[1]+1./4;
    res[29][1] = v[0]+1./4;
    res[29][2] = v[2]+1./4;
    res[30][0] = -v[1]+3./4;
    res[30][1] = -v[0]+3./4;
    res[30][2] = -v[2]+3./4;
    res[31][0] = v[1]+3./4;
    res[31][1] = v[0]+3./4;
    res[31][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] = v[2]*1./2;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[0]+v[1])*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    phase[20] = v[0]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    phase[21] = v[0]*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[1]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[1]+v[2])*1./2;
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    phase[24] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    phase[25] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    phase[26] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    phase[27] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    phase[28] = (v[0]+v[1]+v[2])*1./4;
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    phase[29] = (v[0]+v[1]+v[2])*1./4;
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    phase[30] = (v[0]+v[1]+v[2])*3./4;
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
    phase[31] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=32;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41_amd {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1]+1./4;
    res[4][1] = v[0]+3./4;
    res[4][2] = v[2]+1./4;
    res[5][0] = v[1]+1./4;
    res[5][1] = -v[0]+3./4;
    res[5][2] = -v[2]+1./4;
    res[6][0] = -v[1]+3./4;
    res[6][1] = v[0]+1./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = v[1]+3./4;
    res[7][1] = -v[0]+1./4;
    res[7][2] = -v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1]+1./4;
    res[12][1] = -v[0]+1./4;
    res[12][2] = v[2]+3./4;
    res[13][0] = -v[1]+1./4;
    res[13][1] = v[0]+1./4;
    res[13][2] = -v[2]+3./4;
    res[14][0] = v[1]+3./4;
    res[14][1] = -v[0]+3./4;
    res[14][2] = v[2]+1./4;
    res[15][0] = -v[1]+3./4;
    res[15][1] = v[0]+3./4;
    res[15][2] = -v[2]+1./4;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[1]+1./2;
    res[18][2] = -v[2]+1./2;
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = v[2]+1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1]+1./2;
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1]+1./2;
    res[21][2] = v[2];
    res[22][0] = -v[0]+1./2;
    res[22][1] = v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1];
    res[23][2] = v[2]+1./2;
    res[24][0] = v[1]+1./4;
    res[24][1] = v[0]+3./4;
    res[24][2] = -v[2]+1./4;
    res[25][0] = -v[1]+1./4;
    res[25][1] = -v[0]+3./4;
    res[25][2] = v[2]+1./4;
    res[26][0] = v[1]+3./4;
    res[26][1] = v[0]+1./4;
    res[26][2] = -v[2]+3./4;
    res[27][0] = -v[1]+3./4;
    res[27][1] = -v[0]+1./4;
    res[27][2] = v[2]+3./4;
    res[28][0] = -v[1]+1./4;
    res[28][1] = -v[0]+1./4;
    res[28][2] = -v[2]+3./4;
    res[29][0] = v[1]+1./4;
    res[29][1] = v[0]+1./4;
    res[29][2] = v[2]+3./4;
    res[30][0] = -v[1]+3./4;
    res[30][1] = -v[0]+3./4;
    res[30][2] = -v[2]+1./4;
    res[31][0] = v[1]+3./4;
    res[31][1] = v[0]+3./4;
    res[31][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[16][0] = v[0];
    res[16][1] = -v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = v[0];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[1];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    phase[20] = v[1]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    phase[21] = v[1]*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[2])*1./2;
    res[24][0] = v[1];
    res[24][1] = v[0];
    res[24][2] = -v[2];
    phase[24] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[25][0] = -v[1];
    res[25][1] = -v[0];
    res[25][2] = v[2];
    phase[25] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[26][0] = v[1];
    res[26][1] = v[0];
    res[26][2] = -v[2];
    phase[26] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[27][0] = -v[1];
    res[27][1] = -v[0];
    res[27][2] = v[2];
    phase[27] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[28][0] = -v[1];
    res[28][1] = -v[0];
    res[28][2] = -v[2];
    phase[28] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[29][0] = v[1];
    res[29][1] = v[0];
    res[29][2] = v[2];
    phase[29] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[30][0] = -v[1];
    res[30][1] = -v[0];
    res[30][2] = -v[2];
    phase[30] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[31][0] = v[1];
    res[31][1] = v[0];
    res[31][2] = v[2];
    phase[31] = (v[0]+v[1])*3./4+v[2]*1./4;
  }
  static const short size=32;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4122 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./4;
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0];
    res[3][2] = v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./4;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0];
    res[7][2] = v[2]+3./4;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./4;
    res[9][0] = v[0]+1./2;
    res[9][1] = -v[1];
    res[9][2] = -v[2]+3./4;
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./4;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+3./4;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1]+1./2;
    res[13][1] = v[0]+1./2;
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = -v[1]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2+v[2]*1./4;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2+v[2]*3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2+v[2]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2+v[2]*3./4;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2+v[2]*1./4;
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*1./2+v[2]*3./4;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2+v[2]*1./4;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./2+v[2]*3./4;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4132 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1]+1./4;
    res[2][1] = v[0]+3./4;
    res[2][2] = v[2]+1./4;
    res[3][0] = -v[1]+3./4;
    res[3][1] = v[0]+1./4;
    res[3][2] = v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1]+1./4;
    res[6][1] = -v[0]+1./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = v[1]+3./4;
    res[7][1] = -v[0]+3./4;
    res[7][2] = v[2]+1./4;
    res[8][0] = v[0]+1./4;
    res[8][1] = -v[2]+1./4;
    res[8][2] = v[1]+3./4;
    res[9][0] = v[0]+3./4;
    res[9][1] = -v[2]+3./4;
    res[9][2] = v[1]+1./4;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = -v[2];
    res[12][0] = v[0]+3./4;
    res[12][1] = v[2]+1./4;
    res[12][2] = -v[1]+1./4;
    res[13][0] = v[0]+1./4;
    res[13][1] = v[2]+3./4;
    res[13][2] = -v[1]+3./4;
    res[14][0] = v[2]+3./4;
    res[14][1] = v[1]+1./4;
    res[14][2] = -v[0]+1./4;
    res[15][0] = v[2]+1./4;
    res[15][1] = v[1]+3./4;
    res[15][2] = -v[0]+3./4;
    res[16][0] = -v[0]+1./2;
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1]+1./2;
    res[17][2] = -v[2]+1./2;
    res[18][0] = -v[2]+1./4;
    res[18][1] = v[1]+3./4;
    res[18][2] = v[0]+1./4;
    res[19][0] = -v[2]+3./4;
    res[19][1] = v[1]+1./4;
    res[19][2] = v[0]+3./4;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = v[2]+1./2;
    res[21][1] = v[0]+1./2;
    res[21][2] = v[1]+1./2;
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = v[1]+1./2;
    res[23][1] = v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[1];
    res[24][1] = -v[2]+1./2;
    res[24][2] = v[0];
    res[25][0] = -v[1]+1./2;
    res[25][1] = -v[2];
    res[25][2] = v[0]+1./2;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1]+1./2;
    res[27][0] = v[2]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = -v[1];
    res[28][0] = -v[1]+1./2;
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1];
    res[29][1] = v[2]+1./2;
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[2];
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[1];
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[0];
    res[31][2] = v[1]+1./2;
    res[32][0] = -v[2]+1./2;
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2];
    res[33][1] = v[0]+1./2;
    res[33][2] = -v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0]+1./2;
    res[35][0] = v[1]+1./2;
    res[35][1] = -v[2]+1./2;
    res[35][2] = -v[0];
    res[36][0] = v[1]+3./4;
    res[36][1] = v[0]+1./4;
    res[36][2] = -v[2]+1./4;
    res[37][0] = v[1]+1./4;
    res[37][1] = v[0]+3./4;
    res[37][2] = -v[2]+3./4;
    res[38][0] = -v[1]+1./4;
    res[38][1] = -v[0]+1./4;
    res[38][2] = -v[2]+1./4;
    res[39][0] = -v[1]+3./4;
    res[39][1] = -v[0]+3./4;
    res[39][2] = -v[2]+3./4;
    res[40][0] = -v[0]+1./4;
    res[40][1] = v[2]+3./4;
    res[40][2] = v[1]+1./4;
    res[41][0] = -v[0]+3./4;
    res[41][1] = v[2]+1./4;
    res[41][2] = v[1]+3./4;
    res[42][0] = -v[0]+1./4;
    res[42][1] = -v[2]+1./4;
    res[42][2] = -v[1]+1./4;
    res[43][0] = -v[0]+3./4;
    res[43][1] = -v[2]+3./4;
    res[43][2] = -v[1]+3./4;
    res[44][0] = v[2]+1./4;
    res[44][1] = -v[1]+1./4;
    res[44][2] = v[0]+3./4;
    res[45][0] = v[2]+3./4;
    res[45][1] = -v[1]+3./4;
    res[45][2] = v[0]+1./4;
    res[46][0] = -v[2]+1./4;
    res[46][1] = -v[1]+1./4;
    res[46][2] = -v[0]+1./4;
    res[47][0] = -v[2]+3./4;
    res[47][1] = -v[1]+3./4;
    res[47][2] = -v[0]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = -v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = -v[2];
    res[15][1] = v[1];
    res[15][2] = v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = v[2];
    res[19][1] = v[1];
    res[19][2] = -v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = v[1];
    res[37][1] = v[0];
    res[37][2] = -v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = -v[1];
    res[39][1] = -v[0];
    res[39][2] = -v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = -v[0];
    res[41][1] = v[2];
    res[41][2] = v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = -v[0];
    res[43][1] = -v[2];
    res[43][2] = -v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = v[2];
    res[45][1] = -v[1];
    res[45][2] = v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = -v[2];
    res[47][1] = -v[1];
    res[47][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = -v[1];
    phase[9] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[13][0] = v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1];
    phase[13] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[15][0] = -v[2];
    res[15][1] = v[1];
    res[15][2] = v[0];
    phase[15] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] = v[0]*1./2;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[19][0] = v[2];
    res[19][1] = v[1];
    res[19][2] = -v[0];
    phase[19] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] = v[1]*1./2;
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    phase[25] = (v[0]+v[2])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] = v[2]*1./2;
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[1])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] = v[0]*1./2;
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    phase[29] = (v[1]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] = v[1]*1./2;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[2])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] = v[0]*1./2;
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    phase[33] = (v[1]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = v[2]*1./2;
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[37][0] = v[1];
    res[37][1] = v[0];
    res[37][2] = -v[2];
    phase[37] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] = (v[0]+v[1]+v[2])*1./4;
    res[39][0] = -v[1];
    res[39][1] = -v[0];
    res[39][2] = -v[2];
    phase[39] = (v[0]+v[1]+v[2])*3./4;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[41][0] = -v[0];
    res[41][1] = v[2];
    res[41][2] = v[1];
    phase[41] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] = (v[0]+v[1]+v[2])*1./4;
    res[43][0] = -v[0];
    res[43][1] = -v[2];
    res[43][2] = -v[1];
    phase[43] = (v[0]+v[1]+v[2])*3./4;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[45][0] = v[2];
    res[45][1] = -v[1];
    res[45][2] = v[0];
    phase[45] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] = (v[0]+v[1]+v[2])*1./4;
    res[47][0] = -v[2];
    res[47][1] = -v[1];
    res[47][2] = -v[0];
    phase[47] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41cd {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./4;
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0];
    res[3][2] = v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./4;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0];
    res[7][2] = v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[1]+1./2;
    res[12][1] = -v[0];
    res[12][2] = v[2]+1./4;
    res[13][0] = -v[1];
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+3./4;
    res[14][0] = v[1]+1./2;
    res[14][1] = v[0];
    res[14][2] = v[2]+1./4;
    res[15][0] = v[1];
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2+v[2]*1./4;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2+v[2]*3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2+v[2]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2+v[2]*3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[0]*1./2+v[2]*1./4;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2+v[2]*3./4;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*1./2+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[1]*1./2+v[2]*3./4;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I41md {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./4;
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0];
    res[3][2] = v[2]+3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./4;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0];
    res[7][2] = v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0]+1./2;
    res[12][2] = v[2]+1./4;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0];
    res[13][2] = v[2]+3./4;
    res[14][0] = v[1];
    res[14][1] = v[0]+1./2;
    res[14][2] = v[2]+1./4;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0];
    res[15][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2+v[2]*1./4;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2+v[2]*3./4;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2+v[2]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2+v[2]*3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[1]*1./2+v[2]*1./4;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2+v[2]*3./4;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[1]*1./2+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[0]*1./2+v[2]*3./4;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I422 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0]+1./2;
    res[9][1] = -v[1]+1./2;
    res[9][2] = -v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1]+1./2;
    res[13][1] = v[0]+1./2;
    res[13][2] = -v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = -v[1]+1./2;
    res[15][1] = -v[0]+1./2;
    res[15][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I432 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    res[9][0] = v[0]+1./2;
    res[9][1] = -v[2]+1./2;
    res[9][2] = v[1]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    res[13][0] = v[0]+1./2;
    res[13][1] = v[2]+1./2;
    res[13][2] = -v[1]+1./2;
    res[14][0] = v[2];
    res[14][1] = v[1];
    res[14][2] = -v[0];
    res[15][0] = v[2]+1./2;
    res[15][1] = v[1]+1./2;
    res[15][2] = -v[0]+1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0]+1./2;
    res[17][1] = v[1]+1./2;
    res[17][2] = -v[2]+1./2;
    res[18][0] = -v[2];
    res[18][1] = v[1];
    res[18][2] = v[0];
    res[19][0] = -v[2]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = v[0]+1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = v[2]+1./2;
    res[21][1] = v[0]+1./2;
    res[21][2] = v[1]+1./2;
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = v[1]+1./2;
    res[23][1] = v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[1];
    res[24][1] = -v[2];
    res[24][2] = v[0];
    res[25][0] = -v[1]+1./2;
    res[25][1] = -v[2]+1./2;
    res[25][2] = v[0]+1./2;
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = v[2]+1./2;
    res[27][1] = -v[0]+1./2;
    res[27][2] = -v[1]+1./2;
    res[28][0] = -v[1];
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1]+1./2;
    res[29][1] = v[2]+1./2;
    res[29][2] = -v[0]+1./2;
    res[30][0] = -v[2];
    res[30][1] = -v[0];
    res[30][2] = v[1];
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[0]+1./2;
    res[31][2] = v[1]+1./2;
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = -v[2]+1./2;
    res[33][1] = v[0]+1./2;
    res[33][2] = -v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0];
    res[35][0] = v[1]+1./2;
    res[35][1] = -v[2]+1./2;
    res[35][2] = -v[0]+1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = v[1]+1./2;
    res[37][1] = v[0]+1./2;
    res[37][2] = -v[2]+1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = -v[1]+1./2;
    res[39][1] = -v[0]+1./2;
    res[39][2] = -v[2]+1./2;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = -v[0]+1./2;
    res[41][1] = v[2]+1./2;
    res[41][2] = v[1]+1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = -v[0]+1./2;
    res[43][1] = -v[2]+1./2;
    res[43][2] = -v[1]+1./2;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = v[2]+1./2;
    res[45][1] = -v[1]+1./2;
    res[45][2] = v[0]+1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = -v[2]+1./2;
    res[47][1] = -v[1]+1./2;
    res[47][2] = -v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = -v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = -v[2];
    res[15][1] = v[1];
    res[15][2] = v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = v[2];
    res[19][1] = v[1];
    res[19][2] = -v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = v[1];
    res[37][1] = v[0];
    res[37][2] = -v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = -v[1];
    res[39][1] = -v[0];
    res[39][2] = -v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = -v[0];
    res[41][1] = v[2];
    res[41][2] = v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = -v[0];
    res[43][1] = -v[2];
    res[43][2] = -v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = v[2];
    res[45][1] = -v[1];
    res[45][2] = v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = -v[2];
    res[47][1] = -v[1];
    res[47][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = -v[1];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] =  0;
    res[15][0] = -v[2];
    res[15][1] = v[1];
    res[15][2] = v[0];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = v[1];
    res[17][2] = -v[2];
    phase[17] = (v[0]+v[1]+v[2])*1./2;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] =  0;
    res[19][0] = v[2];
    res[19][1] = v[1];
    res[19][2] = -v[0];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = v[1];
    res[21][1] = v[2];
    res[21][2] = v[0];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = v[1];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = v[2];
    res[25][1] = -v[0];
    res[25][2] = -v[1];
    phase[25] = (v[0]+v[1]+v[2])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] =  0;
    res[27][0] = -v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] =  0;
    res[29][0] = -v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    phase[29] = (v[0]+v[1]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] =  0;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] =  0;
    res[33][0] = v[1];
    res[33][1] = -v[2];
    res[33][2] = -v[0];
    phase[33] = (v[0]+v[1]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] =  0;
    res[35][0] = -v[2];
    res[35][1] = v[0];
    res[35][2] = -v[1];
    phase[35] = (v[0]+v[1]+v[2])*1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] =  0;
    res[37][0] = v[1];
    res[37][1] = v[0];
    res[37][2] = -v[2];
    phase[37] = (v[0]+v[1]+v[2])*1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] =  0;
    res[39][0] = -v[1];
    res[39][1] = -v[0];
    res[39][2] = -v[2];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] =  0;
    res[41][0] = -v[0];
    res[41][1] = v[2];
    res[41][2] = v[1];
    phase[41] = (v[0]+v[1]+v[2])*1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] =  0;
    res[43][0] = -v[0];
    res[43][1] = -v[2];
    res[43][2] = -v[1];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] =  0;
    res[45][0] = v[2];
    res[45][1] = -v[1];
    res[45][2] = v[0];
    phase[45] = (v[0]+v[1]+v[2])*1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] =  0;
    res[47][0] = -v[2];
    res[47][1] = -v[1];
    res[47][2] = -v[0];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2]+1./2;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_I4mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ia {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ia_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = v[2]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[1]+1./2;
    res[7][0] = -v[2]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[1]+1./2;
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    res[10][0] = v[1]+1./2;
    res[10][1] = v[2]+1./2;
    res[10][2] = v[0]+1./2;
    res[11][0] = -v[1]+1./2;
    res[11][1] = -v[2]+1./2;
    res[11][2] = -v[0]+1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[2]+1./2;
    res[12][2] = v[0];
    res[13][0] = v[1];
    res[13][1] = v[2]+1./2;
    res[13][2] = -v[0];
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[2];
    res[14][2] = v[0]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[2];
    res[15][2] = -v[0]+1./2;
    res[16][0] = v[2];
    res[16][1] = -v[0];
    res[16][2] = -v[1]+1./2;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = v[1]+1./2;
    res[18][0] = v[2]+1./2;
    res[18][1] = -v[0]+1./2;
    res[18][2] = -v[1];
    res[19][0] = -v[2]+1./2;
    res[19][1] = v[0]+1./2;
    res[19][2] = v[1];
    res[20][0] = -v[1]+1./2;
    res[20][1] = v[2];
    res[20][2] = -v[0];
    res[21][0] = v[1]+1./2;
    res[21][1] = -v[2];
    res[21][2] = v[0];
    res[22][0] = -v[1];
    res[22][1] = v[2]+1./2;
    res[22][2] = -v[0]+1./2;
    res[23][0] = v[1];
    res[23][1] = -v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[2];
    res[24][1] = -v[0]+1./2;
    res[24][2] = v[1];
    res[25][0] = v[2];
    res[25][1] = v[0]+1./2;
    res[25][2] = -v[1];
    res[26][0] = -v[2]+1./2;
    res[26][1] = -v[0];
    res[26][2] = v[1]+1./2;
    res[27][0] = v[2]+1./2;
    res[27][1] = v[0];
    res[27][2] = -v[1]+1./2;
    res[28][0] = -v[2]+1./2;
    res[28][1] = v[0];
    res[28][2] = -v[1];
    res[29][0] = v[2]+1./2;
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[2];
    res[30][1] = v[0]+1./2;
    res[30][2] = -v[1]+1./2;
    res[31][0] = v[2];
    res[31][1] = -v[0]+1./2;
    res[31][2] = v[1]+1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0]+1./2;
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0]+1./2;
    res[34][0] = v[1]+1./2;
    res[34][1] = -v[2]+1./2;
    res[34][2] = -v[0];
    res[35][0] = -v[1]+1./2;
    res[35][1] = v[2]+1./2;
    res[35][2] = v[0];
    res[36][0] = -v[0];
    res[36][1] = -v[1]+1./2;
    res[36][2] = v[2];
    res[37][0] = v[0];
    res[37][1] = v[1]+1./2;
    res[37][2] = -v[2];
    res[38][0] = -v[0]+1./2;
    res[38][1] = -v[1];
    res[38][2] = v[2]+1./2;
    res[39][0] = v[0]+1./2;
    res[39][1] = v[1];
    res[39][2] = -v[2]+1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2]+1./2;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2]+1./2;
    res[42][0] = v[0]+1./2;
    res[42][1] = -v[1]+1./2;
    res[42][2] = -v[2];
    res[43][0] = -v[0]+1./2;
    res[43][1] = v[1]+1./2;
    res[43][2] = v[2];
    res[44][0] = -v[0]+1./2;
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = v[0]+1./2;
    res[45][1] = -v[1];
    res[45][2] = v[2];
    res[46][0] = -v[0];
    res[46][1] = v[1]+1./2;
    res[46][2] = -v[2]+1./2;
    res[47][0] = v[0];
    res[47][1] = -v[1]+1./2;
    res[47][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    res[7][0] = -v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = -v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[2];
    res[13][1] = v[0];
    res[13][2] = v[1];
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    res[15][0] = -v[2];
    res[15][1] = v[0];
    res[15][2] = v[1];
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    res[17][0] = v[1];
    res[17][1] = v[2];
    res[17][2] = -v[0];
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    res[19][0] = v[1];
    res[19][1] = v[2];
    res[19][2] = -v[0];
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    res[21][0] = v[2];
    res[21][1] = v[0];
    res[21][2] = -v[1];
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = -v[1];
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    res[25][0] = v[1];
    res[25][1] = -v[2];
    res[25][2] = v[0];
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    res[27][0] = v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1];
    res[29][1] = v[2];
    res[29][2] = v[0];
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = v[0];
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    res[37][0] = v[0];
    res[37][1] = v[1];
    res[37][2] = -v[2];
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    res[39][0] = v[0];
    res[39][1] = v[1];
    res[39][2] = -v[2];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = v[0];
    res[45][1] = -v[1];
    res[45][2] = v[2];
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    res[47][0] = v[0];
    res[47][1] = -v[1];
    res[47][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    phase[8] =  0;
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    phase[9] =  0;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = -v[1];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] = v[1]*1./2;
    res[13][0] = -v[2];
    res[13][1] = v[0];
    res[13][2] = v[1];
    phase[13] = v[1]*1./2;
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = -v[2];
    res[15][1] = v[0];
    res[15][2] = v[1];
    phase[15] = (v[0]+v[2])*1./2;
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    phase[16] = v[2]*1./2;
    res[17][0] = v[1];
    res[17][1] = v[2];
    res[17][2] = -v[0];
    phase[17] = v[2]*1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    phase[18] = (v[0]+v[1])*1./2;
    res[19][0] = v[1];
    res[19][1] = v[2];
    res[19][2] = -v[0];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    phase[20] = v[0]*1./2;
    res[21][0] = v[2];
    res[21][1] = v[0];
    res[21][2] = -v[1];
    phase[21] = v[0]*1./2;
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    phase[22] = (v[1]+v[2])*1./2;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = -v[1];
    phase[23] = (v[1]+v[2])*1./2;
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    phase[24] = v[1]*1./2;
    res[25][0] = v[1];
    res[25][1] = -v[2];
    res[25][2] = v[0];
    phase[25] = v[1]*1./2;
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    phase[26] = (v[0]+v[2])*1./2;
    res[27][0] = v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[2])*1./2;
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    phase[28] = v[0]*1./2;
    res[29][0] = -v[1];
    res[29][1] = v[2];
    res[29][2] = v[0];
    phase[29] = v[0]*1./2;
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    phase[30] = (v[1]+v[2])*1./2;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = v[0];
    phase[31] = (v[1]+v[2])*1./2;
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    phase[32] = v[2]*1./2;
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    phase[33] = v[2]*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = (v[0]+v[1])*1./2;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] = (v[0]+v[1])*1./2;
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    phase[36] = v[1]*1./2;
    res[37][0] = v[0];
    res[37][1] = v[1];
    res[37][2] = -v[2];
    phase[37] = v[1]*1./2;
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    phase[38] = (v[0]+v[2])*1./2;
    res[39][0] = v[0];
    res[39][1] = v[1];
    res[39][2] = -v[2];
    phase[39] = (v[0]+v[2])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] = v[2]*1./2;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] = v[2]*1./2;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[0]+v[1])*1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[0]+v[1])*1./2;
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    phase[44] = v[0]*1./2;
    res[45][0] = v[0];
    res[45][1] = -v[1];
    res[45][2] = v[2];
    phase[45] = v[0]*1./2;
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    phase[46] = (v[1]+v[2])*1./2;
    res[47][0] = v[0];
    res[47][1] = -v[1];
    res[47][2] = v[2];
    phase[47] = (v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ia_3d {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1]+1./4;
    res[4][1] = v[0]+3./4;
    res[4][2] = v[2]+1./4;
    res[5][0] = v[1]+1./4;
    res[5][1] = -v[0]+3./4;
    res[5][2] = -v[2]+1./4;
    res[6][0] = -v[1]+3./4;
    res[6][1] = v[0]+1./4;
    res[6][2] = v[2]+3./4;
    res[7][0] = v[1]+3./4;
    res[7][1] = -v[0]+1./4;
    res[7][2] = -v[2]+3./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1]+1./4;
    res[12][1] = -v[0]+1./4;
    res[12][2] = v[2]+3./4;
    res[13][0] = -v[1]+1./4;
    res[13][1] = v[0]+1./4;
    res[13][2] = -v[2]+3./4;
    res[14][0] = v[1]+3./4;
    res[14][1] = -v[0]+3./4;
    res[14][2] = v[2]+1./4;
    res[15][0] = -v[1]+3./4;
    res[15][1] = v[0]+3./4;
    res[15][2] = -v[2]+1./4;
    res[16][0] = v[0]+1./4;
    res[16][1] = -v[2]+1./4;
    res[16][2] = v[1]+3./4;
    res[17][0] = -v[0]+1./4;
    res[17][1] = v[2]+1./4;
    res[17][2] = -v[1]+3./4;
    res[18][0] = v[0]+3./4;
    res[18][1] = -v[2]+3./4;
    res[18][2] = v[1]+1./4;
    res[19][0] = -v[0]+3./4;
    res[19][1] = v[2]+3./4;
    res[19][2] = -v[1]+1./4;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2]+1./2;
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = -v[2];
    res[23][0] = -v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = v[2];
    res[24][0] = v[0]+3./4;
    res[24][1] = v[2]+1./4;
    res[24][2] = -v[1]+1./4;
    res[25][0] = -v[0]+3./4;
    res[25][1] = -v[2]+1./4;
    res[25][2] = v[1]+1./4;
    res[26][0] = v[0]+1./4;
    res[26][1] = v[2]+3./4;
    res[26][2] = -v[1]+3./4;
    res[27][0] = -v[0]+1./4;
    res[27][1] = -v[2]+3./4;
    res[27][2] = v[1]+3./4;
    res[28][0] = v[2]+3./4;
    res[28][1] = v[1]+1./4;
    res[28][2] = -v[0]+1./4;
    res[29][0] = -v[2]+3./4;
    res[29][1] = -v[1]+1./4;
    res[29][2] = v[0]+1./4;
    res[30][0] = v[2]+1./4;
    res[30][1] = v[1]+3./4;
    res[30][2] = -v[0]+3./4;
    res[31][0] = -v[2]+1./4;
    res[31][1] = -v[1]+3./4;
    res[31][2] = v[0]+3./4;
    res[32][0] = -v[0]+1./2;
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = v[0]+1./2;
    res[33][1] = -v[1];
    res[33][2] = v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1]+1./2;
    res[34][2] = -v[2]+1./2;
    res[35][0] = v[0];
    res[35][1] = -v[1]+1./2;
    res[35][2] = v[2]+1./2;
    res[36][0] = -v[2]+1./4;
    res[36][1] = v[1]+3./4;
    res[36][2] = v[0]+1./4;
    res[37][0] = v[2]+1./4;
    res[37][1] = -v[1]+3./4;
    res[37][2] = -v[0]+1./4;
    res[38][0] = -v[2]+3./4;
    res[38][1] = v[1]+1./4;
    res[38][2] = v[0]+3./4;
    res[39][0] = v[2]+3./4;
    res[39][1] = -v[1]+1./4;
    res[39][2] = -v[0]+3./4;
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = -v[2];
    res[41][1] = -v[0];
    res[41][2] = -v[1];
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0]+1./2;
    res[42][2] = v[1]+1./2;
    res[43][0] = -v[2]+1./2;
    res[43][1] = -v[0]+1./2;
    res[43][2] = -v[1]+1./2;
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = -v[1];
    res[45][1] = -v[2];
    res[45][2] = -v[0];
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2]+1./2;
    res[46][2] = v[0]+1./2;
    res[47][0] = -v[1]+1./2;
    res[47][1] = -v[2]+1./2;
    res[47][2] = -v[0]+1./2;
    res[48][0] = -v[1];
    res[48][1] = -v[2]+1./2;
    res[48][2] = v[0];
    res[49][0] = v[1];
    res[49][1] = v[2]+1./2;
    res[49][2] = -v[0];
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2];
    res[50][2] = v[0]+1./2;
    res[51][0] = v[1]+1./2;
    res[51][1] = v[2];
    res[51][2] = -v[0]+1./2;
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1]+1./2;
    res[53][0] = -v[2];
    res[53][1] = v[0];
    res[53][2] = v[1]+1./2;
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0]+1./2;
    res[54][2] = -v[1];
    res[55][0] = -v[2]+1./2;
    res[55][1] = v[0]+1./2;
    res[55][2] = v[1];
    res[56][0] = -v[1]+1./2;
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = v[1]+1./2;
    res[57][1] = -v[2];
    res[57][2] = v[0];
    res[58][0] = -v[1];
    res[58][1] = v[2]+1./2;
    res[58][2] = -v[0]+1./2;
    res[59][0] = v[1];
    res[59][1] = -v[2]+1./2;
    res[59][2] = v[0]+1./2;
    res[60][0] = -v[2];
    res[60][1] = -v[0]+1./2;
    res[60][2] = v[1];
    res[61][0] = v[2];
    res[61][1] = v[0]+1./2;
    res[61][2] = -v[1];
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0];
    res[62][2] = v[1]+1./2;
    res[63][0] = v[2]+1./2;
    res[63][1] = v[0];
    res[63][2] = -v[1]+1./2;
    res[64][0] = -v[2]+1./2;
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = v[2]+1./2;
    res[65][1] = -v[0];
    res[65][2] = v[1];
    res[66][0] = -v[2];
    res[66][1] = v[0]+1./2;
    res[66][2] = -v[1]+1./2;
    res[67][0] = v[2];
    res[67][1] = -v[0]+1./2;
    res[67][2] = v[1]+1./2;
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0]+1./2;
    res[69][0] = -v[1];
    res[69][1] = v[2];
    res[69][2] = v[0]+1./2;
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2]+1./2;
    res[70][2] = -v[0];
    res[71][0] = -v[1]+1./2;
    res[71][1] = v[2]+1./2;
    res[71][2] = v[0];
    res[72][0] = v[1]+3./4;
    res[72][1] = v[0]+1./4;
    res[72][2] = -v[2]+1./4;
    res[73][0] = -v[1]+3./4;
    res[73][1] = -v[0]+1./4;
    res[73][2] = v[2]+1./4;
    res[74][0] = v[1]+1./4;
    res[74][1] = v[0]+3./4;
    res[74][2] = -v[2]+3./4;
    res[75][0] = -v[1]+1./4;
    res[75][1] = -v[0]+3./4;
    res[75][2] = v[2]+3./4;
    res[76][0] = -v[1]+1./4;
    res[76][1] = -v[0]+1./4;
    res[76][2] = -v[2]+1./4;
    res[77][0] = v[1]+1./4;
    res[77][1] = v[0]+1./4;
    res[77][2] = v[2]+1./4;
    res[78][0] = -v[1]+3./4;
    res[78][1] = -v[0]+3./4;
    res[78][2] = -v[2]+3./4;
    res[79][0] = v[1]+3./4;
    res[79][1] = v[0]+3./4;
    res[79][2] = v[2]+3./4;
    res[80][0] = -v[0]+1./4;
    res[80][1] = v[2]+3./4;
    res[80][2] = v[1]+1./4;
    res[81][0] = v[0]+1./4;
    res[81][1] = -v[2]+3./4;
    res[81][2] = -v[1]+1./4;
    res[82][0] = -v[0]+3./4;
    res[82][1] = v[2]+1./4;
    res[82][2] = v[1]+3./4;
    res[83][0] = v[0]+3./4;
    res[83][1] = -v[2]+1./4;
    res[83][2] = -v[1]+3./4;
    res[84][0] = -v[0]+1./4;
    res[84][1] = -v[2]+1./4;
    res[84][2] = -v[1]+1./4;
    res[85][0] = v[0]+1./4;
    res[85][1] = v[2]+1./4;
    res[85][2] = v[1]+1./4;
    res[86][0] = -v[0]+3./4;
    res[86][1] = -v[2]+3./4;
    res[86][2] = -v[1]+3./4;
    res[87][0] = v[0]+3./4;
    res[87][1] = v[2]+3./4;
    res[87][2] = v[1]+3./4;
    res[88][0] = v[2]+1./4;
    res[88][1] = -v[1]+1./4;
    res[88][2] = v[0]+3./4;
    res[89][0] = -v[2]+1./4;
    res[89][1] = v[1]+1./4;
    res[89][2] = -v[0]+3./4;
    res[90][0] = v[2]+3./4;
    res[90][1] = -v[1]+3./4;
    res[90][2] = v[0]+1./4;
    res[91][0] = -v[2]+3./4;
    res[91][1] = v[1]+3./4;
    res[91][2] = -v[0]+1./4;
    res[92][0] = -v[2]+1./4;
    res[92][1] = -v[1]+1./4;
    res[92][2] = -v[0]+1./4;
    res[93][0] = v[2]+1./4;
    res[93][1] = v[1]+1./4;
    res[93][2] = v[0]+1./4;
    res[94][0] = -v[2]+3./4;
    res[94][1] = -v[1]+3./4;
    res[94][2] = -v[0]+3./4;
    res[95][0] = v[2]+3./4;
    res[95][1] = v[1]+3./4;
    res[95][2] = v[0]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = v[0];
    res[33][1] = -v[1];
    res[33][2] = v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = v[0];
    res[35][1] = -v[1];
    res[35][2] = v[2];
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = -v[1];
    res[41][1] = -v[2];
    res[41][2] = -v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = -v[1];
    res[43][1] = -v[2];
    res[43][2] = -v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = -v[2];
    res[45][1] = -v[0];
    res[45][2] = -v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = -v[2];
    res[47][1] = -v[0];
    res[47][2] = -v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = -v[2];
    res[49][1] = v[0];
    res[49][2] = v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = -v[2];
    res[51][1] = v[0];
    res[51][2] = v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = v[1];
    res[53][1] = v[2];
    res[53][2] = -v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = v[1];
    res[55][1] = v[2];
    res[55][2] = -v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = v[2];
    res[57][1] = v[0];
    res[57][2] = -v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = v[2];
    res[59][1] = v[0];
    res[59][2] = -v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = v[1];
    res[61][1] = -v[2];
    res[61][2] = v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = v[1];
    res[63][1] = -v[2];
    res[63][2] = v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = -v[1];
    res[65][1] = v[2];
    res[65][2] = v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = -v[1];
    res[67][1] = v[2];
    res[67][2] = v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    phase[16] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    phase[17] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    phase[18] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    phase[19] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = v[2]*1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] = v[2]*1./2;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[1])*1./2;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[1])*1./2;
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    phase[24] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    phase[25] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    phase[26] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    phase[27] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    phase[28] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    phase[29] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    phase[30] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    phase[31] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] = v[0]*1./2;
    res[33][0] = v[0];
    res[33][1] = -v[1];
    res[33][2] = v[2];
    phase[33] = v[0]*1./2;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[1]+v[2])*1./2;
    res[35][0] = v[0];
    res[35][1] = -v[1];
    res[35][2] = v[2];
    phase[35] = (v[1]+v[2])*1./2;
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    phase[36] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    phase[37] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    phase[38] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    phase[39] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = -v[1];
    res[41][1] = -v[2];
    res[41][2] = -v[0];
    phase[41] =  0;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[1]+v[2])*1./2;
    res[43][0] = -v[1];
    res[43][1] = -v[2];
    res[43][2] = -v[0];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = -v[2];
    res[45][1] = -v[0];
    res[45][2] = -v[1];
    phase[45] =  0;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[1]+v[2])*1./2;
    res[47][0] = -v[2];
    res[47][1] = -v[0];
    res[47][2] = -v[1];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] = v[1]*1./2;
    res[49][0] = -v[2];
    res[49][1] = v[0];
    res[49][2] = v[1];
    phase[49] = v[1]*1./2;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[2])*1./2;
    res[51][0] = -v[2];
    res[51][1] = v[0];
    res[51][2] = v[1];
    phase[51] = (v[0]+v[2])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] = v[2]*1./2;
    res[53][0] = v[1];
    res[53][1] = v[2];
    res[53][2] = -v[0];
    phase[53] = v[2]*1./2;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[1])*1./2;
    res[55][0] = v[1];
    res[55][1] = v[2];
    res[55][2] = -v[0];
    phase[55] = (v[0]+v[1])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] = v[0]*1./2;
    res[57][0] = v[2];
    res[57][1] = v[0];
    res[57][2] = -v[1];
    phase[57] = v[0]*1./2;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[1]+v[2])*1./2;
    res[59][0] = v[2];
    res[59][1] = v[0];
    res[59][2] = -v[1];
    phase[59] = (v[1]+v[2])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] = v[1]*1./2;
    res[61][0] = v[1];
    res[61][1] = -v[2];
    res[61][2] = v[0];
    phase[61] = v[1]*1./2;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[2])*1./2;
    res[63][0] = v[1];
    res[63][1] = -v[2];
    res[63][2] = v[0];
    phase[63] = (v[0]+v[2])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] = v[0]*1./2;
    res[65][0] = -v[1];
    res[65][1] = v[2];
    res[65][2] = v[0];
    phase[65] = v[0]*1./2;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[1]+v[2])*1./2;
    res[67][0] = -v[1];
    res[67][1] = v[2];
    res[67][2] = v[0];
    phase[67] = (v[1]+v[2])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] = v[2]*1./2;
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    phase[69] = v[2]*1./2;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[1])*1./2;
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    phase[71] = (v[0]+v[1])*1./2;
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    phase[72] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    phase[73] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    phase[74] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    phase[75] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    phase[76] = (v[0]+v[1]+v[2])*1./4;
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    phase[77] = (v[0]+v[1]+v[2])*1./4;
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    phase[78] = (v[0]+v[1]+v[2])*3./4;
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    phase[79] = (v[0]+v[1]+v[2])*3./4;
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    phase[80] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    phase[81] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    phase[82] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    phase[83] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    phase[84] = (v[0]+v[1]+v[2])*1./4;
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    phase[85] = (v[0]+v[1]+v[2])*1./4;
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    phase[86] = (v[0]+v[1]+v[2])*3./4;
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    phase[87] = (v[0]+v[1]+v[2])*3./4;
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    phase[88] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    phase[89] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    phase[90] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    phase[91] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    phase[92] = (v[0]+v[1]+v[2])*1./4;
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    phase[93] = (v[0]+v[1]+v[2])*1./4;
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    phase[94] = (v[0]+v[1]+v[2])*3./4;
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
    phase[95] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=96;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ib11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Iba2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ibam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ibca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ibm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ibmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ic {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ic11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ic2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ic2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Icab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Icma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Icmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[1]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = v[2]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[1]+1./2;
    res[7][0] = -v[2]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[1]+1./2;
    res[8][0] = v[1];
    res[8][1] = v[2];
    res[8][2] = v[0];
    res[9][0] = -v[1];
    res[9][1] = -v[2];
    res[9][2] = -v[0];
    res[10][0] = v[1]+1./2;
    res[10][1] = v[2]+1./2;
    res[10][2] = v[0]+1./2;
    res[11][0] = -v[1]+1./2;
    res[11][1] = -v[2]+1./2;
    res[11][2] = -v[0]+1./2;
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = v[1];
    res[13][1] = v[2];
    res[13][2] = -v[0];
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[2]+1./2;
    res[14][2] = v[0]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[2]+1./2;
    res[15][2] = -v[0]+1./2;
    res[16][0] = v[2];
    res[16][1] = -v[0];
    res[16][2] = -v[1];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = v[1];
    res[18][0] = v[2]+1./2;
    res[18][1] = -v[0]+1./2;
    res[18][2] = -v[1]+1./2;
    res[19][0] = -v[2]+1./2;
    res[19][1] = v[0]+1./2;
    res[19][2] = v[1]+1./2;
    res[20][0] = -v[1];
    res[20][1] = v[2];
    res[20][2] = -v[0];
    res[21][0] = v[1];
    res[21][1] = -v[2];
    res[21][2] = v[0];
    res[22][0] = -v[1]+1./2;
    res[22][1] = v[2]+1./2;
    res[22][2] = -v[0]+1./2;
    res[23][0] = v[1]+1./2;
    res[23][1] = -v[2]+1./2;
    res[23][2] = v[0]+1./2;
    res[24][0] = -v[2];
    res[24][1] = -v[0];
    res[24][2] = v[1];
    res[25][0] = v[2];
    res[25][1] = v[0];
    res[25][2] = -v[1];
    res[26][0] = -v[2]+1./2;
    res[26][1] = -v[0]+1./2;
    res[26][2] = v[1]+1./2;
    res[27][0] = v[2]+1./2;
    res[27][1] = v[0]+1./2;
    res[27][2] = -v[1]+1./2;
    res[28][0] = -v[2];
    res[28][1] = v[0];
    res[28][2] = -v[1];
    res[29][0] = v[2];
    res[29][1] = -v[0];
    res[29][2] = v[1];
    res[30][0] = -v[2]+1./2;
    res[30][1] = v[0]+1./2;
    res[30][2] = -v[1]+1./2;
    res[31][0] = v[2]+1./2;
    res[31][1] = -v[0]+1./2;
    res[31][2] = v[1]+1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    res[34][0] = v[1]+1./2;
    res[34][1] = -v[2]+1./2;
    res[34][2] = -v[0]+1./2;
    res[35][0] = -v[1]+1./2;
    res[35][1] = v[2]+1./2;
    res[35][2] = v[0]+1./2;
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    res[37][0] = v[0];
    res[37][1] = v[1];
    res[37][2] = -v[2];
    res[38][0] = -v[0]+1./2;
    res[38][1] = -v[1]+1./2;
    res[38][2] = v[2]+1./2;
    res[39][0] = v[0]+1./2;
    res[39][1] = v[1]+1./2;
    res[39][2] = -v[2]+1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0]+1./2;
    res[42][1] = -v[1]+1./2;
    res[42][2] = -v[2]+1./2;
    res[43][0] = -v[0]+1./2;
    res[43][1] = v[1]+1./2;
    res[43][2] = v[2]+1./2;
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = v[0];
    res[45][1] = -v[1];
    res[45][2] = v[2];
    res[46][0] = -v[0]+1./2;
    res[46][1] = v[1]+1./2;
    res[46][2] = -v[2]+1./2;
    res[47][0] = v[0]+1./2;
    res[47][1] = -v[1]+1./2;
    res[47][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    res[7][0] = -v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = -v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[2];
    res[13][1] = v[0];
    res[13][2] = v[1];
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    res[15][0] = -v[2];
    res[15][1] = v[0];
    res[15][2] = v[1];
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    res[17][0] = v[1];
    res[17][1] = v[2];
    res[17][2] = -v[0];
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    res[19][0] = v[1];
    res[19][1] = v[2];
    res[19][2] = -v[0];
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    res[21][0] = v[2];
    res[21][1] = v[0];
    res[21][2] = -v[1];
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = -v[1];
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    res[25][0] = v[1];
    res[25][1] = -v[2];
    res[25][2] = v[0];
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    res[27][0] = v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    res[29][0] = -v[1];
    res[29][1] = v[2];
    res[29][2] = v[0];
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = v[0];
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    res[37][0] = v[0];
    res[37][1] = v[1];
    res[37][2] = -v[2];
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    res[39][0] = v[0];
    res[39][1] = v[1];
    res[39][2] = -v[2];
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    res[45][0] = v[0];
    res[45][1] = -v[1];
    res[45][2] = v[2];
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    res[47][0] = v[0];
    res[47][1] = -v[1];
    res[47][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[2];
    res[6][2] = v[0];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[2];
    res[8][1] = v[0];
    res[8][2] = v[1];
    phase[8] =  0;
    res[9][0] = -v[2];
    res[9][1] = -v[0];
    res[9][2] = -v[1];
    phase[9] =  0;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[2];
    res[11][1] = -v[0];
    res[11][2] = -v[1];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[2];
    res[13][1] = v[0];
    res[13][2] = v[1];
    phase[13] =  0;
    res[14][0] = v[2];
    res[14][1] = -v[0];
    res[14][2] = -v[1];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = -v[2];
    res[15][1] = v[0];
    res[15][2] = v[1];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[1];
    res[16][1] = -v[2];
    res[16][2] = v[0];
    phase[16] =  0;
    res[17][0] = v[1];
    res[17][1] = v[2];
    res[17][2] = -v[0];
    phase[17] =  0;
    res[18][0] = -v[1];
    res[18][1] = -v[2];
    res[18][2] = v[0];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = v[1];
    res[19][1] = v[2];
    res[19][2] = -v[0];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = -v[2];
    res[20][1] = -v[0];
    res[20][2] = v[1];
    phase[20] =  0;
    res[21][0] = v[2];
    res[21][1] = v[0];
    res[21][2] = -v[1];
    phase[21] =  0;
    res[22][0] = -v[2];
    res[22][1] = -v[0];
    res[22][2] = v[1];
    phase[22] = (v[0]+v[1]+v[2])*1./2;
    res[23][0] = v[2];
    res[23][1] = v[0];
    res[23][2] = -v[1];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = -v[1];
    res[24][1] = v[2];
    res[24][2] = -v[0];
    phase[24] =  0;
    res[25][0] = v[1];
    res[25][1] = -v[2];
    res[25][2] = v[0];
    phase[25] =  0;
    res[26][0] = -v[1];
    res[26][1] = v[2];
    res[26][2] = -v[0];
    phase[26] = (v[0]+v[1]+v[2])*1./2;
    res[27][0] = v[1];
    res[27][1] = -v[2];
    res[27][2] = v[0];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = v[1];
    res[28][1] = -v[2];
    res[28][2] = -v[0];
    phase[28] =  0;
    res[29][0] = -v[1];
    res[29][1] = v[2];
    res[29][2] = v[0];
    phase[29] =  0;
    res[30][0] = v[1];
    res[30][1] = -v[2];
    res[30][2] = -v[0];
    phase[30] = (v[0]+v[1]+v[2])*1./2;
    res[31][0] = -v[1];
    res[31][1] = v[2];
    res[31][2] = v[0];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    phase[32] =  0;
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    phase[33] =  0;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = (v[0]+v[1]+v[2])*1./2;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] = (v[0]+v[1]+v[2])*1./2;
    res[36][0] = -v[0];
    res[36][1] = -v[1];
    res[36][2] = v[2];
    phase[36] =  0;
    res[37][0] = v[0];
    res[37][1] = v[1];
    res[37][2] = -v[2];
    phase[37] =  0;
    res[38][0] = -v[0];
    res[38][1] = -v[1];
    res[38][2] = v[2];
    phase[38] = (v[0]+v[1]+v[2])*1./2;
    res[39][0] = v[0];
    res[39][1] = v[1];
    res[39][2] = -v[2];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = v[0];
    res[40][1] = -v[1];
    res[40][2] = -v[2];
    phase[40] =  0;
    res[41][0] = -v[0];
    res[41][1] = v[1];
    res[41][2] = v[2];
    phase[41] =  0;
    res[42][0] = v[0];
    res[42][1] = -v[1];
    res[42][2] = -v[2];
    phase[42] = (v[0]+v[1]+v[2])*1./2;
    res[43][0] = -v[0];
    res[43][1] = v[1];
    res[43][2] = v[2];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = -v[0];
    res[44][1] = v[1];
    res[44][2] = -v[2];
    phase[44] =  0;
    res[45][0] = v[0];
    res[45][1] = -v[1];
    res[45][2] = v[2];
    phase[45] =  0;
    res[46][0] = -v[0];
    res[46][1] = v[1];
    res[46][2] = -v[2];
    phase[46] = (v[0]+v[1]+v[2])*1./2;
    res[47][0] = v[0];
    res[47][1] = -v[1];
    res[47][2] = v[2];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = -v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = -v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = v[2]+1./2;
    res[15][0] = -v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = -v[2]+1./2;
    res[16][0] = v[0];
    res[16][1] = -v[2];
    res[16][2] = v[1];
    res[17][0] = -v[0];
    res[17][1] = v[2];
    res[17][2] = -v[1];
    res[18][0] = v[0]+1./2;
    res[18][1] = -v[2]+1./2;
    res[18][2] = v[1]+1./2;
    res[19][0] = -v[0]+1./2;
    res[19][1] = v[2]+1./2;
    res[19][2] = -v[1]+1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = v[0]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = -v[2]+1./2;
    res[23][0] = -v[0]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = v[2]+1./2;
    res[24][0] = v[0];
    res[24][1] = v[2];
    res[24][2] = -v[1];
    res[25][0] = -v[0];
    res[25][1] = -v[2];
    res[25][2] = v[1];
    res[26][0] = v[0]+1./2;
    res[26][1] = v[2]+1./2;
    res[26][2] = -v[1]+1./2;
    res[27][0] = -v[0]+1./2;
    res[27][1] = -v[2]+1./2;
    res[27][2] = v[1]+1./2;
    res[28][0] = v[2];
    res[28][1] = v[1];
    res[28][2] = -v[0];
    res[29][0] = -v[2];
    res[29][1] = -v[1];
    res[29][2] = v[0];
    res[30][0] = v[2]+1./2;
    res[30][1] = v[1]+1./2;
    res[30][2] = -v[0]+1./2;
    res[31][0] = -v[2]+1./2;
    res[31][1] = -v[1]+1./2;
    res[31][2] = v[0]+1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = v[0];
    res[33][1] = -v[1];
    res[33][2] = v[2];
    res[34][0] = -v[0]+1./2;
    res[34][1] = v[1]+1./2;
    res[34][2] = -v[2]+1./2;
    res[35][0] = v[0]+1./2;
    res[35][1] = -v[1]+1./2;
    res[35][2] = v[2]+1./2;
    res[36][0] = -v[2];
    res[36][1] = v[1];
    res[36][2] = v[0];
    res[37][0] = v[2];
    res[37][1] = -v[1];
    res[37][2] = -v[0];
    res[38][0] = -v[2]+1./2;
    res[38][1] = v[1]+1./2;
    res[38][2] = v[0]+1./2;
    res[39][0] = v[2]+1./2;
    res[39][1] = -v[1]+1./2;
    res[39][2] = -v[0]+1./2;
    res[40][0] = v[2];
    res[40][1] = v[0];
    res[40][2] = v[1];
    res[41][0] = -v[2];
    res[41][1] = -v[0];
    res[41][2] = -v[1];
    res[42][0] = v[2]+1./2;
    res[42][1] = v[0]+1./2;
    res[42][2] = v[1]+1./2;
    res[43][0] = -v[2]+1./2;
    res[43][1] = -v[0]+1./2;
    res[43][2] = -v[1]+1./2;
    res[44][0] = v[1];
    res[44][1] = v[2];
    res[44][2] = v[0];
    res[45][0] = -v[1];
    res[45][1] = -v[2];
    res[45][2] = -v[0];
    res[46][0] = v[1]+1./2;
    res[46][1] = v[2]+1./2;
    res[46][2] = v[0]+1./2;
    res[47][0] = -v[1]+1./2;
    res[47][1] = -v[2]+1./2;
    res[47][2] = -v[0]+1./2;
    res[48][0] = -v[1];
    res[48][1] = -v[2];
    res[48][2] = v[0];
    res[49][0] = v[1];
    res[49][1] = v[2];
    res[49][2] = -v[0];
    res[50][0] = -v[1]+1./2;
    res[50][1] = -v[2]+1./2;
    res[50][2] = v[0]+1./2;
    res[51][0] = v[1]+1./2;
    res[51][1] = v[2]+1./2;
    res[51][2] = -v[0]+1./2;
    res[52][0] = v[2];
    res[52][1] = -v[0];
    res[52][2] = -v[1];
    res[53][0] = -v[2];
    res[53][1] = v[0];
    res[53][2] = v[1];
    res[54][0] = v[2]+1./2;
    res[54][1] = -v[0]+1./2;
    res[54][2] = -v[1]+1./2;
    res[55][0] = -v[2]+1./2;
    res[55][1] = v[0]+1./2;
    res[55][2] = v[1]+1./2;
    res[56][0] = -v[1];
    res[56][1] = v[2];
    res[56][2] = -v[0];
    res[57][0] = v[1];
    res[57][1] = -v[2];
    res[57][2] = v[0];
    res[58][0] = -v[1]+1./2;
    res[58][1] = v[2]+1./2;
    res[58][2] = -v[0]+1./2;
    res[59][0] = v[1]+1./2;
    res[59][1] = -v[2]+1./2;
    res[59][2] = v[0]+1./2;
    res[60][0] = -v[2];
    res[60][1] = -v[0];
    res[60][2] = v[1];
    res[61][0] = v[2];
    res[61][1] = v[0];
    res[61][2] = -v[1];
    res[62][0] = -v[2]+1./2;
    res[62][1] = -v[0]+1./2;
    res[62][2] = v[1]+1./2;
    res[63][0] = v[2]+1./2;
    res[63][1] = v[0]+1./2;
    res[63][2] = -v[1]+1./2;
    res[64][0] = -v[2];
    res[64][1] = v[0];
    res[64][2] = -v[1];
    res[65][0] = v[2];
    res[65][1] = -v[0];
    res[65][2] = v[1];
    res[66][0] = -v[2]+1./2;
    res[66][1] = v[0]+1./2;
    res[66][2] = -v[1]+1./2;
    res[67][0] = v[2]+1./2;
    res[67][1] = -v[0]+1./2;
    res[67][2] = v[1]+1./2;
    res[68][0] = v[1];
    res[68][1] = -v[2];
    res[68][2] = -v[0];
    res[69][0] = -v[1];
    res[69][1] = v[2];
    res[69][2] = v[0];
    res[70][0] = v[1]+1./2;
    res[70][1] = -v[2]+1./2;
    res[70][2] = -v[0]+1./2;
    res[71][0] = -v[1]+1./2;
    res[71][1] = v[2]+1./2;
    res[71][2] = v[0]+1./2;
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    res[74][0] = v[1]+1./2;
    res[74][1] = v[0]+1./2;
    res[74][2] = -v[2]+1./2;
    res[75][0] = -v[1]+1./2;
    res[75][1] = -v[0]+1./2;
    res[75][2] = v[2]+1./2;
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    res[78][0] = -v[1]+1./2;
    res[78][1] = -v[0]+1./2;
    res[78][2] = -v[2]+1./2;
    res[79][0] = v[1]+1./2;
    res[79][1] = v[0]+1./2;
    res[79][2] = v[2]+1./2;
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    res[82][0] = -v[0]+1./2;
    res[82][1] = v[2]+1./2;
    res[82][2] = v[1]+1./2;
    res[83][0] = v[0]+1./2;
    res[83][1] = -v[2]+1./2;
    res[83][2] = -v[1]+1./2;
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    res[86][0] = -v[0]+1./2;
    res[86][1] = -v[2]+1./2;
    res[86][2] = -v[1]+1./2;
    res[87][0] = v[0]+1./2;
    res[87][1] = v[2]+1./2;
    res[87][2] = v[1]+1./2;
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    res[90][0] = v[2]+1./2;
    res[90][1] = -v[1]+1./2;
    res[90][2] = v[0]+1./2;
    res[91][0] = -v[2]+1./2;
    res[91][1] = v[1]+1./2;
    res[91][2] = -v[0]+1./2;
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    res[94][0] = -v[2]+1./2;
    res[94][1] = -v[1]+1./2;
    res[94][2] = -v[0]+1./2;
    res[95][0] = v[2]+1./2;
    res[95][1] = v[1]+1./2;
    res[95][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    res[33][0] = v[0];
    res[33][1] = -v[1];
    res[33][2] = v[2];
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    res[35][0] = v[0];
    res[35][1] = -v[1];
    res[35][2] = v[2];
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    res[41][0] = -v[1];
    res[41][1] = -v[2];
    res[41][2] = -v[0];
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    res[43][0] = -v[1];
    res[43][1] = -v[2];
    res[43][2] = -v[0];
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    res[45][0] = -v[2];
    res[45][1] = -v[0];
    res[45][2] = -v[1];
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    res[47][0] = -v[2];
    res[47][1] = -v[0];
    res[47][2] = -v[1];
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    res[49][0] = -v[2];
    res[49][1] = v[0];
    res[49][2] = v[1];
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    res[51][0] = -v[2];
    res[51][1] = v[0];
    res[51][2] = v[1];
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    res[53][0] = v[1];
    res[53][1] = v[2];
    res[53][2] = -v[0];
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    res[55][0] = v[1];
    res[55][1] = v[2];
    res[55][2] = -v[0];
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    res[57][0] = v[2];
    res[57][1] = v[0];
    res[57][2] = -v[1];
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    res[59][0] = v[2];
    res[59][1] = v[0];
    res[59][2] = -v[1];
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    res[61][0] = v[1];
    res[61][1] = -v[2];
    res[61][2] = v[0];
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    res[63][0] = v[1];
    res[63][1] = -v[2];
    res[63][2] = v[0];
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    res[65][0] = -v[1];
    res[65][1] = v[2];
    res[65][2] = v[0];
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    res[67][0] = -v[1];
    res[67][1] = v[2];
    res[67][2] = v[0];
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[1];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = v[0];
    res[16][1] = v[2];
    res[16][2] = -v[1];
    phase[16] =  0;
    res[17][0] = -v[0];
    res[17][1] = -v[2];
    res[17][2] = v[1];
    phase[17] =  0;
    res[18][0] = v[0];
    res[18][1] = v[2];
    res[18][2] = -v[1];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = -v[0];
    res[19][1] = -v[2];
    res[19][2] = v[1];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] =  0;
    res[22][0] = v[0];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[1]+v[2])*1./2;
    res[23][0] = -v[0];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
    res[24][0] = v[0];
    res[24][1] = -v[2];
    res[24][2] = v[1];
    phase[24] =  0;
    res[25][0] = -v[0];
    res[25][1] = v[2];
    res[25][2] = -v[1];
    phase[25] =  0;
    res[26][0] = v[0];
    res[26][1] = -v[2];
    res[26][2] = v[1];
    phase[26] = (v[0]+v[1]+v[2])*1./2;
    res[27][0] = -v[0];
    res[27][1] = v[2];
    res[27][2] = -v[1];
    phase[27] = (v[0]+v[1]+v[2])*1./2;
    res[28][0] = -v[2];
    res[28][1] = v[1];
    res[28][2] = v[0];
    phase[28] =  0;
    res[29][0] = v[2];
    res[29][1] = -v[1];
    res[29][2] = -v[0];
    phase[29] =  0;
    res[30][0] = -v[2];
    res[30][1] = v[1];
    res[30][2] = v[0];
    phase[30] = (v[0]+v[1]+v[2])*1./2;
    res[31][0] = v[2];
    res[31][1] = -v[1];
    res[31][2] = -v[0];
    phase[31] = (v[0]+v[1]+v[2])*1./2;
    res[32][0] = -v[0];
    res[32][1] = v[1];
    res[32][2] = -v[2];
    phase[32] =  0;
    res[33][0] = v[0];
    res[33][1] = -v[1];
    res[33][2] = v[2];
    phase[33] =  0;
    res[34][0] = -v[0];
    res[34][1] = v[1];
    res[34][2] = -v[2];
    phase[34] = (v[0]+v[1]+v[2])*1./2;
    res[35][0] = v[0];
    res[35][1] = -v[1];
    res[35][2] = v[2];
    phase[35] = (v[0]+v[1]+v[2])*1./2;
    res[36][0] = v[2];
    res[36][1] = v[1];
    res[36][2] = -v[0];
    phase[36] =  0;
    res[37][0] = -v[2];
    res[37][1] = -v[1];
    res[37][2] = v[0];
    phase[37] =  0;
    res[38][0] = v[2];
    res[38][1] = v[1];
    res[38][2] = -v[0];
    phase[38] = (v[0]+v[1]+v[2])*1./2;
    res[39][0] = -v[2];
    res[39][1] = -v[1];
    res[39][2] = v[0];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = v[1];
    res[40][1] = v[2];
    res[40][2] = v[0];
    phase[40] =  0;
    res[41][0] = -v[1];
    res[41][1] = -v[2];
    res[41][2] = -v[0];
    phase[41] =  0;
    res[42][0] = v[1];
    res[42][1] = v[2];
    res[42][2] = v[0];
    phase[42] = (v[0]+v[1]+v[2])*1./2;
    res[43][0] = -v[1];
    res[43][1] = -v[2];
    res[43][2] = -v[0];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = v[2];
    res[44][1] = v[0];
    res[44][2] = v[1];
    phase[44] =  0;
    res[45][0] = -v[2];
    res[45][1] = -v[0];
    res[45][2] = -v[1];
    phase[45] =  0;
    res[46][0] = v[2];
    res[46][1] = v[0];
    res[46][2] = v[1];
    phase[46] = (v[0]+v[1]+v[2])*1./2;
    res[47][0] = -v[2];
    res[47][1] = -v[0];
    res[47][2] = -v[1];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
    res[48][0] = v[2];
    res[48][1] = -v[0];
    res[48][2] = -v[1];
    phase[48] =  0;
    res[49][0] = -v[2];
    res[49][1] = v[0];
    res[49][2] = v[1];
    phase[49] =  0;
    res[50][0] = v[2];
    res[50][1] = -v[0];
    res[50][2] = -v[1];
    phase[50] = (v[0]+v[1]+v[2])*1./2;
    res[51][0] = -v[2];
    res[51][1] = v[0];
    res[51][2] = v[1];
    phase[51] = (v[0]+v[1]+v[2])*1./2;
    res[52][0] = -v[1];
    res[52][1] = -v[2];
    res[52][2] = v[0];
    phase[52] =  0;
    res[53][0] = v[1];
    res[53][1] = v[2];
    res[53][2] = -v[0];
    phase[53] =  0;
    res[54][0] = -v[1];
    res[54][1] = -v[2];
    res[54][2] = v[0];
    phase[54] = (v[0]+v[1]+v[2])*1./2;
    res[55][0] = v[1];
    res[55][1] = v[2];
    res[55][2] = -v[0];
    phase[55] = (v[0]+v[1]+v[2])*1./2;
    res[56][0] = -v[2];
    res[56][1] = -v[0];
    res[56][2] = v[1];
    phase[56] =  0;
    res[57][0] = v[2];
    res[57][1] = v[0];
    res[57][2] = -v[1];
    phase[57] =  0;
    res[58][0] = -v[2];
    res[58][1] = -v[0];
    res[58][2] = v[1];
    phase[58] = (v[0]+v[1]+v[2])*1./2;
    res[59][0] = v[2];
    res[59][1] = v[0];
    res[59][2] = -v[1];
    phase[59] = (v[0]+v[1]+v[2])*1./2;
    res[60][0] = -v[1];
    res[60][1] = v[2];
    res[60][2] = -v[0];
    phase[60] =  0;
    res[61][0] = v[1];
    res[61][1] = -v[2];
    res[61][2] = v[0];
    phase[61] =  0;
    res[62][0] = -v[1];
    res[62][1] = v[2];
    res[62][2] = -v[0];
    phase[62] = (v[0]+v[1]+v[2])*1./2;
    res[63][0] = v[1];
    res[63][1] = -v[2];
    res[63][2] = v[0];
    phase[63] = (v[0]+v[1]+v[2])*1./2;
    res[64][0] = v[1];
    res[64][1] = -v[2];
    res[64][2] = -v[0];
    phase[64] =  0;
    res[65][0] = -v[1];
    res[65][1] = v[2];
    res[65][2] = v[0];
    phase[65] =  0;
    res[66][0] = v[1];
    res[66][1] = -v[2];
    res[66][2] = -v[0];
    phase[66] = (v[0]+v[1]+v[2])*1./2;
    res[67][0] = -v[1];
    res[67][1] = v[2];
    res[67][2] = v[0];
    phase[67] = (v[0]+v[1]+v[2])*1./2;
    res[68][0] = -v[2];
    res[68][1] = v[0];
    res[68][2] = -v[1];
    phase[68] =  0;
    res[69][0] = v[2];
    res[69][1] = -v[0];
    res[69][2] = v[1];
    phase[69] =  0;
    res[70][0] = -v[2];
    res[70][1] = v[0];
    res[70][2] = -v[1];
    phase[70] = (v[0]+v[1]+v[2])*1./2;
    res[71][0] = v[2];
    res[71][1] = -v[0];
    res[71][2] = v[1];
    phase[71] = (v[0]+v[1]+v[2])*1./2;
    res[72][0] = v[1];
    res[72][1] = v[0];
    res[72][2] = -v[2];
    phase[72] =  0;
    res[73][0] = -v[1];
    res[73][1] = -v[0];
    res[73][2] = v[2];
    phase[73] =  0;
    res[74][0] = v[1];
    res[74][1] = v[0];
    res[74][2] = -v[2];
    phase[74] = (v[0]+v[1]+v[2])*1./2;
    res[75][0] = -v[1];
    res[75][1] = -v[0];
    res[75][2] = v[2];
    phase[75] = (v[0]+v[1]+v[2])*1./2;
    res[76][0] = -v[1];
    res[76][1] = -v[0];
    res[76][2] = -v[2];
    phase[76] =  0;
    res[77][0] = v[1];
    res[77][1] = v[0];
    res[77][2] = v[2];
    phase[77] =  0;
    res[78][0] = -v[1];
    res[78][1] = -v[0];
    res[78][2] = -v[2];
    phase[78] = (v[0]+v[1]+v[2])*1./2;
    res[79][0] = v[1];
    res[79][1] = v[0];
    res[79][2] = v[2];
    phase[79] = (v[0]+v[1]+v[2])*1./2;
    res[80][0] = -v[0];
    res[80][1] = v[2];
    res[80][2] = v[1];
    phase[80] =  0;
    res[81][0] = v[0];
    res[81][1] = -v[2];
    res[81][2] = -v[1];
    phase[81] =  0;
    res[82][0] = -v[0];
    res[82][1] = v[2];
    res[82][2] = v[1];
    phase[82] = (v[0]+v[1]+v[2])*1./2;
    res[83][0] = v[0];
    res[83][1] = -v[2];
    res[83][2] = -v[1];
    phase[83] = (v[0]+v[1]+v[2])*1./2;
    res[84][0] = -v[0];
    res[84][1] = -v[2];
    res[84][2] = -v[1];
    phase[84] =  0;
    res[85][0] = v[0];
    res[85][1] = v[2];
    res[85][2] = v[1];
    phase[85] =  0;
    res[86][0] = -v[0];
    res[86][1] = -v[2];
    res[86][2] = -v[1];
    phase[86] = (v[0]+v[1]+v[2])*1./2;
    res[87][0] = v[0];
    res[87][1] = v[2];
    res[87][2] = v[1];
    phase[87] = (v[0]+v[1]+v[2])*1./2;
    res[88][0] = v[2];
    res[88][1] = -v[1];
    res[88][2] = v[0];
    phase[88] =  0;
    res[89][0] = -v[2];
    res[89][1] = v[1];
    res[89][2] = -v[0];
    phase[89] =  0;
    res[90][0] = v[2];
    res[90][1] = -v[1];
    res[90][2] = v[0];
    phase[90] = (v[0]+v[1]+v[2])*1./2;
    res[91][0] = -v[2];
    res[91][1] = v[1];
    res[91][2] = -v[0];
    phase[91] = (v[0]+v[1]+v[2])*1./2;
    res[92][0] = -v[2];
    res[92][1] = -v[1];
    res[92][2] = -v[0];
    phase[92] =  0;
    res[93][0] = v[2];
    res[93][1] = v[1];
    res[93][2] = v[0];
    phase[93] =  0;
    res[94][0] = -v[2];
    res[94][1] = -v[1];
    res[94][2] = -v[0];
    phase[94] = (v[0]+v[1]+v[2])*1./2;
    res[95][0] = v[2];
    res[95][1] = v[1];
    res[95][2] = v[0];
    phase[95] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=96;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Im2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Ima2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Imam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Imcb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Imcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0]+1./2;
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0]+1./2;
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[0]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Imm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Imma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1]+1./2;
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] = v[1]*1./2;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[1]*1./2;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Immb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Immm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = -v[0];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = v[0];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[0];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='I';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]-v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_31c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]-v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[0]+v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = v[0]-v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = v[0]-v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[0]+v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[0]+v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_31m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]-v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0]+v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = v[0]-v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = v[0]+v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
    res[8][0] = -v[0];
    res[8][1] = v[0]+v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_3c1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]-v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[0]+v[1];
    res[7][1] = v[1];
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[0]+v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = v[0];
    res[9][1] = v[0]-v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_3m1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]-v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+v[1];
    res[7][1] = v[1];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[0]+v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0];
    res[9][1] = v[0]-v[1];
    res[9][2] = v[2];
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0]+v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = v[2];
    phase[7] =  0;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = v[0];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_4 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_421c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_421m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_42c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_42m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_43m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = -v[1];
    res[7][2] = v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2];
    res[9][1] = -v[1];
    res[9][2] = -v[0];
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[2];
    res[15][1] = -v[0];
    res[15][2] = v[1];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[2];
    res[20][2] = -v[1];
    res[21][0] = v[0];
    res[21][1] = v[2];
    res[21][2] = v[1];
    res[22][0] = -v[2];
    res[22][1] = v[1];
    res[22][2] = -v[0];
    res[23][0] = v[2];
    res[23][1] = v[1];
    res[23][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[2];
    res[6][2] = -v[1];
    res[7][0] = v[2];
    res[7][1] = -v[1];
    res[7][2] = -v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[2];
    res[9][1] = -v[1];
    res[9][2] = v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[2];
    res[20][2] = -v[1];
    res[21][0] = v[0];
    res[21][1] = v[2];
    res[21][2] = v[1];
    res[22][0] = -v[2];
    res[22][1] = v[1];
    res[22][2] = -v[0];
    res[23][0] = v[2];
    res[23][1] = v[1];
    res[23][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[2];
    res[6][2] = -v[1];
    phase[6] =  0;
    res[7][0] = v[2];
    res[7][1] = -v[1];
    res[7][2] = -v[0];
    phase[7] =  0;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[2];
    res[9][1] = -v[1];
    res[9][2] = v[0];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] =  0;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = v[2];
    phase[18] =  0;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] =  0;
    res[20][0] = v[0];
    res[20][1] = -v[2];
    res[20][2] = -v[1];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = v[2];
    res[21][2] = v[1];
    phase[21] =  0;
    res[22][0] = -v[2];
    res[22][1] = v[1];
    res[22][2] = -v[0];
    phase[22] =  0;
    res[23][0] = v[2];
    res[23][1] = v[1];
    res[23][2] = v[0];
    phase[23] =  0;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_43n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1]+1./2;
    res[1][1] = -v[0]+1./2;
    res[1][2] = -v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[2]+1./2;
    res[4][2] = -v[1]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = -v[2]+1./2;
    res[6][2] = v[1]+1./2;
    res[7][0] = -v[2]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[0]+1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2]+1./2;
    res[9][1] = -v[1]+1./2;
    res[9][2] = -v[0]+1./2;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[2];
    res[15][1] = -v[0];
    res[15][2] = v[1];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = -v[1]+1./2;
    res[18][1] = -v[0]+1./2;
    res[18][2] = v[2]+1./2;
    res[19][0] = v[1]+1./2;
    res[19][1] = v[0]+1./2;
    res[19][2] = v[2]+1./2;
    res[20][0] = v[0]+1./2;
    res[20][1] = -v[2]+1./2;
    res[20][2] = -v[1]+1./2;
    res[21][0] = v[0]+1./2;
    res[21][1] = v[2]+1./2;
    res[21][2] = v[1]+1./2;
    res[22][0] = -v[2]+1./2;
    res[22][1] = v[1]+1./2;
    res[22][2] = -v[0]+1./2;
    res[23][0] = v[2]+1./2;
    res[23][1] = v[1]+1./2;
    res[23][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[2];
    res[6][2] = -v[1];
    res[7][0] = v[2];
    res[7][1] = -v[1];
    res[7][2] = -v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[2];
    res[9][1] = -v[1];
    res[9][2] = v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[2];
    res[20][2] = -v[1];
    res[21][0] = v[0];
    res[21][1] = v[2];
    res[21][2] = v[1];
    res[22][0] = -v[2];
    res[22][1] = v[1];
    res[22][2] = -v[0];
    res[23][0] = v[2];
    res[23][1] = v[1];
    res[23][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = v[1];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[2];
    res[6][2] = -v[1];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[2];
    res[7][1] = -v[1];
    res[7][2] = -v[0];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[2];
    res[9][1] = -v[1];
    res[9][2] = v[0];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] =  0;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = v[2];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[2];
    res[20][2] = -v[1];
    phase[20] = (v[0]+v[1]+v[2])*1./2;
    res[21][0] = v[0];
    res[21][1] = v[2];
    res[21][2] = v[1];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = -v[2];
    res[22][1] = v[1];
    res[22][2] = -v[0];
    phase[22] = (v[0]+v[1]+v[2])*1./2;
    res[23][0] = v[2];
    res[23][1] = v[1];
    res[23][2] = v[0];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_4b2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1]+1./2;
    res[4][1] = v[0]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[1]+1./2;
    res[5][1] = -v[0]+1./2;
    res[5][2] = -v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_4c2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_4m2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_4n2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1]+1./2;
    res[4][1] = v[0]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[1]+1./2;
    res[5][1] = -v[0]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = v[0];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_6 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_62c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_62m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_6c2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[0]-v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+v[1];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0];
    res[10][1] = v[0]-v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0]+v[1];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0]+v[1];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P_6m2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[0]+v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[0]-v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+v[1];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[0]+v[1];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0]+v[1];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0]+v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = -v[1];
    res[11][1] = -v[0];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
  }
  static const short size=1;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P112 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P112_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P112_b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P112_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P112_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1121 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1121_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1121_b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1121_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P1121_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P11a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P11b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P11m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P11n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = (v[0]+v[1])*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_b11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_c11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_m11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2_n11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_b11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_c11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_m11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21_n11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P211 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2111 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P212121 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2122 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21221 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P213 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1]+1./2;
    res[3][1] = -v[2];
    res[3][2] = v[0]+1./2;
    res[4][0] = v[2]+1./2;
    res[4][1] = -v[0]+1./2;
    res[4][2] = -v[1];
    res[5][0] = -v[1];
    res[5][1] = v[2]+1./2;
    res[5][2] = -v[0]+1./2;
    res[6][0] = -v[2]+1./2;
    res[6][1] = -v[0];
    res[6][2] = v[1]+1./2;
    res[7][0] = -v[2];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[1]+1./2;
    res[8][0] = v[1]+1./2;
    res[8][1] = -v[2]+1./2;
    res[8][2] = -v[0];
    res[9][0] = -v[0]+1./2;
    res[9][1] = -v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = -v[1];
    res[4][1] = -v[2];
    res[4][2] = v[0];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = v[1];
    res[6][0] = -v[1];
    res[6][1] = v[2];
    res[6][2] = -v[0];
    res[7][0] = v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    res[8][0] = -v[2];
    res[8][1] = v[0];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
    res[3][0] = v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[1];
    res[4][1] = -v[2];
    res[4][2] = v[0];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = v[1];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[2];
    res[6][2] = -v[0];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = -v[2];
    res[8][1] = v[0];
    res[8][2] = -v[1];
    phase[8] = (v[0]+v[1])*1./2;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] = (v[1]+v[2])*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21ab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21am {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21ca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21cn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21ma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21mn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21nb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = v[0]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P21nm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = -v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P22121 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2221 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[0];
    res[2][1] = -v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P23 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = v[0];
    res[4][0] = v[2];
    res[4][1] = -v[0];
    res[4][2] = -v[1];
    res[5][0] = -v[1];
    res[5][1] = v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[2];
    res[6][1] = -v[0];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = -v[1];
    res[8][0] = v[1];
    res[8][1] = -v[2];
    res[8][2] = -v[0];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = -v[1];
    res[4][1] = -v[2];
    res[4][2] = v[0];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = v[1];
    res[6][0] = -v[1];
    res[6][1] = v[2];
    res[6][2] = -v[0];
    res[7][0] = v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    res[8][0] = -v[2];
    res[8][1] = v[0];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
    res[3][0] = v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    phase[3] =  0;
    res[4][0] = -v[1];
    res[4][1] = -v[2];
    res[4][2] = v[0];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = v[1];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[2];
    res[6][2] = -v[0];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[2];
    res[7][2] = -v[0];
    phase[7] =  0;
    res[8][0] = -v[2];
    res[8][1] = v[0];
    res[8][2] = -v[1];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = -v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2aa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2an {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2cb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2mb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2na {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P2nn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
  }
  static const short size=3;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P31 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+1./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
  }
  static const short size=3;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3112 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+1./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+2./3;
    res[4][0] = -v[0]+v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2]+1./3;
    res[5][0] = v[0];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*2./3;
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P312 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3121 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+1./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+2./3;
    res[3][0] = v[0]-v[1];
    res[3][1] = -v[1];
    res[3][2] = -v[2]+2./3;
    res[4][0] = -v[0];
    res[4][1] = -v[0]+v[1];
    res[4][2] = -v[2]+1./3;
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*2./3;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P31c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0]-v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]-v[1];
    res[5][1] = v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0]-v[1];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P31m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0]-v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0]-v[1];
    res[5][1] = v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[0]-v[1];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P32 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+2./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+1./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*2./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
  }
  static const short size=3;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P321 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = v[0]-v[1];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[0]+v[1];
    res[4][2] = -v[2];
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+2./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./3;
    res[4][0] = -v[0]+v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2]+2./3;
    res[5][0] = v[0];
    res[5][1] = v[0]-v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*2./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./3;
    res[4][0] = -v[0];
    res[4][1] = v[0]+v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = v[0]+v[1];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3221 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2]+2./3;
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2]+1./3;
    res[3][0] = v[0]-v[1];
    res[3][1] = -v[1];
    res[3][2] = -v[2]+1./3;
    res[4][0] = -v[0];
    res[4][1] = -v[0]+v[1];
    res[4][2] = -v[2]+2./3;
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*2./3;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = v[0];
    res[3][1] = -v[0]-v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./3;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = v[1];
    res[5][1] = v[0];
    res[5][2] = -v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3c1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]+v[1];
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[0]+v[1];
    res[3][2] = v[2];
    res[4][0] = v[0]+v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[0]+v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0]+v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P3m1 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]+v[1];
    res[3][1] = v[1];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = v[0]+v[1];
    res[3][2] = v[2];
    res[4][0] = v[0]+v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0]-v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[0]+v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[0]+v[1];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = -v[0];
    res[5][2] = v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_mbm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2];
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_mcc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_mmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] =  0;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] =  0;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_mnc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_nbm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[0]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_ncc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_nmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2];
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] =  0;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4_nnc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P41 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*3./4;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P41212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2]+1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2]+3./4;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+3./4;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./4;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2+v[2]*1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2+v[2]*3./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2+v[2]*3./4;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2+v[2]*1./4;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4122 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+3./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2]+3./4;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*3./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] = v[2]*3./4;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./4;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4132 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./4;
    res[1][1] = v[0]+3./4;
    res[1][2] = v[2]+1./4;
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./4;
    res[3][1] = -v[0]+1./4;
    res[3][2] = v[2]+3./4;
    res[4][0] = v[0]+1./4;
    res[4][1] = -v[2]+1./4;
    res[4][2] = v[1]+3./4;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[0]+3./4;
    res[6][1] = v[2]+1./4;
    res[6][2] = -v[1]+1./4;
    res[7][0] = v[2]+3./4;
    res[7][1] = v[1]+1./4;
    res[7][2] = -v[0]+1./4;
    res[8][0] = -v[0];
    res[8][1] = v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[2]+1./4;
    res[9][1] = v[1]+3./4;
    res[9][2] = v[0]+1./4;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1]+1./2;
    res[12][1] = -v[2];
    res[12][2] = v[0]+1./2;
    res[13][0] = v[2]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2]+1./2;
    res[14][2] = -v[0]+1./2;
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[0];
    res[15][2] = v[1]+1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0]+1./2;
    res[16][2] = -v[1]+1./2;
    res[17][0] = v[1]+1./2;
    res[17][1] = -v[2]+1./2;
    res[17][2] = -v[0];
    res[18][0] = v[1]+3./4;
    res[18][1] = v[0]+1./4;
    res[18][2] = -v[2]+1./4;
    res[19][0] = -v[1]+3./4;
    res[19][1] = -v[0]+3./4;
    res[19][2] = -v[2]+3./4;
    res[20][0] = -v[0]+1./4;
    res[20][1] = v[2]+3./4;
    res[20][2] = v[1]+1./4;
    res[21][0] = -v[0]+3./4;
    res[21][1] = -v[2]+3./4;
    res[21][2] = -v[1]+3./4;
    res[22][0] = v[2]+1./4;
    res[22][1] = -v[1]+1./4;
    res[22][2] = v[0]+3./4;
    res[23][0] = -v[2]+3./4;
    res[23][1] = -v[1]+3./4;
    res[23][2] = -v[0]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    phase[4] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    phase[6] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    phase[7] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    phase[9] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[2])*1./2;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] = (v[1]+v[2])*1./2;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] = (v[0]+v[1])*1./2;
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    phase[18] = v[0]*3./4+(v[1]+v[2])*1./4;
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    phase[19] = (v[0]+v[1]+v[2])*3./4;
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    phase[20] = (v[0]+v[2])*1./4+v[1]*3./4;
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    phase[21] = (v[0]+v[1]+v[2])*3./4;
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    phase[22] = (v[0]+v[1])*1./4+v[2]*3./4;
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
    phase[23] = (v[0]+v[1]+v[2])*3./4;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_mbc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_mcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] =  0;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_mmc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] =  0;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_mnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] =  0;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_nbc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2];
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[1]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[0]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_ncm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2];
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[0]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] =  0;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_nmc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1]+1./2;
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1]+1./2;
    res[11][2] = v[2];
    res[12][0] = v[1]+1./2;
    res[12][1] = v[0]+1./2;
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[1]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = v[0]*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = v[0]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = v[1]*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = v[1]*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] = (v[0]+v[1]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42_nnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1]+1./2;
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+1./2;
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0]+1./2;
    res[11][1] = -v[1];
    res[11][2] = v[2]+1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1]+1./2;
    res[14][1] = -v[0]+1./2;
    res[14][2] = -v[2];
    res[15][0] = v[1]+1./2;
    res[15][1] = v[0]+1./2;
    res[15][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = -v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = v[1];
    res[9][2] = v[2];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[0];
    res[11][1] = -v[1];
    res[11][2] = v[2];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = v[1];
    res[12][1] = v[0];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[0];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[1];
    res[14][1] = -v[0];
    res[14][2] = -v[2];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = v[2];
    phase[15] = (v[0]+v[1])*1./2;
  }
  static const short size=16;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P422 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+1./2;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2]+1./2;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4232 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[2]+1./2;
    res[4][2] = v[1]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0]+1./2;
    res[6][1] = v[2]+1./2;
    res[6][2] = -v[1]+1./2;
    res[7][0] = v[2]+1./2;
    res[7][1] = v[1]+1./2;
    res[7][2] = -v[0]+1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[2]+1./2;
    res[9][1] = v[1]+1./2;
    res[9][2] = v[0]+1./2;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[2];
    res[15][1] = -v[0];
    res[15][2] = v[1];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = v[1]+1./2;
    res[18][1] = v[0]+1./2;
    res[18][2] = -v[2]+1./2;
    res[19][0] = -v[1]+1./2;
    res[19][1] = -v[0]+1./2;
    res[19][2] = -v[2]+1./2;
    res[20][0] = -v[0]+1./2;
    res[20][1] = v[2]+1./2;
    res[20][2] = v[1]+1./2;
    res[21][0] = -v[0]+1./2;
    res[21][1] = -v[2]+1./2;
    res[21][2] = -v[1]+1./2;
    res[22][0] = v[2]+1./2;
    res[22][1] = -v[1]+1./2;
    res[22][2] = v[0]+1./2;
    res[23][0] = -v[2]+1./2;
    res[23][1] = -v[1]+1./2;
    res[23][2] = -v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] =  0;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    phase[20] = (v[0]+v[1]+v[2])*1./2;
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    phase[21] = (v[0]+v[1]+v[2])*1./2;
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    phase[22] = (v[0]+v[1]+v[2])*1./2;
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
    phase[23] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42bc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42mc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P42nm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P43 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./4;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P432 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[2];
    res[4][2] = v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = v[2];
    res[6][2] = -v[1];
    res[7][0] = v[2];
    res[7][1] = v[1];
    res[7][2] = -v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = -v[2];
    res[9][1] = v[1];
    res[9][2] = v[0];
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1];
    res[12][1] = -v[2];
    res[12][2] = v[0];
    res[13][0] = v[2];
    res[13][1] = -v[0];
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[2];
    res[15][1] = -v[0];
    res[15][2] = v[1];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[1];
    res[17][1] = -v[2];
    res[17][2] = -v[0];
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    phase[6] =  0;
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    phase[7] =  0;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    phase[9] =  0;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] =  0;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] =  0;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] =  0;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] =  0;
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    phase[18] =  0;
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    phase[19] =  0;
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    phase[20] =  0;
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    phase[21] =  0;
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    phase[22] =  0;
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
    phase[23] =  0;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P43212 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+1./2;
    res[1][1] = v[0]+1./2;
    res[1][2] = v[2]+3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = v[2]+1./4;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./4;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2]+3./4;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[1])*1./2+v[2]*3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2+v[2]*1./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2+v[2]*1./4;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2+v[2]*3./4;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4322 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2]+1./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2]+1./4;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2]+3./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*3./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = v[2]*1./4;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = v[1];
    res[6][1] = v[0];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./4;
    res[7][0] = -v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[2]*3./4;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4332 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1]+3./4;
    res[1][1] = v[0]+1./4;
    res[1][2] = v[2]+3./4;
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+3./4;
    res[3][1] = -v[0]+3./4;
    res[3][2] = v[2]+1./4;
    res[4][0] = v[0]+3./4;
    res[4][1] = -v[2]+3./4;
    res[4][2] = v[1]+1./4;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[0]+1./4;
    res[6][1] = v[2]+3./4;
    res[6][2] = -v[1]+3./4;
    res[7][0] = v[2]+1./4;
    res[7][1] = v[1]+3./4;
    res[7][2] = -v[0]+3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1]+1./2;
    res[8][2] = -v[2]+1./2;
    res[9][0] = -v[2]+3./4;
    res[9][1] = v[1]+1./4;
    res[9][2] = v[0]+3./4;
    res[10][0] = v[2];
    res[10][1] = v[0];
    res[10][2] = v[1];
    res[11][0] = v[1];
    res[11][1] = v[2];
    res[11][2] = v[0];
    res[12][0] = -v[1]+1./2;
    res[12][1] = -v[2];
    res[12][2] = v[0]+1./2;
    res[13][0] = v[2]+1./2;
    res[13][1] = -v[0]+1./2;
    res[13][2] = -v[1];
    res[14][0] = -v[1];
    res[14][1] = v[2]+1./2;
    res[14][2] = -v[0]+1./2;
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[0];
    res[15][2] = v[1]+1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0]+1./2;
    res[16][2] = -v[1]+1./2;
    res[17][0] = v[1]+1./2;
    res[17][1] = -v[2]+1./2;
    res[17][2] = -v[0];
    res[18][0] = v[1]+1./4;
    res[18][1] = v[0]+3./4;
    res[18][2] = -v[2]+3./4;
    res[19][0] = -v[1]+1./4;
    res[19][1] = -v[0]+1./4;
    res[19][2] = -v[2]+1./4;
    res[20][0] = -v[0]+3./4;
    res[20][1] = v[2]+1./4;
    res[20][2] = v[1]+3./4;
    res[21][0] = -v[0]+1./4;
    res[21][1] = -v[2]+1./4;
    res[21][2] = -v[1]+1./4;
    res[22][0] = v[2]+3./4;
    res[22][1] = -v[1]+3./4;
    res[22][2] = v[0]+1./4;
    res[23][0] = -v[2]+1./4;
    res[23][1] = -v[1]+1./4;
    res[23][2] = -v[0]+1./4;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = -v[1];
    phase[4] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[2];
    res[6][2] = v[1];
    phase[6] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[7][0] = -v[2];
    res[7][1] = v[1];
    res[7][2] = v[0];
    phase[7] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[8][0] = -v[0];
    res[8][1] = v[1];
    res[8][2] = -v[2];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = v[2];
    res[9][1] = v[1];
    res[9][2] = -v[0];
    phase[9] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[10][0] = v[1];
    res[10][1] = v[2];
    res[10][2] = v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = v[1];
    phase[11] =  0;
    res[12][0] = v[2];
    res[12][1] = -v[0];
    res[12][2] = -v[1];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = -v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[2];
    res[14][1] = -v[0];
    res[14][2] = v[1];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[2])*1./2;
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    phase[16] = (v[1]+v[2])*1./2;
    res[17][0] = -v[2];
    res[17][1] = v[0];
    res[17][2] = -v[1];
    phase[17] = (v[0]+v[1])*1./2;
    res[18][0] = v[1];
    res[18][1] = v[0];
    res[18][2] = -v[2];
    phase[18] = v[0]*1./4+(v[1]+v[2])*3./4;
    res[19][0] = -v[1];
    res[19][1] = -v[0];
    res[19][2] = -v[2];
    phase[19] = (v[0]+v[1]+v[2])*1./4;
    res[20][0] = -v[0];
    res[20][1] = v[2];
    res[20][2] = v[1];
    phase[20] = (v[0]+v[2])*3./4+v[1]*1./4;
    res[21][0] = -v[0];
    res[21][1] = -v[2];
    res[21][2] = -v[1];
    phase[21] = (v[0]+v[1]+v[2])*1./4;
    res[22][0] = v[2];
    res[22][1] = -v[1];
    res[22][2] = v[0];
    phase[22] = (v[0]+v[1])*3./4+v[2]*1./4;
    res[23][0] = -v[2];
    res[23][1] = -v[1];
    res[23][2] = -v[0];
    phase[23] = (v[0]+v[1]+v[2])*1./4;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4bm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4cc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P4nc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = v[1]+1./2;
    res[4][2] = v[2]+1./2;
    res[5][0] = v[0]+1./2;
    res[5][1] = -v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = v[0];
    res[5][1] = -v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6_mcc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0]-v[1];
    res[12][1] = -v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[0]+v[1];
    res[13][1] = v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0];
    res[14][1] = -v[0]+v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = v[0]-v[1];
    res[15][2] = v[2]+1./2;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2]+1./2;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2]+1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2]+1./2;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2]+1./2;
    res[20][0] = -v[0]+v[1];
    res[20][1] = v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = v[0]-v[1];
    res[21][1] = -v[1];
    res[21][2] = v[2]+1./2;
    res[22][0] = v[0];
    res[22][1] = v[0]-v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = -v[0];
    res[23][1] = -v[0]+v[1];
    res[23][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] =  0;
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] = v[2]*1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    phase[18] = v[2]*1./2;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] = v[2]*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    phase[20] = v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    phase[21] = v[2]*1./2;
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = v[2]*1./2;
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = v[2]*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6_mmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0]-v[1];
    res[12][1] = -v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0]+v[1];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = -v[0]+v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = v[0]-v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0]+v[1];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0]-v[1];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = v[0]-v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = -v[0]+v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] =  0;
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    phase[18] =  0;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] =  0;
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    phase[21] =  0;
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] =  0;
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] =  0;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P61 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./6;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+2./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+5./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./6;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*5./6;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6122 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./6;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+2./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+5./6;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2]+2./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2]+1./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+5./6;
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./6;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*5./6;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*2./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*5./6;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./6;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P62 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./3;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./3;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*2./3;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P622 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6222 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./3;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+2./3;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2]+1./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2]+2./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+2./3;
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./3;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*2./3;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] = v[2]*2./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*2./3;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./3;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63_m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63_mcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[0]-v[1];
    res[12][1] = -v[1];
    res[12][2] = -v[2]+1./2;
    res[13][0] = -v[0]+v[1];
    res[13][1] = v[1];
    res[13][2] = v[2]+1./2;
    res[14][0] = -v[0];
    res[14][1] = -v[0]+v[1];
    res[14][2] = -v[2]+1./2;
    res[15][0] = v[0];
    res[15][1] = v[0]-v[1];
    res[15][2] = v[2]+1./2;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2]+1./2;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2]+1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0]+v[1];
    res[20][1] = v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0]-v[1];
    res[21][1] = -v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = v[0]-v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = -v[0]+v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[2]*1./2;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    phase[16] = v[2]*1./2;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] = v[2]*1./2;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    phase[18] =  0;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] =  0;
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    phase[21] =  0;
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] =  0;
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] =  0;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63_mmc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]-v[1];
    res[2][1] = v[0];
    res[2][2] = v[2]+1./2;
    res[3][0] = -v[0]+v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[1];
    res[4][1] = v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2]+1./2;
    res[8][0] = -v[0]+v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]-v[1];
    res[9][1] = v[0];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]+v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[1];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./2;
    res[12][0] = v[0]-v[1];
    res[12][1] = -v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0]+v[1];
    res[13][1] = v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0];
    res[14][1] = -v[0]+v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0];
    res[15][1] = v[0]-v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2]+1./2;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2]+1./2;
    res[20][0] = -v[0]+v[1];
    res[20][1] = v[1];
    res[20][2] = -v[2]+1./2;
    res[21][0] = v[0]-v[1];
    res[21][1] = -v[1];
    res[21][2] = v[2]+1./2;
    res[22][0] = v[0];
    res[22][1] = v[0]-v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = -v[0];
    res[23][1] = -v[0]+v[1];
    res[23][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0]+v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0]-v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = -v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[0]+v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = -v[1];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[1];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[0]-v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[0]+v[1];
    res[13][2] = v[2];
    phase[13] =  0;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] =  0;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[1];
    res[15][2] = v[2];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = -v[1];
    res[18][1] = -v[0];
    res[18][2] = -v[2];
    phase[18] = v[2]*1./2;
    res[19][0] = v[1];
    res[19][1] = v[0];
    res[19][2] = v[2];
    phase[19] = v[2]*1./2;
    res[20][0] = -v[0];
    res[20][1] = v[0]+v[1];
    res[20][2] = -v[2];
    phase[20] = v[2]*1./2;
    res[21][0] = v[0];
    res[21][1] = -v[0]-v[1];
    res[21][2] = v[2];
    phase[21] = v[2]*1./2;
    res[22][0] = v[0]+v[1];
    res[22][1] = -v[1];
    res[22][2] = -v[2];
    phase[22] = v[2]*1./2;
    res[23][0] = -v[0]-v[1];
    res[23][1] = v[1];
    res[23][2] = v[2];
    phase[23] = v[2]*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6322 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+1./2;
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] =  0;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63cm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+v[1];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[0]-v[1];
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2]+1./2;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P63mc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+v[1];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[0]-v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P64 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+2./3;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+2./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*2./3;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./3;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6422 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+2./3;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+2./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./3;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2]+2./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2]+1./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+1./3;
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*2./3;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*2./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./3;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*2./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] = v[2]*1./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*1./3;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*2./3;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P65 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+5./6;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*5./6;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./6;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6522 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2]+5./6;
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2]+1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2]+1./6;
    res[6][0] = v[0]-v[1];
    res[6][1] = -v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2]+1./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2]+2./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2]+1./6;
    res[10][0] = -v[0]+v[1];
    res[10][1] = v[1];
    res[10][2] = -v[2]+1./2;
    res[11][0] = v[0];
    res[11][1] = v[0]-v[1];
    res[11][2] = -v[2]+5./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] = v[2]*5./6;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*2./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] = v[2]*1./3;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./6;
    res[6][0] = v[0];
    res[6][1] = -v[0]-v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[1];
    res[7][2] = -v[2];
    phase[7] = v[2]*1./3;
    res[8][0] = v[1];
    res[8][1] = v[0];
    res[8][2] = -v[2];
    phase[8] = v[2]*2./3;
    res[9][0] = -v[1];
    res[9][1] = -v[0];
    res[9][2] = -v[2];
    phase[9] = v[2]*1./6;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = -v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = v[0]+v[1];
    res[11][1] = -v[1];
    res[11][2] = -v[2];
    phase[11] = v[2]*5./6;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6cc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+v[1];
    res[6][1] = v[1];
    res[6][2] = v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = v[0]-v[1];
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2]+1./2;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2]+1./2;
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] = v[2]*1./2;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[2]*1./2;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = v[2]*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_P6mm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]-v[1];
    res[1][1] = v[0];
    res[1][2] = v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]+v[1];
    res[4][1] = -v[0];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+v[1];
    res[6][1] = v[1];
    res[6][2] = v[2];
    res[7][0] = v[0];
    res[7][1] = v[0]-v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0]-v[1];
    res[10][1] = -v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = -v[0]+v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0]+v[1];
    res[1][1] = -v[0];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0]-v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = -v[0]-v[1];
    res[4][1] = v[0];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = -v[1];
    res[5][1] = v[0]+v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[0]+v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[0]+v[1];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
    res[8][0] = -v[1];
    res[8][1] = -v[0];
    res[8][2] = v[2];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[0];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] =  0;
    res[11][0] = -v[0]-v[1];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pa_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[2];
    res[6][2] = v[0]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = v[2];
    res[7][2] = -v[0]+1./2;
    res[8][0] = v[2]+1./2;
    res[8][1] = -v[0]+1./2;
    res[8][2] = -v[1];
    res[9][0] = -v[2]+1./2;
    res[9][1] = v[0]+1./2;
    res[9][2] = v[1];
    res[10][0] = -v[1];
    res[10][1] = v[2]+1./2;
    res[10][2] = -v[0]+1./2;
    res[11][0] = v[1];
    res[11][1] = -v[2]+1./2;
    res[11][2] = v[0]+1./2;
    res[12][0] = -v[2]+1./2;
    res[12][1] = -v[0];
    res[12][2] = v[1]+1./2;
    res[13][0] = v[2]+1./2;
    res[13][1] = v[0];
    res[13][2] = -v[1]+1./2;
    res[14][0] = -v[2];
    res[14][1] = v[0]+1./2;
    res[14][2] = -v[1]+1./2;
    res[15][0] = v[2];
    res[15][1] = -v[0]+1./2;
    res[15][2] = v[1]+1./2;
    res[16][0] = v[1]+1./2;
    res[16][1] = -v[2]+1./2;
    res[16][2] = -v[0];
    res[17][0] = -v[1]+1./2;
    res[17][1] = v[2]+1./2;
    res[17][2] = v[0];
    res[18][0] = -v[0]+1./2;
    res[18][1] = -v[1];
    res[18][2] = v[2]+1./2;
    res[19][0] = v[0]+1./2;
    res[19][1] = v[1];
    res[19][2] = -v[2]+1./2;
    res[20][0] = v[0]+1./2;
    res[20][1] = -v[1]+1./2;
    res[20][2] = -v[2];
    res[21][0] = -v[0]+1./2;
    res[21][1] = v[1]+1./2;
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1]+1./2;
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1]+1./2;
    res[23][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    phase[8] = (v[0]+v[1])*1./2;
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    phase[9] = (v[0]+v[1])*1./2;
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    phase[12] = (v[0]+v[2])*1./2;
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] = (v[0]+v[2])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    phase[14] = (v[1]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    phase[15] = (v[1]+v[2])*1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    phase[16] = (v[0]+v[1])*1./2;
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    phase[17] = (v[0]+v[1])*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = (v[0]+v[2])*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = (v[0]+v[2])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = (v[0]+v[1])*1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] = (v[0]+v[1])*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[1]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[1]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pb11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[1]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pb21a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pb21m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pb2b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pb2n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pba2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pban {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbc21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbcb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbcn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[1]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbmn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbn21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbna {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbnb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pbnn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[1]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[1]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc21b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc21n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pc2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pca21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcan {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcc2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pccb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pccm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pccn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcm21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcmn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcn2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcna {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcnb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pcnn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[2]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[2]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[1];
    res[6][1] = -v[2];
    res[6][2] = v[0];
    res[7][0] = v[1];
    res[7][1] = v[2];
    res[7][2] = -v[0];
    res[8][0] = v[2];
    res[8][1] = -v[0];
    res[8][2] = -v[1];
    res[9][0] = -v[2];
    res[9][1] = v[0];
    res[9][2] = v[1];
    res[10][0] = -v[1];
    res[10][1] = v[2];
    res[10][2] = -v[0];
    res[11][0] = v[1];
    res[11][1] = -v[2];
    res[11][2] = v[0];
    res[12][0] = -v[2];
    res[12][1] = -v[0];
    res[12][2] = v[1];
    res[13][0] = v[2];
    res[13][1] = v[0];
    res[13][2] = -v[1];
    res[14][0] = -v[2];
    res[14][1] = v[0];
    res[14][2] = -v[1];
    res[15][0] = v[2];
    res[15][1] = -v[0];
    res[15][2] = v[1];
    res[16][0] = v[1];
    res[16][1] = -v[2];
    res[16][2] = -v[0];
    res[17][0] = -v[1];
    res[17][1] = v[2];
    res[17][2] = v[0];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    phase[6] =  0;
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    phase[7] =  0;
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    phase[8] =  0;
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    phase[9] =  0;
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    phase[11] =  0;
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    phase[12] =  0;
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] =  0;
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    phase[14] =  0;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    phase[15] =  0;
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    phase[16] =  0;
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    phase[17] =  0;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] =  0;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] =  0;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] =  0;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] =  0;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] =  0;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] =  0;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[2];
    res[8][2] = v[1];
    res[9][0] = -v[0];
    res[9][1] = v[2];
    res[9][2] = -v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1];
    res[13][0] = -v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1];
    res[14][0] = v[2];
    res[14][1] = v[1];
    res[14][2] = -v[0];
    res[15][0] = -v[2];
    res[15][1] = -v[1];
    res[15][2] = v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = -v[2];
    res[18][1] = v[1];
    res[18][2] = v[0];
    res[19][0] = v[2];
    res[19][1] = -v[1];
    res[19][2] = -v[0];
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = -v[1];
    res[23][1] = -v[2];
    res[23][2] = -v[0];
    res[24][0] = -v[1];
    res[24][1] = -v[2];
    res[24][2] = v[0];
    res[25][0] = v[1];
    res[25][1] = v[2];
    res[25][2] = -v[0];
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    res[28][0] = -v[1];
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = v[1];
    res[29][1] = -v[2];
    res[29][2] = v[0];
    res[30][0] = -v[2];
    res[30][1] = -v[0];
    res[30][2] = v[1];
    res[31][0] = v[2];
    res[31][1] = v[0];
    res[31][2] = -v[1];
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0];
    res[35][0] = -v[1];
    res[35][1] = v[2];
    res[35][2] = v[0];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] =  0;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] =  0;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] =  0;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] =  0;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] =  0;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] =  0;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] =  0;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    phase[21] =  0;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] =  0;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] =  0;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] =  0;
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    phase[27] =  0;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] =  0;
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    phase[29] =  0;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] =  0;
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    phase[31] =  0;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] =  0;
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    phase[33] =  0;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] =  0;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] =  0;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] =  0;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] =  0;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] =  0;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] =  0;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] =  0;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] =  0;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] =  0;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] =  0;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] =  0;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] =  0;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] =  0;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] =  0;
  }
  static const short size=48;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm_3n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[2]+1./2;
    res[8][2] = v[1]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[2]+1./2;
    res[9][2] = -v[1]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0]+1./2;
    res[12][1] = v[2]+1./2;
    res[12][2] = -v[1]+1./2;
    res[13][0] = -v[0]+1./2;
    res[13][1] = -v[2]+1./2;
    res[13][2] = v[1]+1./2;
    res[14][0] = v[2]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[0]+1./2;
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[0]+1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = -v[2]+1./2;
    res[18][1] = v[1]+1./2;
    res[18][2] = v[0]+1./2;
    res[19][0] = v[2]+1./2;
    res[19][1] = -v[1]+1./2;
    res[19][2] = -v[0]+1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = -v[1];
    res[23][1] = -v[2];
    res[23][2] = -v[0];
    res[24][0] = -v[1];
    res[24][1] = -v[2];
    res[24][2] = v[0];
    res[25][0] = v[1];
    res[25][1] = v[2];
    res[25][2] = -v[0];
    res[26][0] = v[2];
    res[26][1] = -v[0];
    res[26][2] = -v[1];
    res[27][0] = -v[2];
    res[27][1] = v[0];
    res[27][2] = v[1];
    res[28][0] = -v[1];
    res[28][1] = v[2];
    res[28][2] = -v[0];
    res[29][0] = v[1];
    res[29][1] = -v[2];
    res[29][2] = v[0];
    res[30][0] = -v[2];
    res[30][1] = -v[0];
    res[30][2] = v[1];
    res[31][0] = v[2];
    res[31][1] = v[0];
    res[31][2] = -v[1];
    res[32][0] = -v[2];
    res[32][1] = v[0];
    res[32][2] = -v[1];
    res[33][0] = v[2];
    res[33][1] = -v[0];
    res[33][2] = v[1];
    res[34][0] = v[1];
    res[34][1] = -v[2];
    res[34][2] = -v[0];
    res[35][0] = -v[1];
    res[35][1] = v[2];
    res[35][2] = v[0];
    res[36][0] = v[1]+1./2;
    res[36][1] = v[0]+1./2;
    res[36][2] = -v[2]+1./2;
    res[37][0] = -v[1]+1./2;
    res[37][1] = -v[0]+1./2;
    res[37][2] = v[2]+1./2;
    res[38][0] = -v[1]+1./2;
    res[38][1] = -v[0]+1./2;
    res[38][2] = -v[2]+1./2;
    res[39][0] = v[1]+1./2;
    res[39][1] = v[0]+1./2;
    res[39][2] = v[2]+1./2;
    res[40][0] = -v[0]+1./2;
    res[40][1] = v[2]+1./2;
    res[40][2] = v[1]+1./2;
    res[41][0] = v[0]+1./2;
    res[41][1] = -v[2]+1./2;
    res[41][2] = -v[1]+1./2;
    res[42][0] = -v[0]+1./2;
    res[42][1] = -v[2]+1./2;
    res[42][2] = -v[1]+1./2;
    res[43][0] = v[0]+1./2;
    res[43][1] = v[2]+1./2;
    res[43][2] = v[1]+1./2;
    res[44][0] = v[2]+1./2;
    res[44][1] = -v[1]+1./2;
    res[44][2] = v[0]+1./2;
    res[45][0] = -v[2]+1./2;
    res[45][1] = v[1]+1./2;
    res[45][2] = -v[0]+1./2;
    res[46][0] = -v[2]+1./2;
    res[46][1] = -v[1]+1./2;
    res[46][2] = -v[0]+1./2;
    res[47][0] = v[2]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] =  0;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] = (v[0]+v[1]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] =  0;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] =  0;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] = (v[0]+v[1]+v[2])*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] = (v[0]+v[1]+v[2])*1./2;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] = (v[0]+v[1]+v[2])*1./2;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1]+v[2])*1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] =  0;
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    phase[17] =  0;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] = (v[0]+v[1]+v[2])*1./2;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] = (v[0]+v[1]+v[2])*1./2;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    phase[21] =  0;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] =  0;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] =  0;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] =  0;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] =  0;
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    phase[27] =  0;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] =  0;
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    phase[29] =  0;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] =  0;
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    phase[31] =  0;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] =  0;
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    phase[33] =  0;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] =  0;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] =  0;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] = (v[0]+v[1]+v[2])*1./2;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] = (v[0]+v[1]+v[2])*1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] = (v[0]+v[1]+v[2])*1./2;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] = (v[0]+v[1]+v[2])*1./2;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] = (v[0]+v[1]+v[2])*1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] = (v[0]+v[1]+v[2])*1./2;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] = (v[0]+v[1]+v[2])*1./2;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] = (v[0]+v[1]+v[2])*1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] = (v[0]+v[1]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] =  0;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm21b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm21n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+1./2;
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = (v[0]+v[1])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm2a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pm2m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pma2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[0]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pman {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmc21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = v[2]*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmcb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmcm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmcn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmm2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmmn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmn21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1];
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmna {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmnb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = v[0]*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pmnn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] =  0;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] =  0;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+1./2;
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[0]+v[2])*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[2]+1./2;
    res[6][2] = v[0];
    res[7][0] = v[1]+1./2;
    res[7][1] = v[2]+1./2;
    res[7][2] = -v[0];
    res[8][0] = v[2];
    res[8][1] = -v[0]+1./2;
    res[8][2] = -v[1]+1./2;
    res[9][0] = -v[2];
    res[9][1] = v[0]+1./2;
    res[9][2] = v[1]+1./2;
    res[10][0] = -v[1]+1./2;
    res[10][1] = v[2];
    res[10][2] = -v[0]+1./2;
    res[11][0] = v[1]+1./2;
    res[11][1] = -v[2];
    res[11][2] = v[0]+1./2;
    res[12][0] = -v[2]+1./2;
    res[12][1] = -v[0]+1./2;
    res[12][2] = v[1];
    res[13][0] = v[2]+1./2;
    res[13][1] = v[0]+1./2;
    res[13][2] = -v[1];
    res[14][0] = -v[2]+1./2;
    res[14][1] = v[0];
    res[14][2] = -v[1]+1./2;
    res[15][0] = v[2]+1./2;
    res[15][1] = -v[0];
    res[15][2] = v[1]+1./2;
    res[16][0] = v[1];
    res[16][1] = -v[2]+1./2;
    res[16][2] = -v[0]+1./2;
    res[17][0] = -v[1];
    res[17][1] = v[2]+1./2;
    res[17][2] = v[0]+1./2;
    res[18][0] = -v[0]+1./2;
    res[18][1] = -v[1]+1./2;
    res[18][2] = v[2];
    res[19][0] = v[0]+1./2;
    res[19][1] = v[1]+1./2;
    res[19][2] = -v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1]+1./2;
    res[20][2] = -v[2]+1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1]+1./2;
    res[21][2] = v[2]+1./2;
    res[22][0] = -v[0]+1./2;
    res[22][1] = v[1];
    res[22][2] = -v[2]+1./2;
    res[23][0] = v[0]+1./2;
    res[23][1] = -v[1];
    res[23][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
    res[6][0] = v[2];
    res[6][1] = -v[0];
    res[6][2] = -v[1];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = -v[2];
    res[7][1] = v[0];
    res[7][2] = v[1];
    phase[7] = (v[0]+v[1])*1./2;
    res[8][0] = -v[1];
    res[8][1] = -v[2];
    res[8][2] = v[0];
    phase[8] = (v[1]+v[2])*1./2;
    res[9][0] = v[1];
    res[9][1] = v[2];
    res[9][2] = -v[0];
    phase[9] = (v[1]+v[2])*1./2;
    res[10][0] = -v[2];
    res[10][1] = -v[0];
    res[10][2] = v[1];
    phase[10] = (v[0]+v[2])*1./2;
    res[11][0] = v[2];
    res[11][1] = v[0];
    res[11][2] = -v[1];
    phase[11] = (v[0]+v[2])*1./2;
    res[12][0] = -v[1];
    res[12][1] = v[2];
    res[12][2] = -v[0];
    phase[12] = (v[0]+v[1])*1./2;
    res[13][0] = v[1];
    res[13][1] = -v[2];
    res[13][2] = v[0];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = v[1];
    res[14][1] = -v[2];
    res[14][2] = -v[0];
    phase[14] = (v[0]+v[2])*1./2;
    res[15][0] = -v[1];
    res[15][1] = v[2];
    res[15][2] = v[0];
    phase[15] = (v[0]+v[2])*1./2;
    res[16][0] = -v[2];
    res[16][1] = v[0];
    res[16][2] = -v[1];
    phase[16] = (v[1]+v[2])*1./2;
    res[17][0] = v[2];
    res[17][1] = -v[0];
    res[17][2] = v[1];
    phase[17] = (v[1]+v[2])*1./2;
    res[18][0] = -v[0];
    res[18][1] = -v[1];
    res[18][2] = v[2];
    phase[18] = (v[0]+v[1])*1./2;
    res[19][0] = v[0];
    res[19][1] = v[1];
    res[19][2] = -v[2];
    phase[19] = (v[0]+v[1])*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[1];
    res[20][2] = -v[2];
    phase[20] = (v[1]+v[2])*1./2;
    res[21][0] = -v[0];
    res[21][1] = v[1];
    res[21][2] = v[2];
    phase[21] = (v[1]+v[2])*1./2;
    res[22][0] = -v[0];
    res[22][1] = v[1];
    res[22][2] = -v[2];
    phase[22] = (v[0]+v[2])*1./2;
    res[23][0] = v[0];
    res[23][1] = -v[1];
    res[23][2] = v[2];
    phase[23] = (v[0]+v[2])*1./2;
  }
  static const short size=24;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1];
    res[2][1] = v[0]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[1];
    res[3][1] = -v[0]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1]+1./2;
    res[6][1] = -v[0];
    res[6][2] = v[2]+1./2;
    res[7][0] = -v[1]+1./2;
    res[7][1] = v[0];
    res[7][2] = -v[2]+1./2;
    res[8][0] = v[0]+1./2;
    res[8][1] = -v[2];
    res[8][2] = v[1]+1./2;
    res[9][0] = -v[0]+1./2;
    res[9][1] = v[2];
    res[9][2] = -v[1]+1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[0]+1./2;
    res[12][1] = v[2]+1./2;
    res[12][2] = -v[1];
    res[13][0] = -v[0]+1./2;
    res[13][1] = -v[2]+1./2;
    res[13][2] = v[1];
    res[14][0] = v[2]+1./2;
    res[14][1] = v[1]+1./2;
    res[14][2] = -v[0];
    res[15][0] = -v[2]+1./2;
    res[15][1] = -v[1]+1./2;
    res[15][2] = v[0];
    res[16][0] = -v[0]+1./2;
    res[16][1] = v[1];
    res[16][2] = -v[2]+1./2;
    res[17][0] = v[0]+1./2;
    res[17][1] = -v[1];
    res[17][2] = v[2]+1./2;
    res[18][0] = -v[2];
    res[18][1] = v[1]+1./2;
    res[18][2] = v[0]+1./2;
    res[19][0] = v[2];
    res[19][1] = -v[1]+1./2;
    res[19][2] = -v[0]+1./2;
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = -v[1];
    res[23][1] = -v[2];
    res[23][2] = -v[0];
    res[24][0] = -v[1]+1./2;
    res[24][1] = -v[2]+1./2;
    res[24][2] = v[0];
    res[25][0] = v[1]+1./2;
    res[25][1] = v[2]+1./2;
    res[25][2] = -v[0];
    res[26][0] = v[2];
    res[26][1] = -v[0]+1./2;
    res[26][2] = -v[1]+1./2;
    res[27][0] = -v[2];
    res[27][1] = v[0]+1./2;
    res[27][2] = v[1]+1./2;
    res[28][0] = -v[1]+1./2;
    res[28][1] = v[2];
    res[28][2] = -v[0]+1./2;
    res[29][0] = v[1]+1./2;
    res[29][1] = -v[2];
    res[29][2] = v[0]+1./2;
    res[30][0] = -v[2]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[1];
    res[31][0] = v[2]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[1];
    res[32][0] = -v[2]+1./2;
    res[32][1] = v[0];
    res[32][2] = -v[1]+1./2;
    res[33][0] = v[2]+1./2;
    res[33][1] = -v[0];
    res[33][2] = v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2]+1./2;
    res[34][2] = -v[0]+1./2;
    res[35][0] = -v[1];
    res[35][1] = v[2]+1./2;
    res[35][2] = v[0]+1./2;
    res[36][0] = v[1]+1./2;
    res[36][1] = v[0]+1./2;
    res[36][2] = -v[2];
    res[37][0] = -v[1]+1./2;
    res[37][1] = -v[0]+1./2;
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2]+1./2;
    res[40][2] = v[1]+1./2;
    res[41][0] = v[0];
    res[41][1] = -v[2]+1./2;
    res[41][2] = -v[1]+1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2]+1./2;
    res[44][1] = -v[1];
    res[44][2] = v[0]+1./2;
    res[45][0] = -v[2]+1./2;
    res[45][1] = v[1];
    res[45][2] = -v[0]+1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = (v[0]+v[2])*1./2;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] = (v[0]+v[2])*1./2;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] = (v[0]+v[2])*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] = (v[0]+v[1])*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] = (v[0]+v[1])*1./2;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] = (v[0]+v[1])*1./2;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] = (v[0]+v[1])*1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] = (v[0]+v[2])*1./2;
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    phase[17] = (v[0]+v[2])*1./2;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] = (v[1]+v[2])*1./2;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] = (v[1]+v[2])*1./2;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    phase[21] =  0;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] =  0;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] = (v[0]+v[1])*1./2;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] = (v[0]+v[1])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] = (v[1]+v[2])*1./2;
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    phase[27] = (v[1]+v[2])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] = (v[0]+v[2])*1./2;
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    phase[29] = (v[0]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] = (v[0]+v[2])*1./2;
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    phase[33] = (v[0]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = (v[1]+v[2])*1./2;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] = (v[1]+v[2])*1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] = (v[0]+v[1])*1./2;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] = (v[0]+v[1])*1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] =  0;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] =  0;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] = (v[1]+v[2])*1./2;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] = (v[1]+v[2])*1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] =  0;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] =  0;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] = (v[0]+v[2])*1./2;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] = (v[0]+v[2])*1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] =  0;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] =  0;
  }
  static const short size=48;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn_3n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[1]+1./2;
    res[2][1] = v[0];
    res[2][2] = v[2];
    res[3][0] = v[1]+1./2;
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = v[2];
    res[5][0] = v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]+1./2;
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+1./2;
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = -v[2]+1./2;
    res[8][2] = v[1];
    res[9][0] = -v[0];
    res[9][1] = v[2]+1./2;
    res[9][2] = -v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[2]+1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1]+1./2;
    res[11][2] = v[2]+1./2;
    res[12][0] = v[0];
    res[12][1] = v[2];
    res[12][2] = -v[1]+1./2;
    res[13][0] = -v[0];
    res[13][1] = -v[2];
    res[13][2] = v[1]+1./2;
    res[14][0] = v[2];
    res[14][1] = v[1];
    res[14][2] = -v[0]+1./2;
    res[15][0] = -v[2];
    res[15][1] = -v[1];
    res[15][2] = v[0]+1./2;
    res[16][0] = -v[0]+1./2;
    res[16][1] = v[1];
    res[16][2] = -v[2]+1./2;
    res[17][0] = v[0]+1./2;
    res[17][1] = -v[1];
    res[17][2] = v[2]+1./2;
    res[18][0] = -v[2]+1./2;
    res[18][1] = v[1];
    res[18][2] = v[0];
    res[19][0] = v[2]+1./2;
    res[19][1] = -v[1];
    res[19][2] = -v[0];
    res[20][0] = v[2];
    res[20][1] = v[0];
    res[20][2] = v[1];
    res[21][0] = -v[2];
    res[21][1] = -v[0];
    res[21][2] = -v[1];
    res[22][0] = v[1];
    res[22][1] = v[2];
    res[22][2] = v[0];
    res[23][0] = -v[1];
    res[23][1] = -v[2];
    res[23][2] = -v[0];
    res[24][0] = -v[1]+1./2;
    res[24][1] = -v[2]+1./2;
    res[24][2] = v[0];
    res[25][0] = v[1]+1./2;
    res[25][1] = v[2]+1./2;
    res[25][2] = -v[0];
    res[26][0] = v[2];
    res[26][1] = -v[0]+1./2;
    res[26][2] = -v[1]+1./2;
    res[27][0] = -v[2];
    res[27][1] = v[0]+1./2;
    res[27][2] = v[1]+1./2;
    res[28][0] = -v[1]+1./2;
    res[28][1] = v[2];
    res[28][2] = -v[0]+1./2;
    res[29][0] = v[1]+1./2;
    res[29][1] = -v[2];
    res[29][2] = v[0]+1./2;
    res[30][0] = -v[2]+1./2;
    res[30][1] = -v[0]+1./2;
    res[30][2] = v[1];
    res[31][0] = v[2]+1./2;
    res[31][1] = v[0]+1./2;
    res[31][2] = -v[1];
    res[32][0] = -v[2]+1./2;
    res[32][1] = v[0];
    res[32][2] = -v[1]+1./2;
    res[33][0] = v[2]+1./2;
    res[33][1] = -v[0];
    res[33][2] = v[1]+1./2;
    res[34][0] = v[1];
    res[34][1] = -v[2]+1./2;
    res[34][2] = -v[0]+1./2;
    res[35][0] = -v[1];
    res[35][1] = v[2]+1./2;
    res[35][2] = v[0]+1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2]+1./2;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2]+1./2;
    res[38][0] = -v[1]+1./2;
    res[38][1] = -v[0]+1./2;
    res[38][2] = -v[2]+1./2;
    res[39][0] = v[1]+1./2;
    res[39][1] = v[0]+1./2;
    res[39][2] = v[2]+1./2;
    res[40][0] = -v[0]+1./2;
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0]+1./2;
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0]+1./2;
    res[42][1] = -v[2]+1./2;
    res[42][2] = -v[1]+1./2;
    res[43][0] = v[0]+1./2;
    res[43][1] = v[2]+1./2;
    res[43][2] = v[1]+1./2;
    res[44][0] = v[2];
    res[44][1] = -v[1]+1./2;
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1]+1./2;
    res[45][2] = -v[0];
    res[46][0] = -v[2]+1./2;
    res[46][1] = -v[1]+1./2;
    res[46][2] = -v[0]+1./2;
    res[47][0] = v[2]+1./2;
    res[47][1] = v[1]+1./2;
    res[47][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = -v[0];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = -v[1];
    res[3][1] = v[0];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = -v[0];
    res[4][1] = -v[1];
    res[4][2] = v[2];
    phase[4] = (v[0]+v[1])*1./2;
    res[5][0] = v[0];
    res[5][1] = v[1];
    res[5][2] = -v[2];
    phase[5] = (v[0]+v[1])*1./2;
    res[6][0] = -v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[1];
    res[7][1] = -v[0];
    res[7][2] = -v[2];
    phase[7] = v[1]*1./2;
    res[8][0] = v[0];
    res[8][1] = v[2];
    res[8][2] = -v[1];
    phase[8] = v[1]*1./2;
    res[9][0] = -v[0];
    res[9][1] = -v[2];
    res[9][2] = v[1];
    phase[9] = v[1]*1./2;
    res[10][0] = v[0];
    res[10][1] = -v[1];
    res[10][2] = -v[2];
    phase[10] = (v[1]+v[2])*1./2;
    res[11][0] = -v[0];
    res[11][1] = v[1];
    res[11][2] = v[2];
    phase[11] = (v[1]+v[2])*1./2;
    res[12][0] = v[0];
    res[12][1] = -v[2];
    res[12][2] = v[1];
    phase[12] = v[2]*1./2;
    res[13][0] = -v[0];
    res[13][1] = v[2];
    res[13][2] = -v[1];
    phase[13] = v[2]*1./2;
    res[14][0] = -v[2];
    res[14][1] = v[1];
    res[14][2] = v[0];
    phase[14] = v[2]*1./2;
    res[15][0] = v[2];
    res[15][1] = -v[1];
    res[15][2] = -v[0];
    phase[15] = v[2]*1./2;
    res[16][0] = -v[0];
    res[16][1] = v[1];
    res[16][2] = -v[2];
    phase[16] = (v[0]+v[2])*1./2;
    res[17][0] = v[0];
    res[17][1] = -v[1];
    res[17][2] = v[2];
    phase[17] = (v[0]+v[2])*1./2;
    res[18][0] = v[2];
    res[18][1] = v[1];
    res[18][2] = -v[0];
    phase[18] = v[0]*1./2;
    res[19][0] = -v[2];
    res[19][1] = -v[1];
    res[19][2] = v[0];
    phase[19] = v[0]*1./2;
    res[20][0] = v[1];
    res[20][1] = v[2];
    res[20][2] = v[0];
    phase[20] =  0;
    res[21][0] = -v[1];
    res[21][1] = -v[2];
    res[21][2] = -v[0];
    phase[21] =  0;
    res[22][0] = v[2];
    res[22][1] = v[0];
    res[22][2] = v[1];
    phase[22] =  0;
    res[23][0] = -v[2];
    res[23][1] = -v[0];
    res[23][2] = -v[1];
    phase[23] =  0;
    res[24][0] = v[2];
    res[24][1] = -v[0];
    res[24][2] = -v[1];
    phase[24] = (v[0]+v[1])*1./2;
    res[25][0] = -v[2];
    res[25][1] = v[0];
    res[25][2] = v[1];
    phase[25] = (v[0]+v[1])*1./2;
    res[26][0] = -v[1];
    res[26][1] = -v[2];
    res[26][2] = v[0];
    phase[26] = (v[1]+v[2])*1./2;
    res[27][0] = v[1];
    res[27][1] = v[2];
    res[27][2] = -v[0];
    phase[27] = (v[1]+v[2])*1./2;
    res[28][0] = -v[2];
    res[28][1] = -v[0];
    res[28][2] = v[1];
    phase[28] = (v[0]+v[2])*1./2;
    res[29][0] = v[2];
    res[29][1] = v[0];
    res[29][2] = -v[1];
    phase[29] = (v[0]+v[2])*1./2;
    res[30][0] = -v[1];
    res[30][1] = v[2];
    res[30][2] = -v[0];
    phase[30] = (v[0]+v[1])*1./2;
    res[31][0] = v[1];
    res[31][1] = -v[2];
    res[31][2] = v[0];
    phase[31] = (v[0]+v[1])*1./2;
    res[32][0] = v[1];
    res[32][1] = -v[2];
    res[32][2] = -v[0];
    phase[32] = (v[0]+v[2])*1./2;
    res[33][0] = -v[1];
    res[33][1] = v[2];
    res[33][2] = v[0];
    phase[33] = (v[0]+v[2])*1./2;
    res[34][0] = -v[2];
    res[34][1] = v[0];
    res[34][2] = -v[1];
    phase[34] = (v[1]+v[2])*1./2;
    res[35][0] = v[2];
    res[35][1] = -v[0];
    res[35][2] = v[1];
    phase[35] = (v[1]+v[2])*1./2;
    res[36][0] = v[1];
    res[36][1] = v[0];
    res[36][2] = -v[2];
    phase[36] = v[2]*1./2;
    res[37][0] = -v[1];
    res[37][1] = -v[0];
    res[37][2] = v[2];
    phase[37] = v[2]*1./2;
    res[38][0] = -v[1];
    res[38][1] = -v[0];
    res[38][2] = -v[2];
    phase[38] = (v[0]+v[1]+v[2])*1./2;
    res[39][0] = v[1];
    res[39][1] = v[0];
    res[39][2] = v[2];
    phase[39] = (v[0]+v[1]+v[2])*1./2;
    res[40][0] = -v[0];
    res[40][1] = v[2];
    res[40][2] = v[1];
    phase[40] = v[0]*1./2;
    res[41][0] = v[0];
    res[41][1] = -v[2];
    res[41][2] = -v[1];
    phase[41] = v[0]*1./2;
    res[42][0] = -v[0];
    res[42][1] = -v[2];
    res[42][2] = -v[1];
    phase[42] = (v[0]+v[1]+v[2])*1./2;
    res[43][0] = v[0];
    res[43][1] = v[2];
    res[43][2] = v[1];
    phase[43] = (v[0]+v[1]+v[2])*1./2;
    res[44][0] = v[2];
    res[44][1] = -v[1];
    res[44][2] = v[0];
    phase[44] = v[1]*1./2;
    res[45][0] = -v[2];
    res[45][1] = v[1];
    res[45][2] = -v[0];
    phase[45] = v[1]*1./2;
    res[46][0] = -v[2];
    res[46][1] = -v[1];
    res[46][2] = -v[0];
    phase[46] = (v[0]+v[1]+v[2])*1./2;
    res[47][0] = v[2];
    res[47][1] = v[1];
    res[47][2] = v[0];
    phase[47] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=48;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn11 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
  }
  static const short size=2;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn21a {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1];
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = v[1]*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn21m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1]+1./2;
    res[1][2] = -v[2]+1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] =  0;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn2b {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pn2n {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = -v[2]+1./2;
    res[3][0] = -v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = -v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = -v[0];
    res[3][1] = v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pna21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = v[2]*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnaa {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnab {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnam {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnan {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[0]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[0]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnc2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnca {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pncb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pncm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pncn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[2]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[2]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnm21 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1]+1./2;
    res[1][2] = v[2]+1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] = (v[1]+v[2])*1./2;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] =  0;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnma {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnmb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnmm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[2]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[2]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = v[1]*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = v[1]*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnmn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] =  0;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnn2 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = v[1]+1./2;
    res[2][2] = v[2]+1./2;
    res[3][0] = v[0]+1./2;
    res[3][1] = -v[1]+1./2;
    res[3][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1]+v[2])*1./2;
    res[3][0] = v[0];
    res[3][1] = -v[1];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=4;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnna {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnnb {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = v[1]*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = v[1]*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnnm {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0]+1./2;
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1]+1./2;
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] =  0;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_Pnnn {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0]+1./2;
    res[2][1] = -v[1]+1./2;
    res[2][2] = v[2];
    res[3][0] = v[0]+1./2;
    res[3][1] = v[1]+1./2;
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1]+1./2;
    res[4][2] = -v[2]+1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1]+1./2;
    res[5][2] = v[2]+1./2;
    res[6][0] = -v[0]+1./2;
    res[6][1] = v[1];
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[0]+1./2;
    res[7][1] = -v[1];
    res[7][2] = v[2]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = -v[0];
    res[2][1] = -v[1];
    res[2][2] = v[2];
    phase[2] = (v[0]+v[1])*1./2;
    res[3][0] = v[0];
    res[3][1] = v[1];
    res[3][2] = -v[2];
    phase[3] = (v[0]+v[1])*1./2;
    res[4][0] = v[0];
    res[4][1] = -v[1];
    res[4][2] = -v[2];
    phase[4] = (v[1]+v[2])*1./2;
    res[5][0] = -v[0];
    res[5][1] = v[1];
    res[5][2] = v[2];
    phase[5] = (v[1]+v[2])*1./2;
    res[6][0] = -v[0];
    res[6][1] = v[1];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[2])*1./2;
    res[7][0] = v[0];
    res[7][1] = -v[1];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[2])*1./2;
  }
  static const short size=8;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+2./3;
    res[2][1] = v[1]+1./3;
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0]+2./3;
    res[3][1] = -v[1]+1./3;
    res[3][2] = -v[2]+1./3;
    res[4][0] = v[0]+1./3;
    res[4][1] = v[1]+2./3;
    res[4][2] = v[2]+2./3;
    res[5][0] = -v[0]+1./3;
    res[5][1] = -v[1]+2./3;
    res[5][2] = -v[2]+2./3;
    res[6][0] = -v[1];
    res[6][1] = v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[1]+2./3;
    res[8][1] = v[0]-v[1]+1./3;
    res[8][2] = v[2]+1./3;
    res[9][0] = v[1]+2./3;
    res[9][1] = -v[0]+v[1]+1./3;
    res[9][2] = -v[2]+1./3;
    res[10][0] = -v[1]+1./3;
    res[10][1] = v[0]-v[1]+2./3;
    res[10][2] = v[2]+2./3;
    res[11][0] = v[1]+1./3;
    res[11][1] = -v[0]+v[1]+2./3;
    res[11][2] = -v[2]+2./3;
    res[12][0] = -v[0]+v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]-v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]+v[1]+2./3;
    res[14][1] = -v[0]+1./3;
    res[14][2] = v[2]+1./3;
    res[15][0] = v[0]-v[1]+2./3;
    res[15][1] = v[0]+1./3;
    res[15][2] = -v[2]+1./3;
    res[16][0] = -v[0]+v[1]+1./3;
    res[16][1] = -v[0]+2./3;
    res[16][2] = v[2]+2./3;
    res[17][0] = v[0]-v[1]+1./3;
    res[17][1] = v[0]+2./3;
    res[17][2] = -v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    phase[8] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    phase[16] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
    phase[17] = v[0]*1./3+(v[1]+v[2])*2./3;
  }
  static const short size=18;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+2./3;
    res[2][1] = v[1]+1./3;
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0]+2./3;
    res[3][1] = -v[1]+1./3;
    res[3][2] = -v[2]+1./3;
    res[4][0] = v[0]+1./3;
    res[4][1] = v[1]+2./3;
    res[4][2] = v[2]+2./3;
    res[5][0] = -v[0]+1./3;
    res[5][1] = -v[1]+2./3;
    res[5][2] = -v[2]+2./3;
    res[6][0] = -v[1];
    res[6][1] = v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[1]+2./3;
    res[8][1] = v[0]-v[1]+1./3;
    res[8][2] = v[2]+1./3;
    res[9][0] = v[1]+2./3;
    res[9][1] = -v[0]+v[1]+1./3;
    res[9][2] = -v[2]+1./3;
    res[10][0] = -v[1]+1./3;
    res[10][1] = v[0]-v[1]+2./3;
    res[10][2] = v[2]+2./3;
    res[11][0] = v[1]+1./3;
    res[11][1] = -v[0]+v[1]+2./3;
    res[11][2] = -v[2]+2./3;
    res[12][0] = -v[0]+v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]-v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]+v[1]+2./3;
    res[14][1] = -v[0]+1./3;
    res[14][2] = v[2]+1./3;
    res[15][0] = v[0]-v[1]+2./3;
    res[15][1] = v[0]+1./3;
    res[15][2] = -v[2]+1./3;
    res[16][0] = -v[0]+v[1]+1./3;
    res[16][1] = -v[0]+2./3;
    res[16][2] = v[2]+2./3;
    res[17][0] = v[0]-v[1]+1./3;
    res[17][1] = v[0]+2./3;
    res[17][2] = -v[2]+2./3;
    res[18][0] = v[0]-v[1];
    res[18][1] = -v[1];
    res[18][2] = -v[2]+1./2;
    res[19][0] = -v[0]+v[1];
    res[19][1] = v[1];
    res[19][2] = v[2]+1./2;
    res[20][0] = v[0]-v[1]+2./3;
    res[20][1] = -v[1]+1./3;
    res[20][2] = -v[2]+5./6;
    res[21][0] = -v[0]+v[1]+2./3;
    res[21][1] = v[1]+1./3;
    res[21][2] = v[2]+5./6;
    res[22][0] = v[0]-v[1]+1./3;
    res[22][1] = -v[1]+2./3;
    res[22][2] = -v[2]+1./6;
    res[23][0] = -v[0]+v[1]+1./3;
    res[23][1] = v[1]+2./3;
    res[23][2] = v[2]+1./6;
    res[24][0] = -v[0];
    res[24][1] = -v[0]+v[1];
    res[24][2] = -v[2]+1./2;
    res[25][0] = v[0];
    res[25][1] = v[0]-v[1];
    res[25][2] = v[2]+1./2;
    res[26][0] = -v[0]+2./3;
    res[26][1] = -v[0]+v[1]+1./3;
    res[26][2] = -v[2]+5./6;
    res[27][0] = v[0]+2./3;
    res[27][1] = v[0]-v[1]+1./3;
    res[27][2] = v[2]+5./6;
    res[28][0] = -v[0]+1./3;
    res[28][1] = -v[0]+v[1]+2./3;
    res[28][2] = -v[2]+1./6;
    res[29][0] = v[0]+1./3;
    res[29][1] = v[0]-v[1]+2./3;
    res[29][2] = v[2]+1./6;
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2]+1./2;
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2]+1./2;
    res[32][0] = v[1]+2./3;
    res[32][1] = v[0]+1./3;
    res[32][2] = -v[2]+5./6;
    res[33][0] = -v[1]+2./3;
    res[33][1] = -v[0]+1./3;
    res[33][2] = v[2]+5./6;
    res[34][0] = v[1]+1./3;
    res[34][1] = v[0]+2./3;
    res[34][2] = -v[2]+1./6;
    res[35][0] = -v[1]+1./3;
    res[35][1] = -v[0]+2./3;
    res[35][2] = v[2]+1./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
    res[18][0] = v[0];
    res[18][1] = -v[0]-v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[0]+v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[0]-v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[0]+v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[0]-v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[0]+v[1];
    res[23][2] = v[2];
    res[24][0] = -v[0]-v[1];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0]+v[1];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0]-v[1];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    res[27][0] = v[0]+v[1];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    res[28][0] = -v[0]-v[1];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    res[29][0] = v[0]+v[1];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2];
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2];
    res[32][0] = v[1];
    res[32][1] = v[0];
    res[32][2] = -v[2];
    res[33][0] = -v[1];
    res[33][1] = -v[0];
    res[33][2] = v[2];
    res[34][0] = v[1];
    res[34][1] = v[0];
    res[34][2] = -v[2];
    res[35][0] = -v[1];
    res[35][1] = -v[0];
    res[35][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    phase[8] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    phase[16] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
    phase[17] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[18][0] = v[0];
    res[18][1] = -v[0]-v[1];
    res[18][2] = -v[2];
    phase[18] = v[2]*1./2;
    res[19][0] = -v[0];
    res[19][1] = v[0]+v[1];
    res[19][2] = v[2];
    phase[19] = v[2]*1./2;
    res[20][0] = v[0];
    res[20][1] = -v[0]-v[1];
    res[20][2] = -v[2];
    phase[20] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[21][0] = -v[0];
    res[21][1] = v[0]+v[1];
    res[21][2] = v[2];
    phase[21] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[22][0] = v[0];
    res[22][1] = -v[0]-v[1];
    res[22][2] = -v[2];
    phase[22] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[23][0] = -v[0];
    res[23][1] = v[0]+v[1];
    res[23][2] = v[2];
    phase[23] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[24][0] = -v[0]-v[1];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    phase[24] = v[2]*1./2;
    res[25][0] = v[0]+v[1];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    phase[25] = v[2]*1./2;
    res[26][0] = -v[0]-v[1];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    phase[26] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[27][0] = v[0]+v[1];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    phase[27] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[28][0] = -v[0]-v[1];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    phase[28] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[29][0] = v[0]+v[1];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    phase[29] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2];
    phase[30] = v[2]*1./2;
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2];
    phase[31] = v[2]*1./2;
    res[32][0] = v[1];
    res[32][1] = v[0];
    res[32][2] = -v[2];
    phase[32] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[33][0] = -v[1];
    res[33][1] = -v[0];
    res[33][2] = v[2];
    phase[33] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[34][0] = v[1];
    res[34][1] = v[0];
    res[34][2] = -v[2];
    phase[34] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[35][0] = -v[1];
    res[35][1] = -v[0];
    res[35][2] = v[2];
    phase[35] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
  }
  static const short size=36;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3c_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[1]+1./2;
    res[6][1] = -v[0]+1./2;
    res[6][2] = -v[2]+1./2;
    res[7][0] = v[1]+1./2;
    res[7][1] = v[0]+1./2;
    res[7][2] = v[2]+1./2;
    res[8][0] = -v[0]+1./2;
    res[8][1] = -v[2]+1./2;
    res[8][2] = -v[1]+1./2;
    res[9][0] = v[0]+1./2;
    res[9][1] = v[2]+1./2;
    res[9][2] = v[1]+1./2;
    res[10][0] = -v[2]+1./2;
    res[10][1] = -v[1]+1./2;
    res[10][2] = -v[0]+1./2;
    res[11][0] = v[2]+1./2;
    res[11][1] = v[1]+1./2;
    res[11][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = -v[1];
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = v[1];
    res[10][0] = -v[2];
    res[10][1] = -v[1];
    res[10][2] = -v[0];
    res[11][0] = v[2];
    res[11][1] = v[1];
    res[11][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] = (v[0]+v[1]+v[2])*1./2;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = (v[0]+v[1]+v[2])*1./2;
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = -v[1];
    phase[8] = (v[0]+v[1]+v[2])*1./2;
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = v[1];
    phase[9] = (v[0]+v[1]+v[2])*1./2;
    res[10][0] = -v[2];
    res[10][1] = -v[1];
    res[10][2] = -v[0];
    phase[10] = (v[0]+v[1]+v[2])*1./2;
    res[11][0] = v[2];
    res[11][1] = v[1];
    res[11][2] = v[0];
    phase[11] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0]+2./3;
    res[2][1] = v[1]+1./3;
    res[2][2] = v[2]+1./3;
    res[3][0] = -v[0]+2./3;
    res[3][1] = -v[1]+1./3;
    res[3][2] = -v[2]+1./3;
    res[4][0] = v[0]+1./3;
    res[4][1] = v[1]+2./3;
    res[4][2] = v[2]+2./3;
    res[5][0] = -v[0]+1./3;
    res[5][1] = -v[1]+2./3;
    res[5][2] = -v[2]+2./3;
    res[6][0] = -v[1];
    res[6][1] = v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = v[1];
    res[7][1] = -v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = -v[1]+2./3;
    res[8][1] = v[0]-v[1]+1./3;
    res[8][2] = v[2]+1./3;
    res[9][0] = v[1]+2./3;
    res[9][1] = -v[0]+v[1]+1./3;
    res[9][2] = -v[2]+1./3;
    res[10][0] = -v[1]+1./3;
    res[10][1] = v[0]-v[1]+2./3;
    res[10][2] = v[2]+2./3;
    res[11][0] = v[1]+1./3;
    res[11][1] = -v[0]+v[1]+2./3;
    res[11][2] = -v[2]+2./3;
    res[12][0] = -v[0]+v[1];
    res[12][1] = -v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]-v[1];
    res[13][1] = v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]+v[1]+2./3;
    res[14][1] = -v[0]+1./3;
    res[14][2] = v[2]+1./3;
    res[15][0] = v[0]-v[1]+2./3;
    res[15][1] = v[0]+1./3;
    res[15][2] = -v[2]+1./3;
    res[16][0] = -v[0]+v[1]+1./3;
    res[16][1] = -v[0]+2./3;
    res[16][2] = v[2]+2./3;
    res[17][0] = v[0]-v[1]+1./3;
    res[17][1] = v[0]+2./3;
    res[17][2] = -v[2]+2./3;
    res[18][0] = v[0]-v[1];
    res[18][1] = -v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0]+v[1];
    res[19][1] = v[1];
    res[19][2] = v[2];
    res[20][0] = v[0]-v[1]+2./3;
    res[20][1] = -v[1]+1./3;
    res[20][2] = -v[2]+1./3;
    res[21][0] = -v[0]+v[1]+2./3;
    res[21][1] = v[1]+1./3;
    res[21][2] = v[2]+1./3;
    res[22][0] = v[0]-v[1]+1./3;
    res[22][1] = -v[1]+2./3;
    res[22][2] = -v[2]+2./3;
    res[23][0] = -v[0]+v[1]+1./3;
    res[23][1] = v[1]+2./3;
    res[23][2] = v[2]+2./3;
    res[24][0] = -v[0];
    res[24][1] = -v[0]+v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0];
    res[25][1] = v[0]-v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0]+2./3;
    res[26][1] = -v[0]+v[1]+1./3;
    res[26][2] = -v[2]+1./3;
    res[27][0] = v[0]+2./3;
    res[27][1] = v[0]-v[1]+1./3;
    res[27][2] = v[2]+1./3;
    res[28][0] = -v[0]+1./3;
    res[28][1] = -v[0]+v[1]+2./3;
    res[28][2] = -v[2]+2./3;
    res[29][0] = v[0]+1./3;
    res[29][1] = v[0]-v[1]+2./3;
    res[29][2] = v[2]+2./3;
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2];
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2];
    res[32][0] = v[1]+2./3;
    res[32][1] = v[0]+1./3;
    res[32][2] = -v[2]+1./3;
    res[33][0] = -v[1]+2./3;
    res[33][1] = -v[0]+1./3;
    res[33][2] = v[2]+1./3;
    res[34][0] = v[1]+1./3;
    res[34][1] = v[0]+2./3;
    res[34][2] = -v[2]+2./3;
    res[35][0] = -v[1]+1./3;
    res[35][1] = -v[0]+2./3;
    res[35][2] = v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
    res[18][0] = v[0];
    res[18][1] = -v[0]-v[1];
    res[18][2] = -v[2];
    res[19][0] = -v[0];
    res[19][1] = v[0]+v[1];
    res[19][2] = v[2];
    res[20][0] = v[0];
    res[20][1] = -v[0]-v[1];
    res[20][2] = -v[2];
    res[21][0] = -v[0];
    res[21][1] = v[0]+v[1];
    res[21][2] = v[2];
    res[22][0] = v[0];
    res[22][1] = -v[0]-v[1];
    res[22][2] = -v[2];
    res[23][0] = -v[0];
    res[23][1] = v[0]+v[1];
    res[23][2] = v[2];
    res[24][0] = -v[0]-v[1];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    res[25][0] = v[0]+v[1];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    res[26][0] = -v[0]-v[1];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    res[27][0] = v[0]+v[1];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    res[28][0] = -v[0]-v[1];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    res[29][0] = v[0]+v[1];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2];
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2];
    res[32][0] = v[1];
    res[32][1] = v[0];
    res[32][2] = -v[2];
    res[33][0] = -v[1];
    res[33][1] = -v[0];
    res[33][2] = v[2];
    res[34][0] = v[1];
    res[34][1] = v[0];
    res[34][2] = -v[2];
    res[35][0] = -v[1];
    res[35][1] = -v[0];
    res[35][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[3][0] = -v[0];
    res[3][1] = -v[1];
    res[3][2] = -v[2];
    phase[3] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[4][0] = v[0];
    res[4][1] = v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[5][0] = -v[0];
    res[5][1] = -v[1];
    res[5][2] = -v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = v[1];
    res[6][1] = -v[0]-v[1];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[1];
    res[7][1] = v[0]+v[1];
    res[7][2] = -v[2];
    phase[7] =  0;
    res[8][0] = v[1];
    res[8][1] = -v[0]-v[1];
    res[8][2] = v[2];
    phase[8] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[9][0] = -v[1];
    res[9][1] = v[0]+v[1];
    res[9][2] = -v[2];
    phase[9] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[10][0] = v[1];
    res[10][1] = -v[0]-v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[11][0] = -v[1];
    res[11][1] = v[0]+v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[0];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[0];
    res[13][2] = -v[2];
    phase[13] =  0;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[0];
    res[14][2] = v[2];
    phase[14] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[15][0] = v[0]+v[1];
    res[15][1] = -v[0];
    res[15][2] = -v[2];
    phase[15] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[16][0] = -v[0]-v[1];
    res[16][1] = v[0];
    res[16][2] = v[2];
    phase[16] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[17][0] = v[0]+v[1];
    res[17][1] = -v[0];
    res[17][2] = -v[2];
    phase[17] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[18][0] = v[0];
    res[18][1] = -v[0]-v[1];
    res[18][2] = -v[2];
    phase[18] =  0;
    res[19][0] = -v[0];
    res[19][1] = v[0]+v[1];
    res[19][2] = v[2];
    phase[19] =  0;
    res[20][0] = v[0];
    res[20][1] = -v[0]-v[1];
    res[20][2] = -v[2];
    phase[20] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[21][0] = -v[0];
    res[21][1] = v[0]+v[1];
    res[21][2] = v[2];
    phase[21] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[22][0] = v[0];
    res[22][1] = -v[0]-v[1];
    res[22][2] = -v[2];
    phase[22] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[23][0] = -v[0];
    res[23][1] = v[0]+v[1];
    res[23][2] = v[2];
    phase[23] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[24][0] = -v[0]-v[1];
    res[24][1] = v[1];
    res[24][2] = -v[2];
    phase[24] =  0;
    res[25][0] = v[0]+v[1];
    res[25][1] = -v[1];
    res[25][2] = v[2];
    phase[25] =  0;
    res[26][0] = -v[0]-v[1];
    res[26][1] = v[1];
    res[26][2] = -v[2];
    phase[26] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[27][0] = v[0]+v[1];
    res[27][1] = -v[1];
    res[27][2] = v[2];
    phase[27] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[28][0] = -v[0]-v[1];
    res[28][1] = v[1];
    res[28][2] = -v[2];
    phase[28] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[29][0] = v[0]+v[1];
    res[29][1] = -v[1];
    res[29][2] = v[2];
    phase[29] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[30][0] = v[1];
    res[30][1] = v[0];
    res[30][2] = -v[2];
    phase[30] =  0;
    res[31][0] = -v[1];
    res[31][1] = -v[0];
    res[31][2] = v[2];
    phase[31] =  0;
    res[32][0] = v[1];
    res[32][1] = v[0];
    res[32][2] = -v[2];
    phase[32] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[33][0] = -v[1];
    res[33][1] = -v[0];
    res[33][2] = v[2];
    phase[33] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[34][0] = v[1];
    res[34][1] = v[0];
    res[34][2] = -v[2];
    phase[34] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[35][0] = -v[1];
    res[35][1] = -v[0];
    res[35][2] = v[2];
    phase[35] = v[0]*1./3+(v[1]+v[2])*2./3;
  }
  static const short size=36;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R_3m_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[2];
    res[3][1] = -v[0];
    res[3][2] = -v[1];
    res[4][0] = v[1];
    res[4][1] = v[2];
    res[4][2] = v[0];
    res[5][0] = -v[1];
    res[5][1] = -v[2];
    res[5][2] = -v[0];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = -v[1];
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = v[1];
    res[10][0] = -v[2];
    res[10][1] = -v[1];
    res[10][2] = -v[0];
    res[11][0] = v[2];
    res[11][1] = v[1];
    res[11][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = -v[1];
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = v[1];
    res[10][0] = -v[2];
    res[10][1] = -v[1];
    res[10][2] = -v[0];
    res[11][0] = v[2];
    res[11][1] = v[1];
    res[11][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = -v[0];
    res[1][1] = -v[1];
    res[1][2] = -v[2];
    phase[1] =  0;
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[2];
    res[3][2] = -v[0];
    phase[3] =  0;
    res[4][0] = v[2];
    res[4][1] = v[0];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[0];
    res[5][2] = -v[1];
    phase[5] =  0;
    res[6][0] = -v[1];
    res[6][1] = -v[0];
    res[6][2] = -v[2];
    phase[6] =  0;
    res[7][0] = v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] =  0;
    res[8][0] = -v[0];
    res[8][1] = -v[2];
    res[8][2] = -v[1];
    phase[8] =  0;
    res[9][0] = v[0];
    res[9][1] = v[2];
    res[9][2] = v[1];
    phase[9] =  0;
    res[10][0] = -v[2];
    res[10][1] = -v[1];
    res[10][2] = -v[0];
    phase[10] =  0;
    res[11][0] = v[2];
    res[11][1] = v[1];
    res[11][2] = v[0];
    phase[11] =  0;
  }
  static const short size=12;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+2./3;
    res[1][1] = v[1]+1./3;
    res[1][2] = v[2]+1./3;
    res[2][0] = v[0]+1./3;
    res[2][1] = v[1]+2./3;
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[1];
    res[3][1] = v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1]+2./3;
    res[4][1] = v[0]-v[1]+1./3;
    res[4][2] = v[2]+1./3;
    res[5][0] = -v[1]+1./3;
    res[5][1] = v[0]-v[1]+2./3;
    res[5][2] = v[2]+2./3;
    res[6][0] = -v[0]+v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]+v[1]+2./3;
    res[7][1] = -v[0]+1./3;
    res[7][2] = v[2]+1./3;
    res[8][0] = -v[0]+v[1]+1./3;
    res[8][1] = -v[0]+2./3;
    res[8][2] = v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] = v[0]*1./3+(v[1]+v[2])*2./3;
  }
  static const short size=9;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R32 {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+2./3;
    res[1][1] = v[1]+1./3;
    res[1][2] = v[2]+1./3;
    res[2][0] = v[0]+1./3;
    res[2][1] = v[1]+2./3;
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[1];
    res[3][1] = v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1]+2./3;
    res[4][1] = v[0]-v[1]+1./3;
    res[4][2] = v[2]+1./3;
    res[5][0] = -v[1]+1./3;
    res[5][1] = v[0]-v[1]+2./3;
    res[5][2] = v[2]+2./3;
    res[6][0] = -v[0]+v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]+v[1]+2./3;
    res[7][1] = -v[0]+1./3;
    res[7][2] = v[2]+1./3;
    res[8][0] = -v[0]+v[1]+1./3;
    res[8][1] = -v[0]+2./3;
    res[8][2] = v[2]+2./3;
    res[9][0] = v[0]-v[1];
    res[9][1] = -v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0]-v[1]+2./3;
    res[10][1] = -v[1]+1./3;
    res[10][2] = -v[2]+1./3;
    res[11][0] = v[0]-v[1]+1./3;
    res[11][1] = -v[1]+2./3;
    res[11][2] = -v[2]+2./3;
    res[12][0] = -v[0];
    res[12][1] = -v[0]+v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0]+2./3;
    res[13][1] = -v[0]+v[1]+1./3;
    res[13][2] = -v[2]+1./3;
    res[14][0] = -v[0]+1./3;
    res[14][1] = -v[0]+v[1]+2./3;
    res[14][2] = -v[2]+2./3;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = v[1]+2./3;
    res[16][1] = v[0]+1./3;
    res[16][2] = -v[2]+1./3;
    res[17][0] = v[1]+1./3;
    res[17][1] = v[0]+2./3;
    res[17][2] = -v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = -v[2];
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = -v[2];
    res[11][0] = v[0];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    res[13][0] = -v[0]-v[1];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    res[17][0] = v[1];
    res[17][1] = v[0];
    res[17][2] = -v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[9][0] = v[0];
    res[9][1] = -v[0]-v[1];
    res[9][2] = -v[2];
    phase[9] =  0;
    res[10][0] = v[0];
    res[10][1] = -v[0]-v[1];
    res[10][2] = -v[2];
    phase[10] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[11][0] = v[0];
    res[11][1] = -v[0]-v[1];
    res[11][2] = -v[2];
    phase[11] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[12][0] = -v[0]-v[1];
    res[12][1] = v[1];
    res[12][2] = -v[2];
    phase[12] =  0;
    res[13][0] = -v[0]-v[1];
    res[13][1] = v[1];
    res[13][2] = -v[2];
    phase[13] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[14][0] = -v[0]-v[1];
    res[14][1] = v[1];
    res[14][2] = -v[2];
    phase[14] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[15][0] = v[1];
    res[15][1] = v[0];
    res[15][2] = -v[2];
    phase[15] =  0;
    res[16][0] = v[1];
    res[16][1] = v[0];
    res[16][2] = -v[2];
    phase[16] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[17][0] = v[1];
    res[17][1] = v[0];
    res[17][2] = -v[2];
    phase[17] = v[0]*1./3+(v[1]+v[2])*2./3;
  }
  static const short size=18;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R32_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = -v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[1];
    res[5][2] = -v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = -v[1];
    res[5][0] = -v[2];
    res[5][1] = -v[1];
    res[5][2] = -v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
    res[3][0] = -v[1];
    res[3][1] = -v[0];
    res[3][2] = -v[2];
    phase[3] =  0;
    res[4][0] = -v[0];
    res[4][1] = -v[2];
    res[4][2] = -v[1];
    phase[4] =  0;
    res[5][0] = -v[2];
    res[5][1] = -v[1];
    res[5][2] = -v[0];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
  }
  static const short size=3;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3c {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+2./3;
    res[1][1] = v[1]+1./3;
    res[1][2] = v[2]+1./3;
    res[2][0] = v[0]+1./3;
    res[2][1] = v[1]+2./3;
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[1];
    res[3][1] = v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1]+2./3;
    res[4][1] = v[0]-v[1]+1./3;
    res[4][2] = v[2]+1./3;
    res[5][0] = -v[1]+1./3;
    res[5][1] = v[0]-v[1]+2./3;
    res[5][2] = v[2]+2./3;
    res[6][0] = -v[0]+v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]+v[1]+2./3;
    res[7][1] = -v[0]+1./3;
    res[7][2] = v[2]+1./3;
    res[8][0] = -v[0]+v[1]+1./3;
    res[8][1] = -v[0]+2./3;
    res[8][2] = v[2]+2./3;
    res[9][0] = -v[0]+v[1];
    res[9][1] = v[1];
    res[9][2] = v[2]+1./2;
    res[10][0] = -v[0]+v[1]+2./3;
    res[10][1] = v[1]+1./3;
    res[10][2] = v[2]+5./6;
    res[11][0] = -v[0]+v[1]+1./3;
    res[11][1] = v[1]+2./3;
    res[11][2] = v[2]+1./6;
    res[12][0] = v[0];
    res[12][1] = v[0]-v[1];
    res[12][2] = v[2]+1./2;
    res[13][0] = v[0]+2./3;
    res[13][1] = v[0]-v[1]+1./3;
    res[13][2] = v[2]+5./6;
    res[14][0] = v[0]+1./3;
    res[14][1] = v[0]-v[1]+2./3;
    res[14][2] = v[2]+1./6;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2]+1./2;
    res[16][0] = -v[1]+2./3;
    res[16][1] = -v[0]+1./3;
    res[16][2] = v[2]+5./6;
    res[17][0] = -v[1]+1./3;
    res[17][1] = -v[0]+2./3;
    res[17][2] = v[2]+1./6;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = v[0]+v[1];
    res[11][2] = v[2];
    res[12][0] = v[0]+v[1];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0]+v[1];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2];
    res[16][0] = -v[1];
    res[16][1] = -v[0];
    res[16][2] = v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    phase[9] = v[2]*1./2;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[11][0] = -v[0];
    res[11][1] = v[0]+v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[12][0] = v[0]+v[1];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] = v[2]*1./2;
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[14][0] = v[0]+v[1];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2];
    phase[15] = v[2]*1./2;
    res[16][0] = -v[1];
    res[16][1] = -v[0];
    res[16][2] = v[2];
    phase[16] = v[0]*2./3+v[1]*1./3+v[2]*5./6;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] = v[0]*1./3+v[1]*2./3+v[2]*1./6;
  }
  static const short size=18;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3c_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = v[1]+1./2;
    res[3][1] = v[0]+1./2;
    res[3][2] = v[2]+1./2;
    res[4][0] = v[0]+1./2;
    res[4][1] = v[2]+1./2;
    res[4][2] = v[1]+1./2;
    res[5][0] = v[2]+1./2;
    res[5][1] = v[1]+1./2;
    res[5][2] = v[0]+1./2;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[1];
    res[5][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] = (v[0]+v[1]+v[2])*1./2;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = v[1];
    phase[4] = (v[0]+v[1]+v[2])*1./2;
    res[5][0] = v[2];
    res[5][1] = v[1];
    res[5][2] = v[0];
    phase[5] = (v[0]+v[1]+v[2])*1./2;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3m {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0]+2./3;
    res[1][1] = v[1]+1./3;
    res[1][2] = v[2]+1./3;
    res[2][0] = v[0]+1./3;
    res[2][1] = v[1]+2./3;
    res[2][2] = v[2]+2./3;
    res[3][0] = -v[1];
    res[3][1] = v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = -v[1]+2./3;
    res[4][1] = v[0]-v[1]+1./3;
    res[4][2] = v[2]+1./3;
    res[5][0] = -v[1]+1./3;
    res[5][1] = v[0]-v[1]+2./3;
    res[5][2] = v[2]+2./3;
    res[6][0] = -v[0]+v[1];
    res[6][1] = -v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]+v[1]+2./3;
    res[7][1] = -v[0]+1./3;
    res[7][2] = v[2]+1./3;
    res[8][0] = -v[0]+v[1]+1./3;
    res[8][1] = -v[0]+2./3;
    res[8][2] = v[2]+2./3;
    res[9][0] = -v[0]+v[1];
    res[9][1] = v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0]+v[1]+2./3;
    res[10][1] = v[1]+1./3;
    res[10][2] = v[2]+1./3;
    res[11][0] = -v[0]+v[1]+1./3;
    res[11][1] = v[1]+2./3;
    res[11][2] = v[2]+2./3;
    res[12][0] = v[0];
    res[12][1] = v[0]-v[1];
    res[12][2] = v[2];
    res[13][0] = v[0]+2./3;
    res[13][1] = v[0]-v[1]+1./3;
    res[13][2] = v[2]+1./3;
    res[14][0] = v[0]+1./3;
    res[14][1] = v[0]-v[1]+2./3;
    res[14][2] = v[2]+2./3;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2];
    res[16][0] = -v[1]+2./3;
    res[16][1] = -v[0]+1./3;
    res[16][2] = v[2]+1./3;
    res[17][0] = -v[1]+1./3;
    res[17][1] = -v[0]+2./3;
    res[17][2] = v[2]+2./3;
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    res[11][0] = -v[0];
    res[11][1] = v[0]+v[1];
    res[11][2] = v[2];
    res[12][0] = v[0]+v[1];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    res[14][0] = v[0]+v[1];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2];
    res[16][0] = -v[1];
    res[16][1] = -v[0];
    res[16][2] = v[2];
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[0];
    res[1][1] = v[1];
    res[1][2] = v[2];
    phase[1] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[2][0] = v[0];
    res[2][1] = v[1];
    res[2][2] = v[2];
    phase[2] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[3][0] = v[1];
    res[3][1] = -v[0]-v[1];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[1];
    res[4][1] = -v[0]-v[1];
    res[4][2] = v[2];
    phase[4] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[5][0] = v[1];
    res[5][1] = -v[0]-v[1];
    res[5][2] = v[2];
    phase[5] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[6][0] = -v[0]-v[1];
    res[6][1] = v[0];
    res[6][2] = v[2];
    phase[6] =  0;
    res[7][0] = -v[0]-v[1];
    res[7][1] = v[0];
    res[7][2] = v[2];
    phase[7] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[8][0] = -v[0]-v[1];
    res[8][1] = v[0];
    res[8][2] = v[2];
    phase[8] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[9][0] = -v[0];
    res[9][1] = v[0]+v[1];
    res[9][2] = v[2];
    phase[9] =  0;
    res[10][0] = -v[0];
    res[10][1] = v[0]+v[1];
    res[10][2] = v[2];
    phase[10] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[11][0] = -v[0];
    res[11][1] = v[0]+v[1];
    res[11][2] = v[2];
    phase[11] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[12][0] = v[0]+v[1];
    res[12][1] = -v[1];
    res[12][2] = v[2];
    phase[12] =  0;
    res[13][0] = v[0]+v[1];
    res[13][1] = -v[1];
    res[13][2] = v[2];
    phase[13] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[14][0] = v[0]+v[1];
    res[14][1] = -v[1];
    res[14][2] = v[2];
    phase[14] = v[0]*1./3+(v[1]+v[2])*2./3;
    res[15][0] = -v[1];
    res[15][1] = -v[0];
    res[15][2] = v[2];
    phase[15] =  0;
    res[16][0] = -v[1];
    res[16][1] = -v[0];
    res[16][2] = v[2];
    phase[16] = v[0]*2./3+(v[1]+v[2])*1./3;
    res[17][0] = -v[1];
    res[17][1] = -v[0];
    res[17][2] = v[2];
    phase[17] = v[0]*1./3+(v[1]+v[2])*2./3;
  }
  static const short size=18;
  static const char lattice='R';
  static const olxstr fullName, hallSymbol;
};
struct FastSG_R3m_r {
  template <class pt, class vt> static inline void GenPos(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[2];
    res[1][1] = v[0];
    res[1][2] = v[1];
    res[2][0] = v[1];
    res[2][1] = v[2];
    res[2][2] = v[0];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[1];
    res[5][2] = v[0];
  }
  template <class pt, class vt> static inline void GenHkl(const pt& v, vt& res)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = v[1];
    res[5][0] = v[2];
    res[5][1] = v[1];
    res[5][2] = v[0];
  }
  template <class pt, class vt, class vt1> static inline void GenHkl(const pt& v, vt& res, vt1& phase)  {
    res[0][0] = v[0];
    res[0][1] = v[1];
    res[0][2] = v[2];
    phase[0] =  0;
    res[1][0] = v[1];
    res[1][1] = v[2];
    res[1][2] = v[0];
    phase[1] =  0;
    res[2][0] = v[2];
    res[2][1] = v[0];
    res[2][2] = v[1];
    phase[2] =  0;
    res[3][0] = v[1];
    res[3][1] = v[0];
    res[3][2] = v[2];
    phase[3] =  0;
    res[4][0] = v[0];
    res[4][1] = v[2];
    res[4][2] = v[1];
    phase[4] =  0;
    res[5][0] = v[2];
    res[5][1] = v[1];
    res[5][2] = v[0];
    phase[5] =  0;
  }
  static const short size=6;
  static const char lattice='P';
  static const olxstr fullName, hallSymbol;
};


EndXlibNamespace()

#endif
